<script type="module">
(function(){
  // ---------- CONFIG ----------
  const ENDPOINTS = {
    xrpUsd: 'https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd',
    bagSpot: 'https://api.getthebag.io/bag-price.json'
  };

  // ---------- Symbols (emoji) ----------
  const SYM = ["7️⃣","💎","🪙","👜","▬","🍒"]; // fillers + pay
  const PAY_SYMS=["🪙","💎","7️⃣"];            // scratch common
  const PAYS    ={ "7️⃣":2.0, "💎":1.25, "🪙":1.0 };

  // Paylines (3 horizontals only)
  const ROWS = [
    [[0,0],[0,1],[0,2]],
    [[1,0],[1,1],[1,2]],
    [[2,0],[2,1],[2,2]],
  ];

  // ---------- DOM refs ----------
  const strips=[...document.querySelectorAll('.strip')];
  const spinBtn=document.getElementById('spin');
  const betUp=document.getElementById('betUp'), betDown=document.getElementById('betDown');
  const curBAG=document.getElementById('curBAG'), curXRP=document.getElementById('curXRP');

  const balEl=document.getElementById('bal'), betEl=document.getElementById('betVal'), winEl=document.getElementById('win');
  const balUsdEl=document.getElementById('balUsd'), betUsdEl=document.getElementById('betUsd'), winUsdEl=document.getElementById('winUsd');

  const lastResult=document.getElementById('lastResult'), lastMult=document.getElementById('lastMult'), lastProfit=document.getElementById('lastProfit');
  const overlay=document.getElementById('winOverlay'), badge=document.getElementById('winBadge'); const cabinet=document.querySelector('.cabinet');

  const xrpUsdEl=document.getElementById('xrpUsd'), bagXrpEl=document.getElementById('bagXrp'), bagUsdEl=document.getElementById('bagUsd'), pxTimeEl=document.getElementById('pxTime'), pxDemoEl=document.getElementById('pxDemo');
  const ariaLive=document.getElementById('ariaLive');

  // Sounds + unlock (mobile autoplay policies)
  const sSpin=document.getElementById('sSpin'),
        sWin=document.getElementById('sWin'),
        sScratch=document.getElementById('sScratch'),
        sLose=document.getElementById('sLose');
  [sSpin,sWin,sScratch,sLose].forEach(a=>{ a.muted=true; a.volume=1; });
  sSpin.volume = 0.35; sWin.volume = 0.9; sScratch.volume = 0.7; sLose.volume = 0.55;

  const unlockAudio=()=>{
    [sSpin,sWin,sScratch,sLose].forEach(a=>{
      try{ a.muted=false; a.play().then(()=>a.pause()).catch(()=>{});}catch(e){}
    });
    window.removeEventListener('pointerdown',unlockAudio);
  };
  window.addEventListener('pointerdown',unlockAudio,{once:true});

  // ---------- State ----------
  let balance=10000, currency='BAG';
  let prices={xrpUsd:null, bagXrp:null, bagUsd:null};
  const CELL_H=93;

  // ---------- Reels (visible immediately) ----------
  const makeCell=s=>{const d=document.createElement('div'); d.className='cell'; d.textContent=s; return d;};
  const fillStrip=(strip,arr)=>{strip.innerHTML=''; arr.forEach(s=>strip.appendChild(makeCell(s)));};

  function initReelsVisible(){
    const starter=["🍒","▬","🪙"]; // placeholders so nothing looks blank
    for(const strip of strips){ fillStrip(strip, starter); strip.style.transition='none'; strip.style.transform='translateY(0)'; }
    requestAnimationFrame(()=>{ for(const strip of strips){ strip.style.transition='transform 2800ms cubic-bezier(.07,.95,.05,1)'; }});
  }
  if (document.readyState === 'complete' || document.readyState === 'interactive') initReelsVisible();
  else window.addEventListener('load', initReelsVisible);

  // ---------- Pricing ----------
  const fmt=n=>(n==null)?'—':(Math.abs(n)>=1?n.toFixed(2):n.toFixed(6));
  const fmtUsd=n=>(n==null)?'—':'$'+(Math.abs(n)>=1?n.toFixed(2):n.toFixed(6));

  function setCurrency(cur){ currency=cur; curBAG.style.opacity=cur==='BAG'?1:.85; curXRP.style.opacity=cur==='XRP'?1:.85; renderUsd(); }
  curBAG.onclick=()=>setCurrency('BAG'); curXRP.onclick=()=>setCurrency('XRP');

  const setBet=v=>{ v=Math.max(1,Math.min(2000,v|0)); betEl.textContent=v; renderUsd(); };
  betUp.onclick=()=>setBet((+betEl.textContent)+10);
  betDown.onclick=()=>setBet((+betEl.textContent)-10);

  balEl.textContent=balance; setCurrency('BAG'); setBet(10);

  async function withTimeout(promise,ms=4000){let t;const timeout=new Promise((_,rej)=>t=setTimeout(()=>rej(new Error('timeout')),ms));try{return await Promise.race([promise,timeout]);}finally{clearTimeout(t);}}
  async function fetchXrpUsd(){const r=await withTimeout(fetch(ENDPOINTS.xrpUsd,{cache:'no-store'}));const j=await r.json();return j?.ripple?.usd ?? null;}
  async function fetchBagSpot(){
    const r=await withTimeout(fetch(ENDPOINTS.bagSpot,{cache:'no-store'}));
    const j=await r.json();
    if(j && typeof j.price_xrp==='number')return j.price_xrp;
    if(j && typeof j.bag_per_xrp==='number' && j.bag_per_xrp>0)return 1/j.bag_per_xrp;
    return null;
  }
  async function refreshPrices(){
    let demo=false;
    try{
      const [xusd,bxx]=await Promise.allSettled([fetchXrpUsd(),fetchBagSpot()]);
      if(xusd.status==='fulfilled'&&xusd.value)prices.xrpUsd=xusd.value; else demo=true;
      if(bxx.status==='fulfilled'&&bxx.value)prices.bagXrp=bxx.value; else demo=true;
      if(!prices.xrpUsd||!prices.bagXrp){demo=true;prices.xrpUsd=prices.xrpUsd??0.55;prices.bagXrp=prices.bagXrp??0.000002;}
      prices.bagUsd=prices.bagXrp*prices.xrpUsd;
      xrpUsdEl.textContent=fmt(prices.xrpUsd);
      bagXrpEl.textContent=fmt(prices.bagXrp);
      bagUsdEl.textContent=fmt(prices.bagUsd);
      pxTimeEl.textContent=new Date().toLocaleTimeString();
      pxDemoEl.textContent=demo?'(demo)':'';
      renderUsd();
    }catch(e){
      prices={xrpUsd:0.55,bagXrp:0.000002,bagUsd:0.55*0.000002};
      xrpUsdEl.textContent=fmt(prices.xrpUsd);
      bagXrpEl.textContent=fmt(prices.bagXrp);
      bagUsdEl.textContent=fmt(prices.bagUsd);
      pxTimeEl.textContent=new Date().toLocaleTimeString();
      pxDemoEl.textContent='(demo)';
      renderUsd();
    }
  }
  function renderUsd(){
    const bet=+betEl.textContent;
    let betUsd='—',balUsd='—',winUsd='—';
    if(currency==='BAG'&&prices.bagUsd){
      betUsd=fmtUsd(bet*prices.bagUsd); balUsd=fmtUsd(balance*prices.bagUsd); winUsd=fmtUsd((+winEl.textContent||0)*prices.bagUsd);
    }else if(currency==='XRP'&&prices.xrpUsd){
      betUsd=fmtUsd(bet*prices.xrpUsd); balUsd=fmtUsd(balance*prices.xrpUsd); winUsd=fmtUsd((+winEl.textContent||0)*prices.xrpUsd);
    }
    betUsdEl.textContent=betUsd; balUsdEl.textContent=balUsd; winUsdEl.textContent=winUsd;
  }
  refreshPrices(); setInterval(refreshPrices,30000);

  // ---------- Demo server now returns winning line + symbol ----------
  function demoServer(stake){
    const rng=()=>SYM[(Math.random()*SYM.length)|0];
    const winSpin=Math.random()<0.495;
    if(winSpin){
      const weights=[18,7,2]; // 🪙, 💎, 7️⃣
      const tot=weights.reduce((a,b)=>a+b,0);
      let r=Math.random()*tot, idx=0;
      for(let i=0;i<weights.length;i++){ if((r-=weights[i])<=0){ idx=i; break; } }
      const sym=PAY_SYMS[idx];
      const line=(Math.random()*ROWS.length)|0;
      const g=[[rng(),rng(),rng()],[rng(),rng(),rng()],[rng(),rng(),rng()]];
      const set3=(a,b,c)=>{g[a[0]][a[1]]=sym; g[b[0]][b[1]]=sym; g[c[0]][c[1]]=sym;};
      set3(...ROWS[line]);
      return {result:g,totalPayout:PAYS[sym]*stake,stake, winLine:line, winSymbol:sym};
    }else{
      // ensure no paying 3-in-row
      let tries=0;
      while(true){
        const rng2=()=>SYM[(Math.random()*SYM.length)|0];
        const g=[[rng2(),rng2(),rng2()],[rng2(),rng2(),rng2()],[rng2(),rng2(),rng2()]];
        let paying=false;
        for(const L of ROWS){
          const [a,b,c]=L, sA=g[a[0]][a[1]];
          if(sA===g[b[0]][b[1]] && sA===g[c[0]][c[1]] && PAYS[sA]){ paying=true; break; }
        }
        if(!paying || tries++>20) return {result:g,totalPayout:0,stake, winLine:null, winSymbol:null};
      }
    }
  }

  // ---------- Highlight helpers (Dice-like feedback) ----------
  function clearHighlights(){
    for(const strip of strips){ [...strip.children].forEach(cell=>cell.classList.remove('win','scratch')); }
  }
  function highlightWinLine(lineIdx, type){
    if(lineIdx==null) return;
    const coords = ROWS[lineIdx]; // 3 coords
    coords.forEach(([row, col])=>{
      const cell = strips[col].children[row];
      if(cell){ cell.classList.add(type==='scratch' ? 'scratch' : 'win'); }
    });
  }
  function popReadouts(){ [lastResult,lastMult,lastProfit].forEach(el=>{ el.classList.remove('read-pop'); void el.offsetWidth; el.classList.add('read-pop'); }); }

  // ---------- Confetti ----------
  const confettiCanvas = document.getElementById('confetti');
  const ctx = confettiCanvas.getContext('2d');
  function fitConfetti(){ const r = confettiCanvas.getBoundingClientRect(); confettiCanvas.width = r.width * devicePixelRatio; confettiCanvas.height = r.height * devicePixelRatio; }
  new ResizeObserver(fitConfetti).observe(confettiCanvas); fitConfetti();

  function runConfetti(burst=80){
    const W=confettiCanvas.width, H=confettiCanvas.height;
    const parts = Array.from({length:burst}, ()=>({
      x: Math.random()*W, y: -20, vy: 2+Math.random()*3, vx: (Math.random()-.5)*2,
      s: 4+Math.random()*6, r: Math.random()*Math.PI, vr:(Math.random()-.5)*0.2,
      c: Math.random()>.5 ? '#f2c76b' : '#ffdfa0'
    }));
    let t=0, raf;
    function step(){
      ctx.clearRect(0,0,W,H);
      for(const p of parts){
        p.vy += 0.06; p.x+=p.vx; p.y+=p.vy; p.r+=p.vr;
        ctx.save(); ctx.translate(p.x, p.y); ctx.rotate(p.r);
        ctx.fillStyle=p.c; ctx.fillRect(-p.s/2,-p.s/2,p.s,p.s);
        ctx.restore();
      }
      t++;
      if(t<120) raf=requestAnimationFrame(step); else ctx.clearRect(0,0,W,H);
    }
    cancelAnimationFrame(raf); step();
  }

  // ---------- Animation ----------
  async function animateToGrid(rows){
    const cols=[0,1,2].map(ci=>[rows[0][ci],rows[1][ci],rows[2][ci]]);
    const fillerLen=16; // longer spin
    await Promise.all(cols.map((colSyms,ci)=>new Promise(resolve=>{
      const strip=strips[ci];
      const filler=Array.from({length:fillerLen},_=>SYM[(Math.random()*SYM.length)|0]);
      const stack=[...filler,...colSyms];
      fillStrip(strip,stack);
      const total=(stack.length-3)*CELL_H;
      requestAnimationFrame(()=>{
        strip.style.transform=`translateY(-${total}px)`;
        strip.addEventListener('transitionend',()=>{
          fillStrip(strip,colSyms);
          strip.style.transition='none'; strip.style.transform='translateY(0)';
          strip.getBoundingClientRect(); strip.style.transition='transform 2800ms cubic-bezier(.07,.95,.05,1)';
          resolve();
        },{once:true});
      });
    })));
  }

  // ---------- Spin flow ----------
  spinBtn.addEventListener('click', async ()=>{
    const stake=+betEl.textContent;
    spinBtn.disabled=true; winEl.textContent='…';
    overlay.classList.remove('show'); badge.classList.remove('pop'); cabinet.classList.remove('win-glow','shake');
    clearHighlights();

    try{
      // spin loop sound
      sSpin.currentTime=0; sSpin.loop=true; sSpin.play().catch(()=>{});

      // DEMO spin (replace with backend if needed)
      const data = demoServer(stake);

      // animate reels
      await animateToGrid(data.result);

      // stop loop
      try{ sSpin.pause(); sSpin.currentTime=0; }catch(_){}

      const payout=data.totalPayout||0;
      winEl.textContent=payout;

      const mult=stake? (payout/stake) : 0;
      lastResult.textContent=(mult>1)?'Win ✅':(mult===1?'Scratch ⏸️':'Lose ❌');
      lastMult.textContent=mult?`${mult.toFixed(2)}×`:'0×';
      lastProfit.textContent=(payout-stake).toString();
      popReadouts();

      // celebrations aligned with Dice:
      if(mult>1){
        // WIN / JACKPOT
        badge.textContent=(mult>=2)?'JACKPOT! 🎉':'WIN! 🎉';
        overlay.classList.add('show'); badge.classList.add('pop');
        cabinet.classList.add('win-glow'); if(mult>=2) cabinet.classList.add('shake');
        highlightWinLine(data.winLine, 'win');
        sWin.currentTime=0; sWin.play().catch(()=>{});
        runConfetti(mult>=2 ? 140 : 80);
        setTimeout(()=>overlay.classList.remove('show'), 1400);
        setTimeout(()=>{ cabinet.classList.remove('win-glow','shake'); clearHighlights(); }, 1600);
      }else if(mult===1){
        // SCRATCH (push)
        badge.textContent='SCRATCH';
        overlay.classList.add('show'); badge.classList.add('pop');
        cabinet.classList.add('win-glow');
        highlightWinLine(data.winLine, 'scratch');
        sScratch.currentTime=0; sScratch.play().catch(()=>{});
        setTimeout(()=>overlay.classList.remove('show'), 900);
        setTimeout(()=>{ cabinet.classList.remove('win-glow'); clearHighlights(); }, 1000);
      }else{
        // LOSE
        sLose.currentTime=0; sLose.play().catch(()=>{});
      }

      // ARIA live feedback
      ariaLive.textContent = (mult>1) ? `Win, multiplier ${mult.toFixed(2)} times`
        : (mult===1 ? 'Scratch, push' : 'No win');

      balance = balance - stake + payout;
      balEl.textContent = balance; renderUsd();

    }catch(e){
      console.error(e);
      try{ sSpin.pause(); sSpin.currentTime=0; }catch(_){}
    }finally{
      spinBtn.disabled=false;
    }
  });

  // expose for quick QA
  window.__slotsDemoSpin = ()=>document.getElementById('spin').click();
})();
</script>
