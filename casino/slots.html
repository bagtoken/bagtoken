<!-- ===================== Reels & Odds + Spin ===================== -->
<script>
(function(){
  const strips=[...document.querySelectorAll('.strip')];
  const spinBtn=document.getElementById('spinBtn');
  const spinText=document.getElementById('spinText');

  // ---- FINAL $BAG SYMBOL SET ----
  const SYMS = [
    {k:'BAG',     emoji:'BAG'},
    {k:'MONEY',   emoji:'💰'},
    {k:'DIAMOND', emoji:'💎'},
    {k:'COIN',    emoji:'🪙'},
    {k:'CHERRY',  emoji:'🍒'},
    {k:'SEVEN',   emoji:'7️⃣'},
    {k:'LOCK',    emoji:'🔒'}
  ];
  const NON_BAG_POOL = SYMS.filter(s => s.k !== 'BAG');

  // ---- House odds (≈43% win-rate live, 55% demo)
  const ODDS = { jackpot: 0.02, win: 0.36, scratch: 0.10 }; // lose implied

  const ROWS=3, CELL_H=88;
  function cell(sym){ const d=document.createElement('div'); d.className='cell'; d.textContent=sym.emoji; return d; }
  function fillStrip(el, arr){ el.innerHTML=''; arr.forEach(s=>el.appendChild(cell(s))); }
  function randomSym(){ return SYMS[(Math.random()*SYMS.length)|0]; }
  function randFrom(a){ return a[(Math.random()*a.length)|0]; }

  // init strips
  strips.forEach(s=>{ fillStrip(s, [randomSym(),randomSym(),randomSym()]); s.style.transform='translateY(0)'; });

  function blankGrid(){ return [[null,null,null],[null,null,null],[null,null,null]]; }
  function rowPay(g,r){
    const a=g[r][0]?.k,b=g[r][1]?.k,c=g[r][2]?.k;
    if(!a||!b||!c) return null;
    if(a===b && b===c) return a==='BAG'?'jackpot':'win';
    return null;
  }
  function diagPay(g){
    const a=g[0][0]?.k,b=g[1][1]?.k,c=g[2][2]?.k;
    const d=g[0][2]?.k,e=g[1][1]?.k,f=g[2][0]?.k;
    const d1=a&&b&&c && a===b && b===c;
    const d2=d&&e&&f && d===e && e===f;
    return (d1||d2)?'scratch':null;
  }
  function anyRowPay(g){ for(let r=0;r<3;r++){ const p=rowPay(g,r); if(p) return p; } return null; }

  function fillRandomNonPayingElsewhere(g){
    for(let r=0;r<3;r++){
      for(let c=0;c<3;c++){
        if(g[r][c]) continue;
        let placed=false, tries=0;
        while(!placed && tries++<12){
          const cand=randomSym();
          g[r][c]=cand;
          const rp=rowPay(g,r), ap=anyRowPay(g), dp=diagPay(g);
          if(!rp && !dp && !ap){ placed=true; } else { g[r][c]=null; }
        }
        if(!placed) g[r][c]=randomSym();
      }
    }
    return g;
  }

  function buildSpin(stakeBag){
    const p=Math.random();
    let target='lose';
    if(p < ODDS.jackpot) target='jackpot';
    else if(p < ODDS.jackpot+ODDS.win) target='win';
    else if(p < ODDS.jackpot+ODDS.win+ODDS.scratch) target='scratch';

    let g=blankGrid();

    if(target==='jackpot'){
      const line=(Math.random()*3)|0;
      g[line]=[SYMS[0],SYMS[0],SYMS[0]]; // BAG BAG BAG
      g=fillRandomNonPayingElsewhere(g);
    } else if(target==='win'){
      const line=(Math.random()*3)|0;
      const s=randFrom(NON_BAG_POOL);
      g[line]=[s,s,s];
      g=fillRandomNonPayingElsewhere(g);
    } else if(target==='scratch'){
      const s=randFrom(SYMS);
      if(Math.random()<0.5){ g[0][0]=s; g[1][1]=s; g[2][2]=s; }
      else{ g[0][2]=s; g[1][1]=s; g[2][0]=s; }
      g=fillRandomNonPayingElsewhere(g);
    } else {
      g=fillRandomNonPayingElsewhere(g);
    }
    return { grid:g, stake: stakeBag };
  }

  function evaluateGrid(rows){
    for(let r=0;r<3;r++){ if(rowPay(rows,r)==='jackpot') return { outcome:'jackpot', mult:2.00 }; }
    for(let r=0;r<3;r++){ if(rowPay(rows,r)==='win')     return { outcome:'win',     mult:1.25 }; }
    if(diagPay(rows)==='scratch') return { outcome:'scratch', mult:1.00 };
    return { outcome:'lose', mult:0.00 };
  }

  function startFastSpin(durationMs, finalRows){
    const loopers = strips.map((strip, idx) => {
      const base = Array.from({length:6},()=>randomSym());
      fillStrip(strip, base.slice(0,3));
      strip.style.transition = 'transform 80ms linear';
      let spinning = true, tickTimer = null;

      function tick(){ if(!spinning) return; strip.style.transform = `translateY(-${CELL_H}px)`; strip.addEventListener('transitionend', onEnd, {once:true}); }
      function onEnd(){
        const children = [...strip.children];
        if(children.length){ strip.removeChild(children[0]); strip.appendChild(cell(randomSym())); }
        strip.style.transition='none'; strip.style.transform='translateY(0)'; strip.getBoundingClientRect();
        strip.style.transition='transform 80ms linear';
        if(spinning) tickTimer=setTimeout(tick,60);
      }
      tick();

      return { stopAbrupt(){
        spinning=false; if(tickTimer) clearTimeout(tickTimer);
        strip.style.transition='none';
        const col=[ finalRows[0][idx], finalRows[1][idx], finalRows[2][idx] ];
        fillStrip(strip,col); strip.style.transform='translateY(0)';
      }};
    });

    return new Promise(resolve=>{ setTimeout(()=>{ loopers.forEach(l=>l.stopAbrupt()); resolve(); }, durationMs); });
  }

  // Sound integration (same hooks)
  function playSpin(){ try{ if(window.__bagAudio){ __bagAudio.resume && __bagAudio.resume(); window.__spinHandle=__bagAudio.spinLoop(); } }catch{} }
  function stopSpin(){ try{ window.__spinHandle && window.__spinHandle.stop(); }catch{} }
  function sWin(){ try{ window.__bagAudio && __bagAudio.chime(); }catch{} }
  function sScratch(){ try{ window.__bagAudio && __bagAudio.scratch(); }catch{} }
  function sLose(){ try{ window.__bagAudio && __bagAudio.thud(); }catch{} }

  function sessionActive(){ return !!(window.__bagSession && window.__bagSession.active && window.__bagSession.active()); }
  function credit(b){ try{ return window.__bagSession && window.__bagSession.credit && window.__bagSession.credit(b); }catch{ return false; } }
  function spend(b){ try{ return window.__bagSession && window.__bagSession.spend && window.__bagSession.spend(b); }catch{ return false; } }

  // Spin handler
  spinBtn.addEventListener('click', async ()=>{
    const sBag = (window.__bagStake && window.__bagStake.bag && window.__bagStake.bag()) || 0;
    const sUsd = (window.__bagStake && window.__bagStake.usd && window.__bagStake.usd()) || 0;

    if (!sessionActive() && !window.__BAG_FORCE_DEMO){ alert('Start a session (one-time sign) or use /demo for practice.'); return; }
    if (sUsd < 1 && !window.__BAG_FORCE_DEMO){ alert('Minimum $1 stake'); return; }
    if (!window.__BAG_FORCE_DEMO){ if (!spend(sBag)) return; }

    spinBtn.disabled=true; spinText.className='t'; spinText.textContent='Spinning…';
    try{ if (window.__bagAudio && __bagAudio.resume) await __bagAudio.resume(); }catch{}
    playSpin();

    const plan = buildSpin(sBag);
    const finalRows = plan.grid;
    await startFastSpin(4000, finalRows);
    stopSpin();

    const verdict = evaluateGrid(finalRows);
    const mult = verdict.mult;

    if(mult>0){
      if(mult===1.00){
        sScratch();
        credit(sBag*1.00);
        spinText.className='t scratch'; spinText.textContent='SCRATCH — 1.00×';
        showWin({ message:'SCRATCH', subtext:`${(mult*100).toFixed(0)}% back`, duration:3200, sound:false });
      } else if(mult===1.25){
        sWin();
        credit(sBag*1.25);
        spinText.className='t win'; spinText.textContent='WIN — 1.25×';
        showWin({ message:'WIN', subtext:`+${(sBag*0.25).toLocaleString(undefined,{maximumFractionDigits:6})} BAG · $${sUsd.toFixed(2)} → $${(sUsd*1.25).toFixed(2)}`, duration:5200 });
      } else {
        sWin();
        credit(sBag*2.00);
        spinText.className='t win'; spinText.textContent='JACKPOT — 2.00×';
        showWin({ message:'JACKPOT', subtext:`+${(sBag*1.00).toLocaleString(undefined,{maximumFractionDigits:6})} BAG · $${sUsd.toFixed(2)} → $${(sUsd*2.00).toFixed(2)}`, duration:7200 });
      }
    } else {
      sLose();
      spinText.className='t lose'; spinText.textContent='Lose — try again';
    }

    window.dispatchEvent(new CustomEvent('bag:slotsResult', {
      detail: { mult, scratch: mult===1.00, jackpot: mult===2.00, stakeBag: sBag }
    }));

    spinBtn.disabled=false;
  });

})();
</script>
