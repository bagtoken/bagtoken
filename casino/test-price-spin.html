<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>The $BAG Is Right Wheel — Side-on 3D (centered & upright)</title>
<style>
  html,body{margin:0;background:#06120d;color:#eaf3ee;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1120px;margin:0 auto;padding:16px}
  h1{margin:0 0 12px;font-size:clamp(1.2rem,4vw,2rem)}
  .board{background:linear-gradient(180deg,#0c2218,#091a13);border:1px solid #244b35;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:14px}
  .marquee{ text-align:center;font-weight:900;letter-spacing:.08em;color:#ffe9a6;background:linear-gradient(180deg,#17311f,#0e2419);border:1px solid #254a33;border-radius:10px;padding:8px;margin-bottom:10px }
  .stage{position:relative;height:72vh;min-height:460px;max-height:82vh;border-radius:12px;overflow:hidden;background:#0b1f16;border:1px dashed #2c6a49}
  #mount{position:absolute;inset:0}
  #hud{position:absolute;right:10px;top:10px;width:200px;height:110px;z-index:3}
  #err{position:absolute;inset:0;display:none;align-items:center;justify-content:center;text-align:center;padding:20px;background:rgba(0,0,0,.5);z-index:5}
  #err b{color:#ffb3b3}
  .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:12px}
  .btn{padding:14px 18px;border:0;border-radius:12px;font-weight:900;cursor:pointer}
  .spin{background:linear-gradient(180deg,#ffe175,#f5c94c);color:#0b120d;box-shadow:0 5px 0 #b08a19}
  .hold{background:linear-gradient(180deg,#d6f0e2,#cde7d9);color:#0b120d;box-shadow:0 5px 0 #7ba38d}
  .reset{background:linear-gradient(180deg,#c3c7cc,#aeb3b9);color:#0b1016;box-shadow:0 5px 0 #7b8086}
  .t{ text-align:center;margin:10px 0 0 } .t.win{color:#37cf82} .t.lose{color:#e65b5b}
</style>
</head>
<body>
<div class="wrap">
  <h1>The $BAG Is Right Wheel</h1>
  <div class="board">
    <div class="marquee">SWIPE UP/DOWN TO SPIN • UPRIGHT 3D WHEEL • Robust CDN→local loader</div>
    <div class="stage">
      <div id="mount"></div>
      <canvas id="hud" width="200" height="110"></canvas>
      <div id="err"></div>
    </div>
    <div class="row">
      <button id="spinBtn" class="btn spin">SPIN</button>
      <button id="holdBtn" class="btn hold">HOLD</button>
      <button id="resetBtn" class="btn reset">RESET</button>
    </div>
    <div id="msg" class="t">Spin up to two times to reach 1.00 without going over.</div>
  </div>
</div>
<script>
(function(){
  const E = document.getElementById('err');
  function showError(html){
    E.style.display='flex';
    E.innerHTML = `<div><b>3D failed to start</b><br><div style="opacity:.9;margin-top:6px">${html}</div></div>`;
  }
  function load(src){ return new Promise((res,rej)=>{ const s=document.createElement('script'); s.src=src; s.async=true; s.onload=res; s.onerror=()=>rej(new Error('load-failed:'+src)); document.head.appendChild(s); }); }
  function when(fn){ let tries=0; (function tick(){ if (window.THREE){ fn(); return; } if (++tries>200){ showError('THREE never loaded. Allow cdn.jsdelivr.net / unpkg.com or host /vendor/three.min.js'); return; } setTimeout(tick,50); })(); }
  (async()=>{
    try{ await load('https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js'); }
    catch(_){
      try{ await load('https://unpkg.com/three@0.158.0/build/three.min.js'); }
      catch(_2){
        try{ await load('/vendor/three.min.js'); }
        catch(_3){ showError('Could not load three.min.js from any source.'); return; }
      }
    }
    when(()=> initWheel3D());
  })();

  function initWheel3D(){
    const test=document.createElement('canvas');
    const gl=test.getContext('webgl2')||test.getContext('webgl')||test.getContext('experimental-webgl');
    if(!gl){ showError('WebGL is disabled or unavailable in this browser.'); return; }

    const seq=[0.05,0.80,0.35,0.60,0.20,0.45,0.70,0.25,0.90,0.55,0.10,0.95,0.30,0.75,0.50,1.00,0.15,0.40,0.65,0.85];
    const labels=seq.map(v=>v.toFixed(2)), N=labels.length, TAU=Math.PI*2, STEP=TAU/N;
    const mount=document.getElementById('mount'), hud=document.getElementById('hud');
    const msg=document.getElementById('msg');
    const spinBtn=document.getElementById('spinBtn'), holdBtn=document.getElementById('holdBtn'), resetBtn=document.getElementById('resetBtn');
    holdBtn.disabled = true;

    const {Scene,PerspectiveCamera,WebGLRenderer,Group,Mesh,MeshStandardMaterial,MeshBasicMaterial,
           CylinderGeometry,TorusGeometry,PlaneGeometry,CanvasTexture,Vector3,
           DirectionalLight,AmbientLight,Color,DoubleSide,SRGBColorSpace,BoxGeometry,Box3} = THREE;

    const scene=new Scene(); scene.background=new Color('#091913');
    const renderer=new WebGLRenderer({antialias:true,alpha:true});
    renderer.outputColorSpace=SRGBColorSpace;
    renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
    renderer.domElement.style.touchAction='none';
    mount.appendChild(renderer.domElement);

    const camera=new PerspectiveCamera(30,1,0.1,100);
    camera.position.set(0,0,11);
    camera.lookAt(0,0,0);

    // Lights
    const key=new DirectionalLight(0xffffff,1.0); key.position.set(3,6,8); scene.add(key);
    const fill=new DirectionalLight(0xffffff,0.6); fill.position.set(-5,2,6); scene.add(fill);
    const rimL=new DirectionalLight(0xfff0cc,0.7); rimL.position.set(0,-6,6); scene.add(rimL);
    scene.add(new AmbientLight(0xffffff,0.35));

    const root=new Group(); scene.add(root);
    const R=2.75, DEPTH=1.20, OUT=R+0.06;
    const wheel=new Group(); root.add(wheel);

    // Drum
    const drum=new Mesh(new CylinderGeometry(R,R,DEPTH,128,1,true),
                        new MeshStandardMaterial({color:'#141414',metalness:.55,roughness:.55}));
    drum.rotation.z=Math.PI/2;
    wheel.add(drum);

    // Rim
    const rimFront=new Mesh(new TorusGeometry(R+0.05,0.08,14,64),
                            new MeshStandardMaterial({color:'#0f0f0f',metalness:.85,roughness:.25}));
    rimFront.rotation.y=Math.PI/2; rimFront.position.z=DEPTH/2+0.02; wheel.add(rimFront);

    // Pegs — now on the **front face**, pointing outward
    const pegGeo=new THREE.CylinderGeometry(0.06,0.06,0.30,12);
    const pegMat=new MeshStandardMaterial({color:'#d7b75f',metalness:.85,roughness:.35});
    const pegs=new Group();
    for(let i=0;i<N;i++){
      const a=i*STEP + STEP*0.5;
      const x = 0;
      const y = Math.sin(a) * OUT;
      const z = Math.cos(a) * OUT;
      const p=new Mesh(pegGeo,pegMat);
      p.position.set(x, y, z);
      p.rotation.x = Math.PI/2; // point outward
      p.position.z += 0.18; // push forward
      pegs.add(p);
    }
    wheel.add(pegs);

    // Plate texture
    function plateTex(v, idx){
      const c=document.createElement('canvas'); c.width=512; c.height=256; const g=c.getContext('2d');
      const is100=v==='1.00', isG=(v==='0.05'||v==='0.15'); const dark=!is100 && !isG && (idx%2===0);
      const bg=is100? '#b90b0b' : isG? '#1b7f3a' : (dark? '#151515' : '#f1f1f1');
      const fg=(is100||isG||dark)? '#f7f7f7' : '#151515';
      g.fillStyle=bg; g.fillRect(0,0,c.width,c.height);
      g.strokeStyle='#d9bf6a'; g.lineWidth=30; g.strokeRect(16,16,c.width-32,c.height-32);
      g.fillStyle=fg; g.font='900 140px Inter,Arial,Helvetica,sans-serif'; g.textAlign='center'; g.textBaseline='middle';
      g.fillText(is100?'100':String(Math.round(parseFloat(v)*100)), c.width/2, c.height/2+6);
      const t=new CanvasTexture(c); t.anisotropy=8; return t;
    }

    // Plates — upright text, facing camera
    const plates=new Group();
    const plateGeo=new PlaneGeometry(1.2,0.60);
    for(let i=0;i<N;i++){
      const a = i*STEP + STEP/2;
      const y = Math.sin(a) * OUT;
      const z = Math.cos(a) * OUT;
      const sliceG = new Group();
      sliceG.position.set(0, y, z);
      sliceG.lookAt(0, y, z); // face outward

      const m = new Mesh(plateGeo, new MeshBasicMaterial({map:plateTex(labels[i],i), side:DoubleSide}));
      m.rotation.x = Math.PI/2; // make plane vertical
      m.rotation.z = Math.PI;  // flip 180° so text is upright
      sliceG.add(m);
      plates.add(sliceG);
    }
    wheel.add(plates);

    // Flapper — now at **top**, pointing down
    const flap=new Mesh(new BoxGeometry(0.06, 0.4, 0.15),
                        new MeshStandardMaterial({color:'#e23a21',metalness:.5,roughness:.5}));
    flap.position.set(0, OUT + 0.05, 0); // top
    flap.rotation.x = Math.PI/2;
    root.add(flap);

    // Center everything
    root.updateMatrixWorld(true);
    const b=new Box3().setFromObject(root);
    const c=b.getCenter(new Vector3());
    root.position.sub(c);
    camera.lookAt(0,0,0);

    // Resize
    function size(){
      const r=mount.getBoundingClientRect();
      const w=Math.max(1,Math.floor(r.width)), h=Math.max(460,Math.floor(r.height));
      renderer.setSize(w,h,false);
      camera.aspect=w/h; camera.updateProjectionMatrix();
    }
    requestAnimationFrame(size); addEventListener('resize', size);

    // HUD
    function drawHUD(v){
      const g=hud.getContext('2d'), w=hud.width, h=hud.height;
      g.clearRect(0,0,w,h); g.fillStyle='#07090b'; g.fillRect(0,0,w,h);
      g.strokeStyle='#222'; g.lineWidth=6; g.strokeRect(4,4,w-8,h-8);
      const fs=Math.min(88,Math.max(44,Math.floor(h*0.70)));
      g.fillStyle='#ffe26a'; g.font=`700 ${fs}px "DM Mono",ui-monospace,monospace`;
      g.textAlign='center'; g.textBaseline='middle'; g.fillText((v||0).toFixed(2),w/2,h/2+2);
    }
    drawHUD(0);

    /* ---------- Physics & input ---------- */
    let angX = 0, vel = 0, spinning = false, spin1 = null, total = 0, done = false;
    const FRICTION = 0.992, VMIN = 0.002, PIX2RAD = 0.025; // increased sensitivity
    function setAngle(a){ angX = a; wheel.rotation.x = a; }
    function idxFrom(a){
      let t = (a % TAU + TAU) % TAU;
      return Math.floor((t + STEP/2) / STEP) % N;
    }
    function currentVal(){ return parseFloat(labels[idxFrom(angX)]); }
    function snapTarget(){
      const i = idxFrom(angX);
      return i * STEP;
    }

    const surf = renderer.domElement;
    let dragging = false, lastY = 0, lastT = 0, samples = [];
    function getY(e){ return e.touches ? e.touches[0].clientY : e.clientY; }

    function down(e){ if(spinning||done) return; dragging=true; samples=[]; lastY=getY(e); lastT=performance.now(); e.preventDefault(); }
    function move(e){
      if(!dragging) return;
      const y = getY(e), t = performance.now(), dy = lastY - y; // invert: swipe down = wheel up
      setAngle(angX + dy * PIX2RAD);
      const dt = t - lastT;
      if(dt>0){ samples.push((dy*PIX2RAD)/(dt/1000)); if(samples.length>6) samples.shift(); }
      lastY = y; lastT = t; e.preventDefault();
    }
    function up(){
      if(!dragging) return; dragging=false;
      const v = samples.length ? samples.reduce((a,b)=>a+b,0)/samples.length : 0;
      vel = Math.max(1.5, Math.min(10, Math.abs(v*1.3))) * Math.sign(v || 1);
      startSpin();
    }

    surf.addEventListener('mousedown',down);
    surf.addEventListener('touchstart',down,{passive:false});
    addEventListener('mousemove',move);
    addEventListener('touchmove',move,{passive:false});
    addEventListener('mouseup',up);
    addEventListener('touchend',up);

    spinBtn.onclick = () => { if(spinning||done) return; vel=7; startSpin(); };
    holdBtn.onclick = () => { if(spinning||done||spin1==null) return; settleHold(); };
    resetBtn.onclick = reset;

    function startSpin(){
      spinning=true; spinBtn.disabled=holdBtn.disabled=resetBtn.disabled=true;
      msg.className='t'; msg.textContent = spin1==null ? 'Spinning 1...' : 'Spinning 2...';
      const loop = () => {
        setAngle(angX + vel * (1/60));
        vel *= FRICTION;
        drawHUD(currentVal());
        if(Math.abs(vel) < VMIN){
          const target = snapTarget();
          const diff = ((target - angX + TAU*3) % TAU) - TAU;
          if(Math.abs(diff) > 0.001){
            setAngle(angX + diff * 0.25);
            requestAnimationFrame(loop);
          } else {
            setAngle(target);
            spinning = false;
            onSettle();
          }
        } else requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }

    function onSettle(){
      const landed = currentVal();
      if(spin1 === null){
        spin1 = landed; total = landed;
        msg.textContent = `Spin 1: ${landed.toFixed(2)} — total ${total.toFixed(2)}. Spin again or HOLD.`;
        holdBtn.disabled = resetBtn.disabled = false;
        spinBtn.disabled = false;
        return;
      }
      total += landed; drawHUD(total);
      if(total > 1.00){
        done = true; msg.className='t lose'; msg.textContent = `BUST — ${total.toFixed(2)} is over 1.00`; end(0,'Bust'); return;
      }
      if(total === 1.00){
        msg.className='t win'; msg.textContent='Exact 1.00 — 5×. Bonus spin...'; bonus(); return;
      }
      if(total >= 0.95) end(1,'Near 1.00');
      else end(0,'Under 1.00');
    }

    function settleHold(){
      if(total === 1.00){ msg.className='t win'; msg.textContent='Exact 1.00 — 5×. Bonus spin...'; bonus(); return; }
      if(total >= 0.95) end(1,'Held near 1.00'); else end(0,'Held under 1.00');
    }

    function bonus(){
      vel = 6.5; spinning = true;
      const loop = () => {
        setAngle(angX + vel * (1/60));
        vel *= FRICTION;
        if(Math.abs(vel) < VMIN){
          const v = currentVal();
          const extra = (v===0.05)?5 : (v===0.15)?15 : (v===1.00)?25 : 0;
          msg.className = extra ? 't win' : 't';
          msg.textContent = extra ? `Bonus hit ${v.toFixed(2)} — +${extra}×` : `Bonus missed — kept base 5×`;
          done = true; resetBtn.disabled = false;
        } else requestAnimationFrame(loop);
      };
      requestAnimationFrame(loop);
    }

    function end(mult, label){
      done = true; spinBtn.disabled = holdBtn.disabled = true; resetBtn.disabled = false;
      msg.className = mult ? 't win' : 't lose';
      msg.textContent = mult ? `${label} — ${mult.toFixed(2)}×` : `${label} — 0×`;
    }

    function reset(){
      spinning = false; spin1 = null; total = 0; done = false;
      holdBtn.disabled = true; spinBtn.disabled = resetBtn.disabled = false;
      setAngle(0); drawHUD(0);
      msg.className='t'; msg.textContent='Spin up to two times to reach 1.00 without going over.';
      size();
    }

    function render(){ renderer.render(scene,camera); requestAnimationFrame(render); }
    setAngle(0); render(); requestAnimationFrame(size);
  }
})();
</script>
</body>
</html>
