<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>$BAG Big Wheel — Front View • Centered • Upright Numbers</title>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<style>
  html,body{margin:0;background:#06120d;color:#eaf3ee;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1120px;margin:0 auto;padding:16px}
  h1{margin:0 0 12px;font-size:clamp(1.2rem,4vw,2rem)}
  .board{background:linear-gradient(180deg,#0c2218,#091a13);border:1px solid #244b35;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:14px}
  .marquee{text-align:center;font-weight:900;letter-spacing:.08em;color:#ffe9a6;background:linear-gradient(180deg,#17311f,#0e2419);border:1px solid #254a33;border-radius:10px;padding:8px;margin-bottom:10px}
  .stage{position:relative;height:72vh;min-height:480px;max-height:82vh;border-radius:12px;overflow:hidden;background:#0b1f16}
  #mount{position:absolute;inset:0}
  #hud{position:absolute;right:10px;top:10px;width:200px;height:110px;z-index:3}
  #err{position:absolute;inset:0;display:none;align-items:center;justify-content:center;text-align:center;padding:20px;background:rgba(0,0,0,.8);color:#fff;z-index:5;font-size:1.05rem}
  #err b{color:#ff6b6b}
  .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:12px}
  .btn{padding:14px 18px;border:0;border-radius:12px;font-weight:900;cursor:pointer;transition:transform .08s}
  .btn:active{transform:translateY(2px)}
  .spin{background:linear-gradient(180deg,#ffe175,#f5c94c);color:#0b120d;box-shadow:0 5px 0 #b08a19}
  .hold{background:linear-gradient(180deg,#d6f0e2,#cde7d9);color:#0b120d;box-shadow:0 5px 0 #7ba38d}
  .reset{background:linear-gradient(180deg,#c3c7cc,#aeb3b9);color:#0b1016;box-shadow:0 5px 0 #7b8086}
  .t{text-align:center;margin:10px 0 0;font-weight:600}
  .t.win{color:#37cf82}
  .t.lose{color:#e65b5b}
</style>
</head>
<body>
<div class="wrap">
  <h1>$BAG Big Wheel</h1>
  <div class="board">
    <div class="marquee">SWIPE DOWN TO SPIN • FULL WHEEL IN VIEW • NUMBERS UPRIGHT</div>
    <div class="stage">
      <div id="mount"></div>
      <canvas id="hud" width="200" height="110"></canvas>
      <div id="err"></div>
    </div>
    <div class="row">
      <button id="spinBtn" class="btn spin">SPIN</button>
      <button id="holdBtn" class="btn hold">HOLD</button>
      <button id="resetBtn" class="btn reset">RESET</button>
    </div>
    <div id="msg" class="t">Spin up to two times to reach 1.00 without going over.</div>
  </div>
</div>

<script>
if(!window.THREE){
  const E=document.getElementById('err');E.style.display='flex';
  E.innerHTML='<b>ERROR:</b> THREE.js failed to load.';throw new Error('THREE not loaded');
}

function plateTexture(valStr, i){
  const is100=valStr==='1.00';
  const isGreen=valStr==='0.05'||valStr==='0.15';
  const altDark=!is100&&!isGreen&&(i%2===0);
  const c=document.createElement('canvas');c.width=512;c.height=256;
  const g=c.getContext('2d');
  g.fillStyle=is100?'#b30000':isGreen?'#0e7f2b':(altDark?'#111':'#fff');
  g.fillRect(0,0,512,256);
  g.strokeStyle='#d4af37';g.lineWidth=28;g.strokeRect(14,14,484,228);
  g.fillStyle=(is100||isGreen||altDark)?'#fff':'#000';
  g.font=is100?'900 160px Inter,system-ui,Arial':'900 140px Inter,system-ui,Arial';
  g.textAlign='center';g.textBaseline='middle';
  const txt=is100?'100':String(Math.round(parseFloat(valStr)*100));
  g.fillText(txt,256,128+(is100?-6:6));
  return new THREE.CanvasTexture(c);
}

function init(){
  const mount=document.getElementById('mount');
  const hud=document.getElementById('hud');
  const msg=document.getElementById('msg');
  const spinBtn=document.getElementById('spinBtn');
  const holdBtn=document.getElementById('holdBtn');
  const resetBtn=document.getElementById('resetBtn');
  holdBtn.disabled=true;

  const seq=[0.05,0.80,0.35,0.60,0.20,0.45,0.70,0.25,0.90,0.55,0.10,0.95,0.30,0.75,0.50,1.00,0.15,0.40,0.65,0.85];
  const labels=seq.map(v=>v.toFixed(2));
  const N=labels.length, TAU=Math.PI*2, STEP=TAU/N;

  const {
    Scene, PerspectiveCamera, WebGLRenderer, Group, Mesh, MeshStandardMaterial, MeshBasicMaterial,
    CylinderGeometry, TorusGeometry, PlaneGeometry, CanvasTexture, Vector3,
    DirectionalLight, AmbientLight, Color, DoubleSide, Box3, BoxGeometry
  }=THREE;

  const scene=new Scene();scene.background=new Color('#091913');

  const renderer=new WebGLRenderer({antialias:true,alpha:true});
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
  renderer.domElement.style.touchAction='none';
  mount.appendChild(renderer.domElement);

  const camera=new PerspectiveCamera(35,1,0.1,100);
  camera.position.set(0,0,10);camera.lookAt(0,0,0);

  scene.add(new DirectionalLight(0xffffff,1.15).position.set(5,6,8));
  scene.add(new DirectionalLight(0xffffff,0.6).position.set(-6,3,5));
  scene.add(new AmbientLight(0xffffff,0.45));

  const root=new Group();scene.add(root);

  const R=2.8, DEPTH=1.0, OUT=R+0.12;
  const wheel=new Group();root.add(wheel);

  /* ---------- DRUM WITH FRONT FACE (the fix) ---------- */
  // openEnded=false draws end caps so you see the front of the wheel
  const drum=new Mesh(
    new CylinderGeometry(R,R,DEPTH,128,1,false), // << false = has caps
    new MeshStandardMaterial({color:'#0b0b0b',metalness:0.75,roughness:0.3})
  );
  drum.rotation.x=Math.PI/2;            // axis along Z so the cap faces the camera
  wheel.add(drum);

  // Subtle front face highlight disk
  const face=new Mesh(
    new CylinderGeometry(R-0.02,R-0.02,0.02,128),
    new MeshStandardMaterial({color:'#0f1412',metalness:0.6,roughness:0.35})
  );
  face.rotation.x=Math.PI/2;
  face.position.z=DEPTH/2+0.011;
  wheel.add(face);

  // Bezel
  const bezel=new Mesh(
    new TorusGeometry(R+0.06,0.08,16,100),
    new MeshStandardMaterial({color:'#111',metalness:0.9,roughness:0.12})
  );
  bezel.rotation.x=Math.PI/2;bezel.position.z=DEPTH/2+0.02;
  wheel.add(bezel);

  // Pegs
  const pegGeo=new CylinderGeometry(0.06,0.06,0.30,12);
  const pegMat=new MeshStandardMaterial({color:'#d4af37',metalness:0.9,roughness:0.2});
  const pegs=new Group();
  for(let i=0;i<N;i++){
    const a=i*STEP+STEP/2, x=Math.sin(a)*OUT, y=Math.cos(a)*OUT;
    const p=new Mesh(pegGeo,pegMat);
    p.position.set(x,y,DEPTH/2+0.15); p.rotation.y=-a; pegs.add(p);
  }
  wheel.add(pegs);

  // Plates — outward facing and always upright
  const plates=new Group();
  const plateGeo=new PlaneGeometry(1.30,0.65);
  for(let i=0;i<N;i++){
    const a=i*STEP+STEP/2, x=Math.sin(a)*OUT, y=Math.cos(a)*OUT;
    const holder=new Group(); holder.position.set(x,y,DEPTH/2+0.01);

    const outward=new Vector3(x,y,0).normalize();
    const target=outward.clone().multiplyScalar(2);
    holder.lookAt(target);           // orient normal
    holder.rotateX(Math.PI);         // make +Z point outward
    holder.rotateZ(Math.PI/2);       // make plate long edge wrap the rim

    const tex=plateTexture(labels[i],i);
    const plate=new Mesh(plateGeo,new MeshBasicMaterial({map:tex,side:DoubleSide}));
    holder.add(plate); plates.add(holder);
  }
  wheel.add(plates);

  // Flapper
  const flap=new Mesh(
    new BoxGeometry(0.08,0.45,0.18),
    new MeshStandardMaterial({color:'#c41e3a',metalness:0.6,roughness:0.4})
  );
  flap.position.set(0,OUT+0.1,0); root.add(flap);

  // Center and fit camera so whole wheel is visible
  function centerAndFit(){
    root.updateMatrixWorld(true);
    const b=new Box3().setFromObject(root);
    const c=b.getCenter(new Vector3()); root.position.sub(c);

    const size=b.getSize(new Vector3());
    const maxDim=Math.max(size.x,size.y,size.z);
    const fov=camera.fov*(Math.PI/180);
    let dist=(maxDim/2)/Math.tan(fov/2); dist+=1.2;
    camera.position.set(0,0,dist); camera.lookAt(0,0,0);

    const r=mount.getBoundingClientRect();
    renderer.setSize(r.width|0,r.height|0,false);
    camera.aspect=r.width/r.height; camera.updateProjectionMatrix();
  }
  centerAndFit(); window.addEventListener('resize',centerAndFit);

  // HUD
  function drawHUD(v=0){
    const ctx=hud.getContext('2d');
    ctx.clearRect(0,0,200,110);
    ctx.fillStyle='#07090b';ctx.fillRect(0,0,200,110);
    ctx.strokeStyle='#333';ctx.lineWidth=6;ctx.strokeRect(4,4,192,102);
    ctx.fillStyle='#ffe26a';ctx.font='700 72px "DM Mono",monospace';
    ctx.textAlign='center';ctx.textBaseline='middle';
    ctx.fillText(v.toFixed(2),100,55);
  }
  drawHUD(0);

  // Spin logic (same behavior)
  let angle=0, velocity=0, spinning=false, spin1=null, total=0, done=false;
  const FRICTION=0.99, MIN_VEL=0.001, PIX2RAD=0.03;

  function setAngle(a){angle=a;wheel.rotation.z=a;}
  function getIndex(){return Math.floor(((angle% (TAU))+TAU)%TAU/STEP)%N;}
  function current(){return parseFloat(labels[getIndex()]);}
  function snap(){return getIndex()*STEP;}

  const canvas=renderer.domElement;
  let dragging=false,lastY=0,samples=[];

  function start(e){ if(spinning||done)return; dragging=true;samples=[]; lastY=(e.touches?.[0]||e).clientY; e.preventDefault();}
  function move(e){
    if(!dragging)return;
    const y=(e.touches?.[0]||e).clientY, dy=lastY-y;
    setAngle(angle+dy*PIX2RAD);
    const now=performance.now();
    if(!samples.length||now-samples[samples.length-1].t>16){
      samples.push({v:dy*PIX2RAD,t:now}); if(samples.length>5)samples.shift();
    }
    lastY=y; e.preventDefault();
  }
  function end(){
    if(!dragging)return; dragging=false;
    if(samples.length){
      const avg=samples.reduce((s,i)=>s+i.v,0)/samples.length;
      velocity=Math.sign(avg)*Math.min(12,Math.max(2,Math.abs(avg)*1.5));
    }
    spin();
  }
  canvas.addEventListener('mousedown',start);
  canvas.addEventListener('touchstart',start,{passive:false});
  window.addEventListener('mousemove',move);
  window.addEventListener('touchmove',move,{passive:false});
  window.addEventListener('mouseup',end);
  window.addEventListener('touchend',end);

  document.getElementById('spinBtn').onclick=()=>{if(!spinning&&!done){velocity=8;spin();}};
  document.getElementById('holdBtn').onclick=()=>{if(!spinning&&!done&&spin1!==null)hold();};
  document.getElementById('resetBtn').onclick=reset;

  function spin(){
    spinning=true; spinBtn.disabled=holdBtn.disabled=resetBtn.disabled=true;
    msg.textContent=spin1===null?'Spinning 1...':'Spinning 2...'; msg.className='t';
    const loop=()=>{
      setAngle(angle+velocity/60); velocity*=FRICTION; drawHUD(current());
      if(Math.abs(velocity)<MIN_VEL){
        const target=snap(); const diff=((target-angle+TAU*3)%TAU)-TAU;
        if(Math.abs(diff)>0.002){ setAngle(angle+diff*0.2); requestAnimationFrame(loop);}
        else{ setAngle(target); spinning=false; settle(); }
      }else requestAnimationFrame(loop);
    }; requestAnimationFrame(loop);
  }

  function settle(){
    const v=current();
    if(spin1===null){
      spin1=v; total=v;
      msg.textContent=`Spin 1: ${v.toFixed(2)} — total ${total.toFixed(2)}. Spin again or HOLD.`;
      holdBtn.disabled=resetBtn.disabled=false; spinBtn.disabled=false;
    }else{
      total+=v; drawHUD(total);
      if(total>1.00){ done=true; msg.className='t lose'; msg.textContent=`BUST — ${total.toFixed(2)} over 1.00`; endGame(0,'Bust'); }
      else if(total===1.00){ msg.className='t win'; msg.textContent='Exact 1.00 — 5×! Bonus spin...'; bonusSpin(); }
      else if(total>=0.95){ endGame(1,'Near 1.00'); }
      else{ endGame(0,'Under 1.00'); }
    }
  }

  function hold(){
    if(total===1.00){ msg.className='t win'; msg.textContent='Exact 1.00 — 5×! Bonus spin...'; bonusSpin(); return; }
    endGame(total>=0.95?1:0, total>=0.95?'Held near 1.00':'Held under 1.00');
  }

  function bonusSpin(){
    velocity=7; spinning=true;
    const loop=()=>{
      setAngle(angle+velocity/60); velocity*=FRICTION;
      if(Math.abs(velocity)<MIN_VEL){
        const v=current();
        const extra=v===0.05?5 : v===0.15?15 : v===1.00?25 : 0;
        msg.className=extra?'t win':'t';
        msg.textContent=extra?`Bonus: ${v} → +${extra}×`:'Bonus missed — 5× base';
        done=true; resetBtn.disabled=false;
      }else requestAnimationFrame(loop);
    }; requestAnimationFrame(loop);
  }

  function endGame(mult,label){
    done=true; spinBtn.disabled=holdBtn.disabled=true; resetBtn.disabled=false;
    msg.className=mult?'t win':'t lose';
    msg.textContent=mult?`${label} — ${mult}×`:`${label} — 0×`;
  }

  function reset(){
    spinning=done=false; spin1=null; total=0;
    holdBtn.disabled=true; spinBtn.disabled=resetBtn.disabled=false;
    setAngle(0); drawHUD(0);
    msg.className='t'; msg.textContent='Spin up to two times to reach 1.00 without going over.';
  }

  function render(){ renderer.render(scene,camera); requestAnimationFrame(render); }
  setAngle(0); render();
}

init();
</script>
</body>
</html>
