<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>The $BAG Big Wheel — centered + upright plates</title>
<style>
  html,body{margin:0;height:100%;background:#081912;color:#eaf3ee;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1100px;margin:0 auto;padding:16px}
  .hdr{display:flex;gap:.6rem;align-items:center;font-weight:900;font-size:28px;margin:0 0 8px}
  .board{background:linear-gradient(180deg,#10271d,#0b1f17);
         border:1px solid #234a35;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:14px}
  .marquee{text-align:center;font-weight:900;letter-spacing:.08em;color:#ffe9a6;
           background:linear-gradient(180deg,#17311f,#0e2419);border:1px solid #254a33;border-radius:10px;
           padding:8px;margin-bottom:10px}
  .stage{position:relative;height:72vh;min-height:480px;max-height:82vh;border-radius:12px;overflow:hidden;
         background:#0b1f16;border:1px dashed #2c6a49}
  #mount{position:absolute;inset:0}
  #hud{position:absolute;right:min(3vw,18px);top:min(3vw,18px);width:min(42vw,220px);height:min(24vw,120px);z-index:3}
  #err{position:absolute;inset:0;display:none;align-items:center;justify-content:center;text-align:center;padding:20px;background:rgba(0,0,0,.55);z-index:5}
  #err b{color:#ffb3b3}
  .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:12px}
  .btn{padding:14px 18px;border:0;border-radius:12px;font-weight:900;cursor:pointer}
  .spin{background:linear-gradient(180deg,#ffe175,#f5c94c);color:#0b120d;box-shadow:0 5px 0 #b08a19}
  .hold{background:linear-gradient(180deg,#d6f0e2,#cde7d9);color:#0b120d;box-shadow:0 5px 0 #7ba38d}
  .reset{background:linear-gradient(180deg,#c3c7cc,#aeb3b9);color:#0b1016;box-shadow:0 5px 0 #7b8086}
  .t{text-align:center;margin:10px 0 0}.t.win{color:#37cf82}.t.lose{color:#e65b5b}
</style>
</head>
<body>
<div class="wrap">
  <div class="hdr">🎡 The $BAG Big Wheel</div>
  <div class="board">
    <div class="marquee">SWIPE UP/DOWN TO SPIN • UPRIGHT 3D WHEEL • centered layout</div>
    <div class="stage">
      <div id="mount"></div>
      <canvas id="hud" width="240" height="130"></canvas>
      <div id="err"></div>
    </div>
    <div class="row">
      <button id="spinBtn" class="btn spin">SPIN</button>
      <button id="holdBtn" class="btn hold">HOLD</button>
      <button id="resetBtn" class="btn reset">RESET</button>
    </div>
    <div id="msg" class="t">Spin up to two times to reach 1.00 without going over.</div>
  </div>
</div>

<script>
/* ----------------------- Three.js loader (CDN → fallback) ----------------------- */
(function(){
  const E = document.getElementById('err');
  const showError = (html)=>{ E.style.display='flex'; E.innerHTML = `<div><b>3D failed to start</b><br><div style="opacity:.9;margin-top:6px">${html}</div></div>`; };
  const load = (src)=>new Promise((res,rej)=>{const s=document.createElement('script'); s.src=src; s.async=true; s.onload=res; s.onerror=()=>rej(); document.head.appendChild(s);});
  const when = (fn)=>{let n=0;(function tick(){ if(window.THREE){fn();return;} if(++n>160){showError('THREE never loaded.');return;} setTimeout(tick,50); })();};

  (async()=>{
    try{ await load('https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js'); }
    catch(_){
      try{ await load('https://unpkg.com/three@0.158.0/build/three.min.js'); }
      catch(_2){ showError('Could not fetch three.min.js'); return; }
    }
    when(init);
  })();

/* ----------------------------- Main 3D scene ----------------------------------- */
function init(){
  const test = document.createElement('canvas');
  const gl = test.getContext('webgl2')||test.getContext('webgl')||test.getContext('experimental-webgl');
  if(!gl){ showError('WebGL is unavailable in this browser.'); return; }

  const seq = [0.05,0.80,0.35,0.60,0.20,0.45,0.70,0.25,0.90,0.55,0.10,0.95,0.30,0.75,0.50,1.00,0.15,0.40,0.65,0.85];
  const labels = seq.map(v=>v.toFixed(2));
  const N = labels.length, TAU=Math.PI*2, STEP=TAU/N;

  const mount = document.getElementById('mount');
  const hud = document.getElementById('hud');
  const msg = document.getElementById('msg');
  const spinBtn = document.getElementById('spinBtn');
  const holdBtn = document.getElementById('holdBtn');
  const resetBtn = document.getElementById('resetBtn');
  holdBtn.disabled = true;

  const {
    Scene, PerspectiveCamera, WebGLRenderer, Group, Mesh,
    MeshStandardMaterial, MeshBasicMaterial,
    CylinderGeometry, TorusGeometry, PlaneGeometry, CircleGeometry,
    CanvasTexture, Vector3, DirectionalLight, AmbientLight, Color, DoubleSide, SRGBColorSpace
  } = THREE;

  const scene = new Scene(); scene.background = new Color('#0b1f16');
  const renderer = new WebGLRenderer({antialias:true,alpha:true});
  renderer.outputColorSpace = SRGBColorSpace;
  renderer.setPixelRatio(Math.min(devicePixelRatio||1,2));
  mount.appendChild(renderer.domElement);

  // Camera: centered, facing the wheel straight on
  const camera = new PerspectiveCamera(40,1,0.1,100);
  camera.position.set(0,0,8.5);

  // Lights
  const key = new DirectionalLight(0xffffff, 1.0); key.position.set(3,6,8); scene.add(key);
  const fill = new DirectionalLight(0xffffff, .6); fill.position.set(-5,2,6); scene.add(fill);
  scene.add(new AmbientLight(0xffffff,.35));

  // Wheel geometry (drum rotates around the X axis = vertical rolling)
  const R = 2.75, DEPTH = 1.25;
  const wheel = new Group(); wheel.position.set(0,0,0); scene.add(wheel);

  const drum = new Mesh(
    new CylinderGeometry(R,R,DEPTH,128,1,true),
    new MeshStandardMaterial({color:'#161616',metalness:.55,roughness:.62})
  );
  drum.rotation.z = Math.PI/2; // axis along X
  wheel.add(drum);

  // front and back rims (slight bevel)
  const rimA = new Mesh(new TorusGeometry(R+0.05,0.07,12,64), new MeshStandardMaterial({color:'#0b0b0b',metalness:.85,roughness:.3}));
  rimA.rotation.y = Math.PI/2; rimA.position.z =  DEPTH/2 + 0.03; wheel.add(rimA);
  const rimB = rimA.clone(); rimB.position.z = -DEPTH/2 - 0.03; wheel.add(rimB);

  // Pegs on the front face (like the real wheel)
  const pegGeo = new THREE.CylinderGeometry(0.06,0.06,0.34,12);
  const pegMat = new MeshStandardMaterial({color:'#d6b45f',metalness:.85,roughness:.35});
  const pegs = new Group();
  for(let i=0;i<N;i++){
    const a=i*STEP;
    const y=Math.sin(a)*(R-0.02), z=Math.cos(a)*(R-0.02);
    const p=new Mesh(pegGeo,pegMat);
    p.position.set(DEPTH/2+0.18,y,z);
    p.rotation.y=Math.PI/2;
    pegs.add(p);
  }
  wheel.add(pegs);

  // ----- Number plates (gold frame; 100 red; 5 & 15 green) -----
  function plateTex(v, idx){
    const c=document.createElement('canvas'); c.width=512; c.height=256; const g=c.getContext('2d');
    const is100 = v==='1.00', isG=(v==='0.05'||v==='0.15');
    const darkStripe = !is100 && !isG && (idx%2===0);
    const bg = is100? '#b90b0b' : isG? '#1a8b43' : (darkStripe? '#0e0e0e' : '#efefef');
    const fg = (is100||isG||darkStripe)? '#f7f7f7' : '#151515';
    g.fillStyle = bg; g.fillRect(0,0,c.width,c.height);
    g.strokeStyle='#d6b45f'; g.lineWidth=28; g.strokeRect(18,18,c.width-36,c.height-36);
    g.fillStyle=fg; g.font='900 140px Inter,Arial,Helvetica,sans-serif';
    g.textAlign='center'; g.textBaseline='middle';
    g.fillText(is100?'100':String(Math.round(parseFloat(v)*100)), c.width/2, c.height/2+8);
    return new CanvasTexture(c);
  }

  // Plate holders keep plates upright while they orbit (fixes “upside-down” look)
  const plateW=1.18, plateH=0.62;
  const plateGeo = new PlaneGeometry(plateW,plateH);
  const plates = new Group();

  for(let i=0;i<N;i++){
    const holder = new Group();                 // rotate holder around X to orbit
    holder.rotation.x = i*STEP;                 // position around the ring
    const plate = new Mesh(plateGeo, new MeshBasicMaterial({map:plateTex(labels[i],i)}));
    plate.position.z = R-0.55;                  // push outward to the rim
    // the next line keeps the text orientation upright relative to world up:
    plate.rotation.x = -holder.rotation.x;      // cancel the orbit tilt
    plates.add(holder); holder.add(plate);
  }
  wheel.add(plates);

  // Hub logo + flapper
  const hub = new Mesh(new CircleGeometry(0.95,64), new MeshStandardMaterial({color:'#0b0f10',metalness:.5,roughness:.5}));
  hub.rotation.y=Math.PI/2; hub.position.set(DEPTH/2+0.04,0,0); scene.add(hub);

  const flap = new Mesh(new PlaneGeometry(0.52,0.3),
    new MeshStandardMaterial({color:'#e23a21',metalness:.4,roughness:.5,side:DoubleSide}));
  flap.rotation.z = Math.PI/2; flap.position.set(DEPTH/2+0.22,0,R*0.02); scene.add(flap);

  // Sizing
  function size(){
    const r=mount.getBoundingClientRect();
    const w=Math.max(1,Math.floor(r.width)), h=Math.max(480,Math.floor(r.height));
    renderer.setSize(w,h,false); camera.aspect=w/h; camera.updateProjectionMatrix();
  }
  size(); addEventListener('resize', size);

  // HUD (blinking)
  let blink = false; setInterval(()=>{ blink = !blink; drawHUD(currentVal()); }, 650);
  function drawHUD(v){
    const g=hud.getContext('2d'), w=hud.width, h=hud.height;
    g.clearRect(0,0,w,h); g.fillStyle= blink ? '#0b0d0f' : '#0a0c0e';
    g.fillRect(0,0,w,h); g.strokeStyle='#222'; g.lineWidth=6; g.strokeRect(4,4,w-8,h-8);
    const fs=Math.min(88,Math.max(44,Math.floor(h*0.7)));
    g.fillStyle='#ffe26a'; g.font=`900 ${fs}px "DM Mono",ui-monospace,monospace`;
    g.textAlign='center'; g.textBaseline='middle';
    g.fillText((v||0).toFixed(2),w/2,h/2+2);
  }

  // Physics
  let angX=-Math.PI/2, vel=0, spinning=false, spin1=null, total=0, done=false;
  const FRICTION=0.992, VMIN=0.002, PIX2RAD=0.012;

  function setAngle(a){ angX=a; wheel.rotation.x=a; }
  function idxFrom(a){
    let t=a%TAU; if(t<0) t+=TAU;
    const i=Math.floor((t+STEP/2)/STEP)%N;
    // plate at the flapper is the one at the top (holder.x = 3π/2)
    return (N-i)%N;
  }
  function currentVal(){ return parseFloat(labels[idxFrom(angX)]); }
  function snapTarget(){
    const i=idxFrom(angX); const top=(N-i)%N; return top*STEP-STEP/2;
  }

  // Input (drag/swipe)
  const surf=renderer.domElement, getY=e=>(e.touches?e.touches[0].clientY:e.clientY);
  let dragging=false,lastY=0,lastT=0,samples=[];
  function down(e){ if(spinning||done) return; dragging=true; samples.length=0; lastY=getY(e); lastT=performance.now(); e.preventDefault(); }
  function move(e){ if(!dragging) return; const y=getY(e), t=performance.now(), dy=y-lastY;
    setAngle(angX + dy*PIX2RAD);
    const dt=t-lastT; if(dt>0){ samples.push(((dy*PIX2RAD)/(dt/1000))); if(samples.length>6) samples.shift(); }
    lastY=y; lastT=t; e.preventDefault();
  }
  function up(){ if(!dragging) return; dragging=false;
    const v=samples.length?samples.reduce((a,b)=>a+b,0)/samples.length:0;
    vel=Math.max(1.2,Math.min(8,Math.abs(v*1.2)))*Math.sign(v||1);
    startSpin();
  }
  surf.addEventListener('mousedown',down); addEventListener('mousemove',move); addEventListener('mouseup',up);
  surf.addEventListener('touchstart',down,{passive:false}); addEventListener('touchmove',move,{passive:false}); addEventListener('touchend',up);

  // Buttons
  spinBtn.onclick=()=>{ if(spinning||done) return; vel=6; startSpin(); };
  holdBtn.onclick=()=>{ if(spinning||done||spin1==null) return; settleHold(); };
  resetBtn.onclick=reset;

  function startSpin(){
    spinning=true; spinBtn.disabled=true; holdBtn.disabled=true; resetBtn.disabled=true;
    msg.className='t'; msg.textContent=(spin1==null)?'Spinning 1…':'Spinning 2…';
    const loop=()=>{ setAngle(angX + vel*(1/60)); vel*=FRICTION; drawHUD(currentVal());
      if(Math.abs(vel)<VMIN){
        const target=snapTarget(); const d=((target-angX+Math.PI*3)%TAU)-Math.PI;
        if(Math.abs(d)>0.0006){ setAngle(angX+d*0.25); requestAnimationFrame(loop); }
        else{ setAngle(target); spinning=false; onSettle(); }
      } else requestAnimationFrame(loop);
    };
    requestAnimationFrame(loop);
  }

  function onSettle(){
    const landed=currentVal();
    if(spin1==null){ spin1=landed; total=landed; msg.textContent=`Spin 1: ${landed.toFixed(2)} — total ${total.toFixed(2)}. Spin again or HOLD.`; holdBtn.disabled=false; resetBtn.disabled=false; spinBtn.disabled=false; return; }
    total+=landed; drawHUD(total);
    if(total>1.00){ done=true; msg.className='t lose'; msg.textContent=`BUST — ${total.toFixed(2)} is over 1.00`; end(0,'Bust'); return; }
    if(total===1.00){ msg.className='t win'; msg.textContent='Exact 1.00 — 5×. Bonus spin…'; bonus(); return; }
    if(total>=0.95) end(1,'Near 1.00'); else end(0,'Under 1.00');
  }
  function settleHold(){ if(total===1.00){ msg.className='t win'; msg.textContent='Exact 1.00 — 5×. Bonus spin…'; bonus(); return; }
    if(total>=0.95) end(1,'Held near 1.00'); else end(0,'Held under 1.00'); }

  function bonus(){
    vel=5.4; const loop=()=>{ setAngle(angX + vel*(1/60)); vel*=FRICTION;
      if(Math.abs(vel)<VMIN){
        const v=currentVal(); const extra=(v===0.05)?5:(v===0.15)?15:(v===1.00)?25:0;
        msg.className=extra?'t win':'t'; msg.textContent= extra?`Bonus hit ${v.toFixed(2)} — +${extra}×`:`Bonus missed — kept base 5×`;
        done=true; resetBtn.disabled=false;
      } else requestAnimationFrame(loop);
    }; requestAnimationFrame(loop);
  }
  function end(mult,label){ done=true; spinBtn.disabled=true; holdBtn.disabled=true; resetBtn.disabled=false; msg.className=mult?'t win':'t lose'; msg.textContent=mult?`${label} — ${mult.toFixed(2)}×`:`${label} — 0×`; }
  function reset(){ spinning=false; spin1=null; total=0; done=false; holdBtn.disabled=true; spinBtn.disabled=false; resetBtn.disabled=false; setAngle(-Math.PI/2); drawHUD(0); msg.className='t'; msg.textContent='Spin up to two times to reach 1.00 without going over.'; size(); }

  // Render
  function render(){ renderer.render(scene,camera); requestAnimationFrame(render); }
  setAngle(-Math.PI/2); drawHUD(0); render(); requestAnimationFrame(size);
}
})();
</script>
</body>
</html>
