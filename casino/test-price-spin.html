<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>The $BAG Is Right Wheel</title>
<style>
  html,body{margin:0;background:#06120d;color:#eaf3ee;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1120px;margin:0 auto;padding:16px}
  h1{margin:0 0 12px;font-size:clamp(1.2rem,4vw,2rem);text-align:center}
  .board{background:linear-gradient(180deg,#0c2218,#091a13);border:1px solid #244b35;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:14px}
  .marquee{text-align:center;font-weight:900;letter-spacing:.08em;color:#ffe9a6;background:linear-gradient(180deg,#17311f,#0e2419);border:1px solid #254a33;border-radius:10px;padding:8px;margin-bottom:10px}
  .stage{position:relative;height:72vh;min-height:460px;max-height:82vh;border-radius:12px;overflow:hidden;background:#0b1f16;border:1px dashed #2c6a49}
  #mount{position:absolute;inset:0}
  #hud{position:absolute;right:10px;top:10px;width:200px;height:110px;z-index:3;background:rgba(0,0,0,.3);border-radius:12px}
  #err{position:absolute;inset:0;display:none;align-items:center;justify-content:center;text-align:center;padding:20px;background:rgba(0,0,0,.5);z-index:5;color:#fff}
  #err b{color:#ffb3b3}
  .row{display:flex;gap:12px;justify-content:center;flex-wrap:wrap;margin-top:12px}
  .btn{padding:14px 20px;border:0;border-radius:12px;font-weight:900;cursor:pointer;font-size:1rem;min-width:100px}
  .spin{background:linear-gradient(180deg,#ffe175,#f5c94c);color:#0b120d;box-shadow:0 5px 0 #b08a19}
  .hold{background:linear-gradient(180deg,#d6f0e2,#cde7d9);color:#0b120d;box-shadow:0 5px 0 #7ba38d}
  .reset{background:linear-gradient(180deg,#c3c7cc,#aeb3b9);color:#0b1016;box-shadow:0 5px 0 #7b8086}
  .t{text-align:center;margin:10px 0 0;font-weight:600} 
  .t.win{color:#37cf82} 
  .t.lose{color:#e65b5b}
</style>
</head>
<body>
<div class="wrap">
  <h1>The $BAG Is Right Wheel</h1>
  <div class="board">
    <div class="marquee">SWIPE DOWN TO SPIN • 1.00 AT TOP • REAL PHYSICS</div>
    <div class="stage">
      <div id="mount"></div>
      <canvas id="hud" width="200" height="110"></canvas>
      <div id="err"></div>
    </div>
    <div class="row">
      <button id="spinBtn" class="btn spin">SPIN</button>
      <button id="holdBtn" class="btn hold">HOLD</button>
      <button id="resetBtn" class="btn reset">RESET</button>
    </div>
    <div id="msg" class="t">Spin up to two times to reach 1.00 without going over.</div>
  </div>
</div>

<script>
(function(){
  const E = document.getElementById('err');
  function showError(html){
    E.style.display='flex';
    E.innerHTML = `<div><b>3D failed to start</b><br><div style="opacity:.9;margin-top:6px">${html}</div></div>`;
  }
  function load(src){ 
    return new Promise((res,rej)=>{ 
      const s=document.createElement('script'); 
      s.src=src; s.async=true; 
      s.onload=res; 
      s.onerror=()=>rej(); 
      document.head.appendChild(s); 
    }); 
  }
  function when(fn){ 
    let tries=0; 
    (function tick(){ 
      if (window.THREE){ fn(); return; } 
      if (++tries>200){ showError('THREE.js failed to load'); return; } 
      setTimeout(tick,50); 
    })(); 
  }

  (async()=>{
    try { await load('https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js'); }
    catch { try { await load('https://unpkg.com/three@0.158.0/build/three.min.js'); } catch { showError('No internet? Host three.min.js locally.'); return; } }
    when(initWheel3D);
  })();

  function initWheel3D(){
    if (!window.THREE) return;
    const canvas = document.createElement('canvas');
    const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
    if (!gl) { showError('WebGL not supported'); return; }

    const seq = [0.05,0.80,0.35,0.60,0.20,0.45,0.70,0.25,0.90,0.55,0.10,0.95,0.30,0.75,0.50,1.00,0.15,0.40,0.65,0.85];
    const labels = seq.map(v=>v.toFixed(2));
    const N = labels.length, TAU = Math.PI*2, STEP = TAU/N;

    const mount = document.getElementById('mount');
    const hud = document.getElementById('hud');
    const msg = document.getElementById('msg');
    const spinBtn = document.getElementById('spinBtn');
    const holdBtn = document.getElementById('holdBtn');
    const resetBtn = document.getElementById('resetBtn');
    holdBtn.disabled = true;

    const {
      Scene, PerspectiveCamera, WebGLRenderer, Group, Mesh, MeshStandardMaterial, MeshBasicMaterial,
      CylinderGeometry, TorusGeometry, PlaneGeometry, CanvasTexture, Vector3,
      DirectionalLight, AmbientLight, Color, DoubleSide, SRGBColorSpace, BoxGeometry, Box3
    } = THREE;

    const scene = new Scene();
    scene.background = new Color('#091913');

    const renderer = new WebGLRenderer({antialias:true, alpha:true});
    renderer.outputColorSpace = SRGBColorSpace;
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.domElement.style.touchAction = 'none';
    mount.appendChild(renderer.domElement);

    const camera = new PerspectiveCamera(30, 1, 0.1, 100);
    camera.position.set(0, 0, 11);
    camera.lookAt(0, 0, 0);

    // Lights
    scene.add(new DirectionalLight(0xffffff, 1.0)).position.set(3,6,8);
    scene.add(new DirectionalLight(0xffffff, 0.6)).position.set(-5,2,6);
    scene.add(new DirectionalLight(0xfff0cc, 0.7)).position.set(0,-6,6);
    scene.add(new AmbientLight(0xffffff, 0.35));

    const root = new Group(); scene.add(root);
    const R = 2.75, DEPTH = 1.20, OUT = R + 0.06;
    const wheel = new Group(); root.add(wheel);

    // Drum
    const drum = new Mesh(
      new CylinderGeometry(R, R, DEPTH, 128, 1, true),
      new MeshStandardMaterial({color:'#141414', metalness:.55, roughness:.55})
    );
    drum.rotation.z = Math.PI/2;
    wheel.add(drum);

    // Rim
    const rim = new Mesh(
      new TorusGeometry(R+0.05, 0.08, 14, 64),
      new MeshStandardMaterial({color:'#0f0f0f', metalness:.85, roughness:.25})
    );
    rim.rotation.y = Math.PI/2;
    rim.position.z = DEPTH/2 + 0.02;
    wheel.add(rim);

    // Pegs
    const pegGeo = new CylinderGeometry(0.06, 0.06, 0.30, 12);
    const pegMat = new MeshStandardMaterial({color:'#d7b75f', metalness:.85, roughness:.35});
    const pegs = new Group();
    for (let i = 0; i < N; i++) {
      const a = i * STEP + STEP * 0.5;
      const y = Math.sin(a) * OUT;
      const z = Math.cos(a) * OUT;
      const p = new Mesh(pegGeo, pegMat);
      p.position.set(0, y, z);
      p.rotation.x = Math.PI/2;
      p.position.z += 0.18;
      pegs.add(p);
    }
    wheel.add(pegs);

    // Plate texture
    function plateTex(v, idx) {
      const c = document.createElement('canvas');
      c.width = 512; c.height = 256;
      const g = c.getContext('2d');
      const is100 = v === '1.00';
      const isG = v === '0.05' || v === '0.15';
      const dark = !is100 && !isG && (idx % 2 === 0);
      const bg = is100 ? '#b90b0b' : isG ? '#1b7f3a' : dark ? '#151515' : '#f1f1f1';
      const fg = (is100 || isG || dark) ? '#f7f7f7' : '#151515';

      g.fillStyle = bg; g.fillRect(0,0,c.width,c.height);
      g.strokeStyle = '#d9bf6a'; g.lineWidth = 30;
      g.strokeRect(16,16,c.width-32,c.height-32);
      g.fillStyle = fg;
      g.font = is100 ? '900 160px Inter,Arial' : '900 140px Inter,Arial';
      g.textAlign = 'center'; g.textBaseline = 'middle';
      g.fillText(is100 ? '100' : String(Math.round(parseFloat(v)*100)), c.width/2, c.height/2 + 6);

      const t = new CanvasTexture(c);
      t.anisotropy = 8;
      return t;
    }

    // Plates — PERFECTLY UPRIGHT & FACING CAMERA
    const plates = new Group();
    const plateGeo = new PlaneGeometry(1.2, 0.60);
    for (let i = 0; i < N; i++) {
      const a = i * STEP + STEP / 2;
      const y = Math.sin(a) * OUT;
      const z = Math.cos(a) * OUT;

      const slice = new Group();
      slice.position.set(0, y, z);
      slice.lookAt(0, y, z); // +Z points outward

      const m = new Mesh(plateGeo, new MeshBasicMaterial({
        map: plateTex(labels[i], i),
        side: DoubleSide
      }));
      m.rotation.x = Math.PI / 2;  // vertical
      m.rotation.y = Math.PI;      // FLIP 180° → text faces camera
      slice.add(m);
      plates.add(slice);
    }
    wheel.add(plates);

    // Red Flapper at TOP
    const flap = new Mesh(
      new BoxGeometry(0.06, 0.4, 0.15),
      new MeshStandardMaterial({color:'#e23a21', metalness:.5, roughness:.5})
    );
    flap.position.set(0, OUT + 0.05, 0);
    flap.rotation.x = Math.PI/2;
    root.add(flap);

    // Center everything
    root.updateMatrixWorld(true);
    const box = new Box3().setFromObject(root);
    const center = box.getCenter(new Vector3());
    root.position.sub(center);
    camera.lookAt(0,0,0);

    // Resize
    function resize() {
      const r = mount.getBoundingClientRect();
      const w = Math.max(1, Math.floor(r.width));
      const h = Math.max(460, Math.floor(r.height));
      renderer.setSize(w, h, false);
      camera.aspect = w/h;
      camera.updateProjectionMatrix();
    }
    resize();
    window.addEventListener('resize', resize);

    // HUD
    function drawHUD(v) {
      const ctx = hud.getContext('2d');
      ctx.clearRect(0,0,200,110);
      ctx.fillStyle = '#07090b'; ctx.fillRect(0,0,200,110);
      ctx.strokeStyle = '#222'; ctx.lineWidth = 6;
      ctx.strokeRect(4,4,192,102);
      ctx.fillStyle = '#ffe26a';
      ctx.font = '700 64px "DM Mono", monospace';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
      ctx.fillText((v||0).toFixed(2), 100, 55);
    }
    drawHUD(0);

    // Physics & Input
    let angX = 0, vel = 0, spinning = false, spin1 = null, total = 0, done = false;
    const FRICTION = 0.992, VMIN = 0.002, PIX2RAD = 0.025;

    function setAngle(a) { angX = a; wheel.rotation.x = a; }
    function idxFrom(a) {
      let t = (a % TAU + TAU) % TAU;
      return Math.floor((t + STEP/2) / STEP) % N;
    }
    function currentVal() { return parseFloat(labels[idxFrom(angX)]); }
    function snapTarget() {
      const i = idxFrom(angX);
      return i * STEP;
    }

    const surf = renderer.domElement;
    let dragging = false, lastY = 0, lastT = 0, samples = [];

    function getY(e) { return e.touches ? e.touches[0].clientY : e.clientY; }
    function down(e) { if (spinning || done) return; dragging = true; samples = []; lastY = getY(e); lastT = performance.now(); e.preventDefault(); }
    function move(e) {
      if (!dragging) return;
      const y = getY(e), dy = lastY - y; // swipe down → positive
      setAngle(angX + dy * PIX2RAD);
      const dt = performance.now() - lastT;
      if (dt > 0) { samples.push(dy * PIX2RAD / (dt/1000)); if (samples.length > 6) samples.shift(); }
      lastY = y; lastT = performance.now();
      e.preventDefault();
    }
    function up() {
      if (!dragging) return; dragging = false;
      const v = samples.length ? samples.reduce((a,b)=>a+b,0)/samples.length : 0;
      vel = Math.max(2, Math.min(12, Math.abs(v * 1.4))) * Math.sign(v || 1);
      startSpin();
    }

    surf.addEventListener('mousedown', down);
    surf.addEventListener('touchstart', down, {passive:false});
    window.addEventListener('mousemove', move);
    window.addEventListener('touchmove', move, {passive:false});
    window.addEventListener('mouseup', up);
    window.addEventListener('touchend', up);

    spinBtn.onclick = () => { if (spinning || done) return; vel = 8; startSpin(); };
    holdBtn.onclick = () => { if (spinning || done || spin1 === null) return; settleHold(); };
    resetBtn.onclick = reset;

    function startSpin() {
      spinning = true;
      spinBtn.disabled = holdBtn.disabled = resetBtn.disabled = true;
      msg.className = 't';
      msg.textContent = spin1 === null ? 'Spinning 1...' : 'Spinning 2...';

      const loop = () => {
        setAngle(angX + vel * (1/60));
        vel *= FRICTION;
        drawHUD(currentVal());

        if (Math.abs(vel) < VMIN) {
          const target = snapTarget();
          const diff = ((target - angX + TAU*3) % TAU) - TAU;
          if (Math.abs(diff) > 0.001) {
            setAngle(angX + diff * 0.25);
            requestAnimationFrame(loop);
          } else {
            setAngle(target);
            spinning = false;
            onSettle();
          }
        } else {
          requestAnimationFrame(loop);
        }
      };
      requestAnimationFrame(loop);
    }

    function onSettle() {
      const landed = currentVal();
      if (spin1 === null) {
        spin1 = landed; total = landed;
        msg.textContent = `Spin 1: ${landed.toFixed(2)} — total ${total.toFixed(2)}. Spin again or HOLD.`;
        holdBtn.disabled = false;
        spinBtn.disabled = false;
        resetBtn.disabled = false;
        return;
      }

      total += landed;
      drawHUD(total);

      if (total > 1.00) {
        done = true;
        msg.className = 't lose';
        msg.textContent = `BUST — ${total.toFixed(2)} is over 1.00`;
        end(0, 'Bust');
        return;
      }
      if (total === 1.00) {
        msg.className = 't win';
        msg.textContent = 'Exact 1.00 — 5×! Bonus spin...';
        bonus();
        return;
      }
      if (total >= 0.95) end(1, 'Near 1.00');
      else end(0, 'Under 1.00');
    }

    function settleHold() {
      if (total === 1.00) { bonus(); return; }
      if (total >= 0.95) end(1, 'Held near 1.00');
      else end(0, 'Held under 1.00');
    }

    function bonus() {
      vel = 7.5; spinning = true;
      const loop = () => {
        setAngle(angX + vel * (1/60));
        vel *= FRICTION;
        if (Math.abs(vel) < VMIN) {
          const v = currentVal();
          const extra = v === 0.05 ? 5 : v === 0.15 ? 15 : v === 1.00 ? 25 : 0;
          msg.className = extra ? 't win' : 't';
          msg.textContent = extra ? `BONUS HIT ${v}! +${extra}×` : `Bonus missed — kept 5×`;
          done = true;
          resetBtn.disabled = false;
        } else {
          requestAnimationFrame(loop);
        }
      };
      requestAnimationFrame(loop);
    }

    function end(mult, label) {
      done = true;
      spinBtn.disabled = holdBtn.disabled = true;
      resetBtn.disabled = false;
      msg.className = mult ? 't win' : 't lose';
      msg.textContent = mult ? `${label} — ${mult.toFixed(2)}× multiplier` : `${label} — 0×`;
    }

    function reset() {
      spinning = false; spin1 = null; total = 0; done = false;
      holdBtn.disabled = true;
      spinBtn.disabled = resetBtn.disabled = false;
      setAngle(0); // 1.00 at top
      drawHUD(0);
      msg.className = 't';
      msg.textContent = 'Spin up to two times to reach 1.00 without going over.';
      resize();
    }

    function render() {
      renderer.render(scene, camera);
      requestAnimationFrame(render);
    }

    setAngle(0);
    render();
    requestAnimationFrame(resize);
  }
})();
</script>
</body>
</html>
