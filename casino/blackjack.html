<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>$BAG Blackjack</title>

<link rel="preconnect" href="https://api.coingecko.com" crossorigin>
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>
<script>window.__BAG_FORCE_DEMO = false;</script>

<style>
  *{box-sizing:border-box}
  :root{
    --gold:#ffe175;--bg:#020703;--panel:#0b1b13;--panel2:#0d2217;--muted:#aeb7af;--fg:#f5f7f4;
    --green:#2fbf6b;--line:#173524;--shadow:rgba(0,0,0,.35);
    --lose:#e25b5b; --warn:#e8a85c; --ok:#2fbf6b;
    --felt:#0e2f21; --table:#091a13; --edge:#1a5136;

    --card-w:clamp(64px,16vw,90px);
    --card-h:calc(var(--card-w)*1.42);
  }
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.55}
  img{display:block;max-width:100%;height:auto}
  button,input{font-size:16px}

  /* Header */
  .game-header{text-align:center;padding:36px 10px 14px;max-width:1200px;margin:0 auto}
  .game-header img.hero-img{margin-bottom:10px;filter:drop-shadow(0 10px 24px rgba(46,191,107,.18))}
  .game-header h2{font-size:clamp(1.6rem,5vw,2.4rem);margin:6px 0 0}
  @media (min-width:900px){
    .game-header img.hero-img{width:34vw;max-width:420px;margin-left:auto;margin-right:auto}
  }

  .game-teaser{padding:10px 16px 60px;background:
    radial-gradient(1200px 600px at 10% -10%, #0e2c1d 0%, transparent 60%),
    radial-gradient(900px 500px at 110% 20%, #0b2318 0%, transparent 55%),#060806;
    border-top:1px solid #131313;border-bottom:1px solid #131313}
  .game-wrap{max-width:1080px;margin:0 auto;display:grid;grid-template-columns:1.12fr .88fr;gap:22px}
  @media (max-width:900px){.game-wrap{grid-template-columns:1fr}}

  .panel{background:linear-gradient(180deg,var(--panel) 0%,var(--panel2) 100%);
    border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 24px var(--shadow)}
  .mock{padding:16px}

  .section-title{font-weight:800;font-size:1.2rem;margin:0 0 12px}
  .stack{display:grid;gap:10px}
  .choice{display:flex;gap:10px;flex-wrap:wrap}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;border:1px solid #2b6a48;background:#0e2a1c;color:#e9efe9;font-weight:800}
  .chip input{accent-color:#2fbf6b}
  .mono{font-variant-numeric:tabular-nums}
  .micro{font-size:.85rem;color:#a8b5ab}
  .muted{color:#cfd6cf}
  .divider{height:1px;background:#123221;margin:10px 0}
  .callout{margin-top:12px;padding:12px;border:1px dashed #29543d;border-radius:12px;background:#0c2418;color:#e4efe7}

  /* Inputs */
  input[type=number]{width:140px;background:#0b2217;border:1px solid #1b4a2f;border-radius:10px;color:#f3f5f0;padding:10px}

  /* Quick chips ‚Äî green like other games */
  .preset-chips{ display:flex; gap:8px; flex-wrap:wrap; margin-top:8px; }
  .preset-chip{
    appearance:none; border:1px solid #3fa86a; background:#1a3b2a; color:#ffffff;
    border-radius:999px; padding:6px 12px; font-weight:800; cursor:pointer;
    box-shadow:inset 0 1px 0 rgba(255,255,255,.06);
  }
  .preset-chip:focus-visible{ outline:2px solid var(--gold); outline-offset:2px; }
  .preset-chip.active{ background:#2a6b4a; border-color:#57d08c; box-shadow:0 0 0 2px rgba(63,168,106,.25) inset; }

  /* Table / felt */
  .marquee{ text-align:center;font-weight:900;letter-spacing:.08em;color:#ffe9a6;
    background:linear-gradient(180deg,#163a28,#0f281e); border:1px solid #2a6447;border-radius:12px;padding:8px;margin-bottom:10px }
  .felt{
    background:
      radial-gradient(1200px 600px at 50% -8%, #145b3b 0%, transparent 60%),
      radial-gradient(900px 550px at 120% 8%, #0f3c29 0%, transparent 55%),
      var(--felt);
    border:1px solid var(--edge); border-radius:14px; padding:12px;
  }
  .table{background:linear-gradient(180deg, var(--table), #06120d);border:1px solid var(--edge);border-radius:12px;padding:10px;
    box-shadow:inset 0 1px 0 rgba(255,255,255,.04)}

  .hand{position:relative;min-height:calc(var(--card-h) + 36px);padding-top:24px}
  .label{position:absolute;top:0;left:0;color:#cbd8d0;font-size:12px}
  .total{position:absolute;top:0;right:0;background:#0f2e20;border:1px solid #1a5136;color:#ffe175;padding:3px 10px;border-radius:999px;font-size:12px}
  .cards{display:flex;gap:14px;flex-wrap:nowrap}

  /* Cards: pro look with SVG faces */
  .card{width:var(--card-w);height:var(--card-h);border-radius:14px;border:2px solid #e6ece8;background:#fff;
    box-shadow:0 12px 28px rgba(0,0,0,.35);position:relative;overflow:hidden;transform:translateY(18px);opacity:0;animation:in .18s ease-out forwards}
  @keyframes in{to{transform:translateY(0);opacity:1}}
  .card.red{color:#c1121f}.card.black{color:#0b0b0b}
  .corner{position:absolute;font-size:clamp(12px,2.2vw,14px);line-height:1.05;font-weight:900}
  .tl{top:8px;left:9px}.br{bottom:8px;right:9px;transform:rotate(180deg)}
  .pip{display:none}
  .back{
    background:
      linear-gradient(135deg, rgba(255,255,255,.08), rgba(0,0,0,.10)),
      repeating-linear-gradient(45deg,#0b1b13 0px,#0b1b13 8px,#0e2217 8px,#0e2217 16px);
    border-color:#194733;
  }

  /* Buttons */
  .btnbar{display:flex;gap:10px;flex-wrap:wrap;justify-content:center;margin:10px 0 0}
  .btn{min-width:120px;padding:12px 14px;border:0;border-radius:12px;font-weight:900;cursor:pointer;color:#08130d;background:linear-gradient(180deg,#ffe175, #f5c94c);box-shadow:0 6px 0 #b08a19, 0 16px 32px rgba(255,225,117,.18)}
  .btn.alt{color:#e9efe9;background:#15261c;box-shadow:none;border:1px solid #2b6a48}
  .btn:disabled{opacity:.55;cursor:not-allowed}

  /* HUD pills */
  .hud{display:flex;gap:6px;flex-wrap:wrap;justify-content:center;margin-top:8px}
  .pill{background:#0a1e15;border:1px solid #244330;border-radius:999px;padding:6px 10px;font-size:12px;color:#cfe6d8}
  .result{margin-top:10px;padding:10px;border:1px solid #1b4a2f;border-radius:12px;background:#0b2217;color:#dfece7}
  .t.win{color:#2fbf6b}.t.push{color:#e8a85c}.t.lose{color:#e25b5b}

  /* Footer (fix wrapping) */
  footer.footer{
    display:flex; flex-direction:column; gap:6px;
    text-align:center; padding:16px 10px; line-height:1.5;
    border-top:1px solid #13251a; background:#06120d;
  }
  .footer .links{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }
  .footer a{ color:#e0c66f; text-decoration:none; font-weight:700 }
  .footer small{ color:#c7d1c9; opacity:.9 }
</style>

<script src="/js/bag-session.js"></script>
</head>
<body>

<section class="game-header">
  <img src="/assets/bag-blackjack.png" alt="$BAG Blackjack" class="hero-img" loading="lazy" decoding="async">
  <h2>üé¥ $BAG BLACKJACK</h2>
  <p class="micro" style="margin-top:4px;opacity:.9;">üí∞ <strong>All payouts are in $BAG.</strong> $XRP bets convert automatically at the live rate.</p>
</section>

<section class="game-teaser">
  <div class="game-wrap">

    <!-- LEFT: Controls -->
    <div class="panel mock">
      <div class="section-title">Stake & Prices</div>
      <div class="stack">
        <div>
          <div class="micro">Amount</div>
          <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
            <div style="display:flex;align-items:center;gap:6px">
              <input id="usdBet" class="mono" type="number" inputmode="decimal" enterkeyhint="done" min="0" max="2000" step="0.01" placeholder="0.00" style="width:140px">
              <span class="micro" aria-hidden="true">USD</span>
            </div>
          </div>
          <!-- Quick chips (green) -->
          <div class="preset-chips" id="usdPresets" role="group" aria-label="Quick bet">
            <button type="button" class="preset-chip" data-usd="1">$1</button>
            <button type="button" class="preset-chip" data-usd="2">$2</button>
            <button type="button" class="preset-chip" data-usd="5">$5</button>
            <button type="button" class="preset-chip" data-usd="10">$10</button>
            <button type="button" class="preset-chip" data-usd="20">$20</button>
            <button type="button" class="preset-chip" data-usd="50">$50</button>
            <button type="button" class="preset-chip" data-usd="100">$100</button>
            <button type="button" class="preset-chip" data-usd="max">Max</button>
          </div>
        </div>

        <div>
          <div class="micro">Bet currency</div>
          <div class="choice" id="curToggle">
            <label class="chip"><input type="radio" name="betCur" value="XRP" checked> XRP</label>
            <label class="chip"><input type="radio" name="betCur" value="BAG"> BAG</label>
          </div>
        </div>

        <div>
          <div class="micro">Bet amount</div>
          <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
            <div>
              <input id="betQty" class="mono" type="number" inputmode="decimal" enterkeyhint="done" min="0" step="any" value="1" style="width:140px">
              <span class="unit">XRP</span>
            </div>
          </div>
          <div class="micro" id="betLimits" style="margin-top:6px"></div>
        </div>

        <div class="divider"></div>

        <div class="micro">Live prices</div>
        <div class="muted mono" id="liveLine">
          <span id="liveDot" class="warn">‚óè</span>
          <span> BAG $<span id="liveBAG">‚Äî</span> ¬∑ XRP $<span id="liveXRP">‚Äî</span> <span id="liveNote"></span></span>
          <div class="micro" id="liveConv" style="margin-top:4px;opacity:.9;">1 BAG ‚âà ‚Äî XRP ¬∑ 1 XRP ‚âà ‚Äî BAG</div>
        </div>

        <div class="callout mono" id="payoutBox">
          Payouts ‚Äî <b>Blackjack 2.00√ó</b> ¬∑ <b>Win 1.25√ó</b> ¬∑ <b>Push</b> returns stake
        </div>
      </div>
    </div>

    <!-- RIGHT: Table -->
    <div class="panel mock">
      <div class="marquee">$BAG TABLE</div>
      <div class="felt">
        <div class="table">
          <div class="hand" id="dealer">
            <div class="label">Dealer</div><div class="total" id="dealerTotal">0</div>
            <div class="cards" id="dealerCards"></div>
          </div>
          <div class="hand" id="player">
            <div class="label">You</div><div class="total" id="playerTotal">0</div>
            <div class="cards" id="playerCards"></div>
          </div>
          <div id="splitArea"></div>

          <div class="btnbar">
            <button id="deal" class="btn">Deal</button>
            <button id="hit"  class="btn" disabled>Hit</button>
            <button id="stand"class="btn" disabled>Stand</button>
            <button id="double"class="btn alt" disabled>Double</button>
            <button id="split" class="btn alt" disabled>Split</button>
            <button id="again" class="btn" style="display:none">New Hand</button>
          </div>

          <div class="hud">
            <span class="pill">Mode: <b id="modeLbl">Demo</b></span>
            <span class="pill">Balance: <b id="balLbl">‚Äî</b> <span id="ccyLbl">BAG</span></span>
            <span class="pill">Bet: <b id="betLbl">1</b></span>
            <span class="pill">Last: <b id="lastLbl">‚Äî</b></span>
          </div>

          <div id="status" class="result">Place a stake, then Deal</div>
        </div>
      </div>
    </div>

  </div>
</section>

<!-- Celebration overlay (reuses Dice win overlay if you include it site-wide) -->
<canvas id="win-canvas" style="display:none"></canvas>
<div id="win-overlay" style="display:none"></div>

<!-- AUDIO (shared + card slide/shuffle) -->
<script>
(function(){
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let AC=null, MASTER=null, lastTap=0, watchdog=null;

  function getAC(){
    if (AC && AC.state!=='closed') return AC;
    if (!AudioCtx) return null;
    AC = new AudioCtx();
    MASTER = AC.createGain();
    MASTER.gain.value = .22;
    MASTER.connect(AC.destination);
    return AC;
  }
  async function resume(){
    const ac = getAC();
    if (!ac) return;
    if (ac.state === 'suspended'){ try{ await ac.resume(); }catch{} }
  }
  addEventListener('pointerdown', ()=>{ lastTap=Date.now(); resume(); }, {passive:true});
  addEventListener('visibilitychange', ()=>{ if(!document.hidden) resume(); });
  if(!watchdog){
    watchdog = setInterval(()=>{ const ac=getAC(); if(!ac) return;
      if(Date.now()-lastTap<30000 && ac.state==='suspended') resume();
    }, 1500);
  }

  function chime(){ const ac=getAC(); if(!ac||ac.state!=='running') return; const now=ac.currentTime;
    [880,1320,1760].forEach((f,i)=>{ const o=ac.createOscillator(); o.type='triangle'; o.frequency.value=f;
      const g=ac.createGain(); g.gain.setValueAtTime(.0001,now+i*.02); g.gain.linearRampToValueAtTime(.18,now+i*.02+.04); g.gain.exponentialRampToValueAtTime(.0001,now+i*.02+.32);
      o.connect(g).connect(MASTER); o.start(now+i*.02); o.stop(now+i*.02+.34); });
  }
  function thud(){ const ac=getAC(); if(!ac||ac.state!=='running') return;
    const o=ac.createOscillator(), g=ac.createGain(); o.type='sine';
    const t=ac.currentTime; o.frequency.setValueAtTime(260,t); o.frequency.exponentialRampToValueAtTime(140,t+.22);
    g.gain.setValueAtTime(.0001,t); g.gain.linearRampToValueAtTime(.10,t+.02); g.gain.exponentialRampToValueAtTime(.0001,t+.25);
    o.connect(g).connect(MASTER); o.start(t); o.stop(t+.27);
  }

  // Card slide / shuffle (noise bursts)
  function noise(duration=0.12, vol=.18, freq=1800){
    const ac=getAC(); if(!ac||ac.state!=='running') return;
    const src = ac.createBufferSource();
    const buf = ac.createBuffer(1, ac.sampleRate*duration, ac.sampleRate);
    const data = buf.getChannelData(0);
    for(let i=0;i<data.length;i++) data[i]=(Math.random()*2-1)*0.35;
    src.buffer=buf;
    const g=ac.createGain(); g.gain.value=.0;
    const lp=ac.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value=freq;
    src.connect(lp).connect(g).connect(MASTER);
    const t=ac.currentTime;
    g.gain.linearRampToValueAtTime(vol, t+.01);
    g.gain.exponentialRampToValueAtTime(.001, t+duration);
    src.start();
  }
  function slide(){ try{ noise(.10,.16,1700); }catch{} }
  function shuffle(){ noise(.08,.14,1600); setTimeout(()=>noise(.08,.14,1600), 90); setTimeout(()=>noise(.08,.14,1600), 180); }

  window.__bagAudio = Object.assign({}, window.__bagAudio||{}, { chime, thud, slide, shuffle, resume });
})();
</script>

<!-- PRICES (same logic as Dice) -->
<script>
(function(){
  const PRICE_REFRESH_MS = 15000;
  const FETCH_TIMEOUT_MS = 8000;
  const LIVE_CACHE_TTL_MS = 24*60*60*1000;
  const VIEW_CACHE_TTL_MS = 6*60*60*1000;

  const XRPL_WSS = 'wss://s1.ripple.com';
  const BAG_ISSUER = 'rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr';
  const BAG_CODE = 'BAG';

  const VIEW_CACHE_KEY = 'bag_prices_v8';
  const LAST_LIVE_KEY  = 'bag_last_live_v1';
  const XRP_KEY        = 'xrp_usd';

  const PRICES = (window.__PRICES__ = window.PRICES = window.__PRICES__ || window.PRICES || { bagUsd:0, xrpUsd:0, source:'‚Äî', ts:0 });

  const liveDot = document.getElementById('liveDot');
  const liveBAG = document.getElementById('liveBAG');
  const liveXRP = document.getElementById('liveXRP');
  const liveNote = document.getElementById('liveNote');
  const liveConv = document.getElementById('liveConv');

  function fmt(n){ return Number.isFinite(n) ? n.toLocaleString(undefined,{maximumFractionDigits:6}) : '‚Äî'; }
  function cacheSet(k,v){ try{ localStorage.setItem(k, JSON.stringify({t:Date.now(), v})); }catch{} }
  function cacheGet(k, ttlMs){
    try{
      const o=JSON.parse(localStorage.getItem(k)||'null');
      if(!o) return null;
      const age = Date.now() - (o.t||0);
      return age<=ttlMs ? o.v : null;
    }catch{ return null; }
  }
  function timedFetch(url, opts={}, timeout=FETCH_TIMEOUT_MS){
    const ctrl = new AbortController();
    const id = setTimeout(()=>ctrl.abort(new Error('timeout')), timeout);
    try{
      const u = new URL(url, location.origin);
      u.searchParams.set('_ts', Date.now().toString());
      return fetch(u.toString(), {
        ...opts,
        headers: { Accept:'application/json', ...(opts.headers||{}) },
        mode:'cors', cache:'no-store', credentials:'omit', referrerPolicy:'no-referrer',
        signal: ctrl.signal
      });
    } finally { setTimeout(()=>clearTimeout(id),0); }
  }

  function updateLiveLine(){
    if (liveBAG)  liveBAG.textContent  = fmt(PRICES.bagUsd);
    if (liveXRP)  liveXRP.textContent  = Number.isFinite(PRICES.xrpUsd)
      ? PRICES.xrpUsd.toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2})
      : '‚Äî';
    if (liveDot)  liveDot.className    = (PRICES.source==='live-amm' ? 'ok' : PRICES.source==='last-live' ? 'warn' : 'err');
    if (liveNote) liveNote.textContent = (PRICES.source==='live-amm' ? ' (AMM live)' : PRICES.source==='last-live' ? ' (last live)' : ' (unavailable)');
    if (liveConv){
      if(PRICES.bagUsd>0 && PRICES.xrpUsd>0){
        const xrpPerBag = PRICES.bagUsd/PRICES.xrpUsd;
        const bagPerXrp = PRICES.xrpUsd/PRICES.bagUsd;
        liveConv.textContent = `1 BAG ‚âà ${xrpPerBag.toLocaleString(undefined,{maximumFractionDigits:6})} XRP ¬∑ 1 XRP ‚âà ${bagPerXrp.toLocaleString(undefined,{maximumFractionDigits:6})} BAG`;
      } else {
        liveConv.textContent = '1 BAG ‚âà ‚Äî XRP ¬∑ 1 XRP ‚âà ‚Äî BAG';
      }
    }
    try{
      window.PRICES = window.__PRICES__ = PRICES;
      window.dispatchEvent(new CustomEvent('bag:pricesUpdated'));
    }catch{}
  }

  async function fetchXrpUsdLive(){
    try{
      const r = await timedFetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
      if(!r.ok) throw 0;
      const v = (await r.json())?.ripple?.usd;
      if(Number(v)>0){
        PRICES.xrpUsd = Number(v);
        cacheSet(XRP_KEY, PRICES.xrpUsd);
        return true;
      }
    }catch(_){}
    return false;
  }
  function parseXrpAmount(a){ if (a==null) return null; if (typeof a==='string') return Number(a)/1_000_000; if (typeof a==='object' && a.currency==='XRP') return Number(a.value); return null; }
  function parseIouAmount(a){ if (!a || typeof a!=='object') return null; return Number(a.value); }
  async function fetchBagViaAMMLive(){
    const req = { id:1, command:'amm_info', asset:{currency:BAG_CODE,issuer:BAG_ISSUER}, asset2:{currency:'XRP'} };
    const xrpPerBag = await new Promise((resolve)=>{
      const ws = new WebSocket(XRPL_WSS);
      const t = setTimeout(()=>{ try{ws.close();}catch{}; resolve(null); }, 8000);
      ws.onopen = ()=> ws.send(JSON.stringify(req));
      ws.onerror = ()=>{ clearTimeout(t); try{ws.close();}catch{}; resolve(null); };
      ws.onmessage = (ev)=>{
        try{
          const msg = JSON.parse(ev.data);
          if (msg.id!==1 || !msg.result || !msg.result.amm) return;
          clearTimeout(t); try{ws.close();}catch{};
          const amm = msg.result.amm;
          const bagBal = parseIouAmount(amm.amount);
          const xrpBal = parseXrpAmount(amm.amount2);
          if (!(bagBal>0) || !(xrpBal>0)) return resolve(null);
          const price = xrpBal / bagBal;
          if (!(price>0) || !isFinite(price)) return resolve(null);
          resolve(price);
        }catch{ resolve(null); }
      };
    });
    if (!(xrpPerBag>0)) return false;
    if (!(PRICES.xrpUsd>0)) return false;
    PRICES.bagUsd = PRICES.xrpUsd * xrpPerBag;
    PRICES.source = 'live-amm';
    cacheSet(LAST_LIVE_KEY, { bagUsd: PRICES.bagUsd, xrpUsd: PRICES.xrpUsd });
    cacheSet(VIEW_CACHE_KEY, { bagUsd: PRICES.bagUsd, xrpUsd: PRICES.xrpUsd });
    return true;
  }

  function loadLastLiveBundle(){
    const v = cacheGet(LAST_LIVE_KEY, LIVE_CACHE_TTL_MS);
    if (v && Number(v.bagUsd)>0){
      PRICES.bagUsd = Number(v.bagUsd);
      if (Number(v.xrpUsd)>0) PRICES.xrpUsd = Number(v.xrpUsd);
      PRICES.source = 'last-live';
      return true;
    }
    return false;
  }
  function loadViewCache(){
    const v = cacheGet(VIEW_CACHE_KEY, VIEW_CACHE_TTL_MS);
    const x = cacheGet(XRP_KEY, VIEW_CACHE_TTL_MS);
    let ok = false;
    if (v && Number(v.bagUsd)>0){
      PRICES.bagUsd = Number(v.bagUsd);
      if (Number(v.xrpUsd)>0) PRICES.xrpUsd = Number(v.xrpUsd);
      ok = true;
    }
    if (!PRICES.xrpUsd && Number(x)>0){ PRICES.xrpUsd = Number(x); ok = true; }
    if (ok && PRICES.source==='‚Äî') PRICES.source = 'last-live';
    return ok;
  }

  async function refreshPrices(){
    let liveOk = false;
    const gotX = await fetchXrpUsdLive();
    const gotBag = await fetchBagViaAMMLive();
    liveOk = gotX && gotBag;
    if (!liveOk){
      if (!loadLastLiveBundle()) loadViewCache();
    }
    PRICES.ts = Date.now();
    updateLiveLine();
  }

  (async ()=>{ await refreshPrices(); setInterval(refreshPrices, PRICE_REFRESH_MS); })();

  window.addEventListener('storage', (e)=>{
    if (e.key === VIEW_CACHE_KEY || e.key === XRP_KEY || e.key === LAST_LIVE_KEY){
      if (!loadLastLiveBundle()) loadViewCache();
      updateLiveLine();
    }
  });
})();
</script>

<!-- Stake wiring (USD autofill from units; presets; limits) -->
<script>
(function(){
  const usdBetEl = document.getElementById('usdBet');
  const betQtyEl = document.getElementById('betQty');
  const curToggle = document.getElementById('curToggle');
  const unitSpan  = document.querySelector('.unit');
  const betLimits = document.getElementById('betLimits');
  const presets   = document.getElementById('usdPresets');

  const MIN_USD = 1, MAX_USD = 2000;
  const PR = ()=>window.__PRICES__||{bagUsd:0,xrpUsd:0};

  function currentCurrency(){
    const el = curToggle?.querySelector('input[name="betCur"]:checked');
    return el ? String(el.value).toUpperCase() : 'XRP';
  }
  function priceForCurrent(){
    const {bagUsd,xrpUsd}=PR();
    return currentCurrency()==='BAG' ? bagUsd : xrpUsd;
  }
  function qty(){ const v=parseFloat(betQtyEl?.value||''); return Number.isFinite(v)&&v>0?v:1; }
  function derivedUsd(){
    const px = priceForCurrent();
    const q=qty();
    return px>0 ? q*px : 0;
  }
  function fmtUsd(n){ return '$'+(Number(n)||0).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}); }

  function clearPresetActive(){ try{ presets?.querySelectorAll('.preset-chip.active').forEach(b=>b.classList.remove('active')); }catch{} }

  function setFromUsd(value){
    const u = Math.max(0, Math.min(MAX_USD, Number(value)||0));
    if (usdBetEl){
      usdBetEl.value = u ? u.toFixed(2) : '';
      usdBetEl.dataset.userTyped = u ? '1' : '0';
    }
    const px = priceForCurrent();
    if (betQtyEl){
      if (px>0 && u>0){
        const units = Math.floor((u/px)*1e6)/1e6;
        betQtyEl.value = units || '';
      } else {
        betQtyEl.value = '';
      }
    }
    renderLimits();
    window.dispatchEvent(new CustomEvent('bag:hudRefresh'));
  }

  function autoFillUsd(){
    if (!usdBetEl) return;
    if (usdBetEl.dataset.userTyped==='1') return; // keep manual/preset
    const v = derivedUsd();
    if (v>0){
      usdBetEl.value = (Math.round(v*100)/100).toFixed(2);
      usdBetEl.dataset.autofill='1';
    }else{
      usdBetEl.value = '';
      usdBetEl.dataset.autofill='0';
    }
  }

  function renderLimits(){
    const direct = parseFloat(usdBetEl?.value||'');
    const uv = (Number.isFinite(direct) && direct>0) ? direct : derivedUsd();
    const warn = (uv>0 && uv<MIN_USD) ? ` ¬∑ <span style="color:#e8a85c">Min $${MIN_USD.toFixed(2)}</span>` :
                 (uv>MAX_USD) ? ` ¬∑ <span style="color:#e8a85c">Max $${MAX_USD.toFixed(2)}</span>` : '';
    if (betLimits) betLimits.innerHTML = `Limits: $${MIN_USD.toFixed(2)}‚Äì$${MAX_USD.toFixed(2)} ¬∑ Your stake ‚âà $${uv.toFixed(2)}${warn}`;
  }

  // Inputs
  usdBetEl?.addEventListener('input', ()=>{ clearPresetActive(); usdBetEl.dataset.userTyped = (usdBetEl.value && usdBetEl.value.length) ? '1' : '0'; renderLimits(); });
  betQtyEl?.addEventListener('input', ()=>{ clearPresetActive(); autoFillUsd(); renderLimits(); });
  curToggle?.addEventListener('change', ()=>{
    if(unitSpan) unitSpan.textContent=currentCurrency();
    if (usdBetEl?.dataset.userTyped==='1'){
      const val = parseFloat(usdBetEl.value)||0;
      setFromUsd(val);
    } else {
      autoFillUsd();
      renderLimits();
    }
  });
  window.addEventListener('bag:pricesUpdated', ()=>{ 
    if (usdBetEl?.dataset.userTyped==='1'){
      const val = parseFloat(usdBetEl.value)||0;
      setFromUsd(val);
    } else {
      autoFillUsd();
      renderLimits();
    }
  });

  // Preset chips
  presets?.addEventListener('click', (e)=>{
    const b = e.target.closest('.preset-chip'); if(!b) return;
    clearPresetActive(); b.classList.add('active');
    const d = b.dataset.usd;
    const val = (d==='max') ? 2000 : Math.max(0, Number(d)||0);
    setFromUsd(val);
  });

  if(unitSpan) unitSpan.textContent=currentCurrency();
  autoFillUsd();
  renderLimits();
})();
</script>

<!-- Blackjack game logic -->
<script>
(function(){
  // ====== Cards & shoe ======
  const CONFIG = { decks:1, hitSoft17:true, allowDouble:true, allowSplit:true, mBJ:2.00, mWIN:1.25, mPUSH:1.00 };
  let shoe=[];
  function buildShoe(){
    const R=['A','2','3','4','5','6','7','8','9','10','J','Q','K'], S=['‚ô†','‚ô•','‚ô¶','‚ô£']; const t=[];
    for(let d=0;d<CONFIG.decks;d++) for(const r of R) for(const s of S) t.push({r,s});
    for(let i=t.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [t[i],t[j]]=[t[j],t[i]]; }
    shoe=t;
    try{ __bagAudio && __bagAudio.shuffle(); }catch{}
  }
  function draw(){ if(!shoe.length) buildShoe(); return shoe.pop(); }
  function val(hand){ let t=0,a=0; for(const c of hand){ if(c.r==='A'){t+=11;a++;} else if(['K','Q','J','10'].includes(c.r)) t+=10; else t+=parseInt(c.r,10); } while(t>21 && a>0){ t-=10; a--; } return {total:t, soft:(a>0 && t<=21)}; }
  function isBJ(h){ if(h.length!==2) return false; const v=h.map(c=>c.r); return v.includes('A') && ['10','J','Q','K'].some(x=>v.includes(x)); }
  function faceVal(x){ return x.r==='A'?11:(['K','Q','J','10'].includes(x.r)?10:parseInt(x.r,10)); }
  function canSplit(h){ return CONFIG.allowSplit && !STATE.split && h.length===2 && faceVal(h[0])===faceVal(h[1]); }

  // ====== Pro card SVG faces ======
  function svgForCard(rank, suit){
    const red = (suit==='‚ô•' || suit==='‚ô¶'); const col = red ? '#C1121F' : '#0B0B0B';
    const PIPS = {
      '2': [[0,-32],[0,32]],
      '3': [[0,-36],[0,0],[0,36]],
      '4': [[-18,-28],[18,-28],[-18,28],[18,28]],
      '5': [[-18,-28],[18,-28],[0,0],[-18,28],[18,28]],
      '6': [[-18,-32],[18,-32],[-18,0],[18,0],[-18,32],[18,32]],
      '7': [[-18,-34],[18,-34],[-18,-10],[18,-10],[0,10],[-18,32],[18,32]],
      '8': [[-18,-34],[18,-34],[-18,-10],[18,-10],[-18,10],[18,10],[-18,34],[18,34]],
      '9': [[-18,-36],[18,-36],[0,-20],[-18,-2],[18,-2],[-18,20],[18,20],[0,36],[0,0]],
      '10': [[-18,-36],[18,-36],[0,-26],[-18,-12],[18,-12],[-18,12],[18,12],[0,26],[-18,36],[18,36]]
    };
    const SUIT_SVG = {
      '‚ô†': `<path d="M0-20c-16,12-24,26-24,36c0,8,6,14,14,14c6,0,10-3,10-8c0,5,4,8,10,8c8,0,14-6,14-14c0-10-8-24-24-36z" />`,
      '‚ô•': `<path d="M0,36C-28,18-32,0-23,-10c7-8,19-5,23,4c4-9,16-12,23-4C32,0,28,18,0,36z"/>`,
      '‚ô¶': `<path d="M0,-38L26,0L0,38L-26,0Z"/>`,
      '‚ô£': `<path d="M0-16a14,14 0 1 1 0,28a14,14 0 1 1 -9-25a14,14 0 1 1 9-3zM-6,16h12v14h-12z"/>`
    }[suit];
    const FACE = (rank==='J'||rank==='Q'||rank==='K') ? `
      <g transform="translate(0,4)" opacity=".95">
        <circle cx="0" cy="0" r="20" fill="${col}" opacity=".12"/>
        <circle cx="0" cy="0" r="16" fill="none" stroke="${col}" stroke-width="2"/>
        <text x="0" y="6" font-family="ui-sans-serif,system-ui,Segoe UI,Roboto,Arial" font-weight="900" font-size="18" text-anchor="middle" fill="${col}">${rank}</text>
      </g>` : '';
    const center = (rank==='A')
      ? `<g transform="translate(0,0)" fill="${col}" stroke="none">${SUIT_SVG}</g>`
      : (PIPS[rank] ? PIPS[rank].map(([x,y]) =>
          `<g transform="translate(${x},${y})" fill="${col}" stroke="none">${SUIT_SVG}</g>`
        ).join('') : FACE);
    const corner = (x,y)=>`
      <g transform="translate(${x},${y})">
        <text x="0" y="0" font-family="ui-sans-serif,system-ui,Segoe UI,Roboto,Arial" font-weight="900" font-size="18" text-anchor="start" fill="${col}">${rank}</text>
        <text x="0" y="16" font-family="ui-sans-serif,system-ui,Segoe UI,Roboto,Arial" font-weight="900" font-size="18" text-anchor="start" fill="${col}">${suit}</text>
      </g>`;
    return `data:image/svg+xml,${encodeURIComponent(`
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="-45 -70 90 140" shape-rendering="geometricPrecision">
        <rect x="-44" y="-69" width="88" height="138" rx="10" fill="#ffffff"/>
        ${corner(-36,-48)}
        <g transform="rotate(180)">${corner(-36,-48)}</g>
        ${center}
      </svg>
    `)}`;
  }
  function cardEl(c, back=false){
    const el=document.createElement('div');
    el.className = back ? 'card back' : 'card '+(['‚ô•','‚ô¶'].includes(c.s)?'red':'black');
    if(!back){
      el.style.background = `#fff center/cover no-repeat url("${svgForCard(c.r, c.s)}")`;
      el.innerHTML = `<div class="corner tl">${c.r}<br>${c.s}</div><div class="corner br">${c.r}<br>${c.s}</div>`;
    }
    el.animate([{transform:'translateY(18px)',opacity:0},{transform:'translateY(0)',opacity:1}],{duration:180,easing:'cubic-bezier(.2,.9,.2,1)',fill:'forwards'});
    try{ __bagAudio && __bagAudio.slide(); }catch{}
    return el;
  }

  // ====== Session & stake helpers ======
  const PR = ()=>window.__PRICES__||{bagUsd:0,xrpUsd:0};
  const betQtyEl = document.getElementById('betQty');
  const usdBetEl = document.getElementById('usdBet');
  const curToggle = document.getElementById('curToggle');
  function currentCurrency(){ const el = curToggle?.querySelector('input[name="betCur"]:checked'); return el ? String(el.value).toUpperCase() : 'XRP'; }
  function stakeBag(){
    const q = parseFloat(betQtyEl?.value||0) || 0;
    if (!q) return 0;
    const {bagUsd,xrpUsd} = PR();
    if (currentCurrency()==='BAG') return q;
    if (bagUsd>0 && xrpUsd>0) return q * (xrpUsd/bagUsd);
    return 0;
  }
  function stakeUsd(){
    const direct = parseFloat(usdBetEl?.value||'');
    if (Number.isFinite(direct) && direct>0) return direct;
    const q = parseFloat(betQtyEl?.value||0) || 0;
    const {bagUsd,xrpUsd} = PR();
    if (currentCurrency()==='BAG') return bagUsd>0 ? q*bagUsd : 0;
    return xrpUsd>0 ? q*xrpUsd : 0;
  }

  function spendBAG(n){ if(!(n>0)) return true; try{ return !!(__bagSession && __bagSession.spend && __bagSession.spend(n)); }catch{ return false; } }
  function creditBAG(n){ if(!(n>0)) return; try{ __bagSession && __bagSession.credit && __bagSession.credit(n);}catch{} }

  // ====== Rendering helpers ======
  const D = (id)=>document.getElementById(id);
  function clearCards(){
    D('dealerCards').innerHTML=''; D('playerCards').innerHTML='';
    D('dealerTotal').textContent='0'; D('playerTotal').textContent='0';
    const extra=document.querySelectorAll('.splitRow'); extra.forEach(n=>n.remove());
  }
  function addSplitRow(i){
    const row=document.createElement('div'); row.className='hand splitRow';
    row.innerHTML = `<div class="label">You (Hand ${i+1})</div><div class="total" id="pT_${i}">0</div><div class="cards" id="pC_${i}"></div>`;
    D('splitArea').appendChild(row);
  }
  function updateTotals(){
    D('dealerTotal').textContent = val(STATE.dealer).total;
    if(STATE.hands.length===1){
      D('playerTotal').textContent = val(STATE.hands[0]).total;
    }else{
      STATE.hands.forEach((h,i)=>{ const t=val(h).total; (i===0?D('playerTotal'):D('pT_'+i)).textContent = t; });
    }
  }
  function setStatus(txt,cls){ const el=D('status'); el.className='result'+(cls?(' t '+cls):''); el.textContent=txt; }
  function last(s){ D('lastLbl').textContent=s; }

  // ====== State & controls ======
  const STATE = { dealer:[], hands:[], active:0, split:false, locked:0, live:false };
  const btnDeal=D('deal'), btnHit=D('hit'), btnStand=D('stand'), btnDouble=D('double'), btnSplit=D('split'), btnAgain=D('again');

  function lockStake(){
    const bag=stakeBag(), usd=stakeUsd();
    if(!window.__BAG_FORCE_DEMO){
      if(!(usd>=1) || usd>2000) return [false,'Stake must be $1‚Äì$2000'];
    }
    if(!(bag>0)) return [false,'Enter a stake first'];
    if(!spendBAG(bag)) return [false,'Insufficient balance'];
    STATE.locked=bag; return [true,''];
  }

  function revealHole(){
    const dc=D('dealerCards'); const backs=[...dc.children].filter(n=>n.classList.contains('back'));
    if(backs[0]) backs[0].replaceWith(cardEl(STATE.dealer[1],false));
    updateTotals();
  }

  function hitHand(i){
    const node = (STATE.hands.length===1) ? D('playerCards') : (i===0?D('playerCards'):D('pC_'+i));
    const c=draw(); STATE.hands[i].push(c); node.appendChild(cardEl(c)); updateTotals();
  }
  function nextHandOrDealer(){
    if(STATE.hands.length>1){
      STATE.active++;
      if(STATE.active<STATE.hands.length){
        btnDouble.disabled = !(STATE.hands[STATE.active].length===2);
        btnHit.disabled=false; btnStand.disabled=false;
        setStatus(`Hand ${STATE.active+1}: your move`);
        return;
      }
    }
    dealerPhase();
  }
  function dealerPhase(){
    revealHole();
    let dv=val(STATE.dealer);
    while(dv.total<17 || (dv.total===17 && dv.soft && CONFIG.hitSoft17)){
      const c=draw(); STATE.dealer.push(c); D('dealerCards').appendChild(cardEl(c)); dv=val(STATE.dealer);
    }
    updateTotals();
    settleAll();
  }

  function settleAll(override){
    let credit=0; const base=STATE.locked;

    function doHand(h){
      const pv=val(h).total, dv=val(STATE.dealer).total;
      const doubled = h._dbl===true; const stake = base*(doubled?2:1);

      if(override==='blackjack'){ credit += stake*CONFIG.mBJ; setStatus('Blackjack ‚Äî paid 2.00√ó','win'); last('Blackjack 2√ó'); return; }
      if(override==='push-bj'){ credit += stake*CONFIG.mPUSH; setStatus('Push (both Blackjack) ‚Äî stake returned','push'); last('Push'); return; }

      if(pv>21){ setStatus('Busted ‚Äî dealer wins','lose'); last('Scratch'); return; }
      if(dv>21 || pv>dv){
        const mult = (isBJ(h)&&!doubled&&!STATE.split) ? CONFIG.mBJ : CONFIG.mWIN;
        credit += stake*mult;
        setStatus(mult===CONFIG.mBJ?'Blackjack ‚Äî 2.00√ó':`You win ${CONFIG.mWIN.toFixed(2)}√ó`,'win'); last(mult===CONFIG.mBJ?'Blackjack 2√ó':'Win 1.25√ó');
      } else if(pv<dv){
        setStatus('Dealer wins','lose'); last('Scratch');
      } else {
        credit += stake*CONFIG.mPUSH; setStatus('Push ‚Äî stake returned','push'); last('Push');
      }
    }

    if(STATE.hands.length===1) doHand(STATE.hands[0]); else STATE.hands.forEach(doHand);
    if(credit>0) creditBAG(credit);

    btnHit.disabled=true; btnStand.disabled=true; btnDouble.disabled=true; btnSplit.disabled=true; btnDeal.disabled=true; btnAgain.style.display='inline-block';
    STATE.live=false;
  }

  function startRound(){
    const [ok,err]=lockStake(); if(!ok) return alert(err);
    clearCards(); STATE.dealer=[]; STATE.hands=[[]]; STATE.active=0; STATE.split=false; STATE.live=true;

    // initial deal: P, D, P, D(hole)
    const pc=D('playerCards'), dc=D('dealerCards');
    const c1=draw(), c2=draw(), c3=draw(), c4=draw();
    STATE.hands[0].push(c1); pc.appendChild(cardEl(c1));
    STATE.dealer.push(c2); dc.appendChild(cardEl(c2));
    STATE.hands[0].push(c3); pc.appendChild(cardEl(c3));
    STATE.dealer.push(c4); dc.appendChild(cardEl(c4,true));

    updateTotals();
    btnDeal.disabled=true; btnHit.disabled=false; btnStand.disabled=false; btnDouble.disabled=false; btnSplit.disabled=!canSplit(STATE.hands[0]); btnAgain.style.display='none';
    setStatus('Play your hand'); last('Dealt');

    if(isBJ(STATE.hands[0])){
      revealHole();
      const dBJ=isBJ(STATE.dealer);
      settleAll(dBJ?'push-bj':'blackjack');
    }
  }

  // Controls
  btnDeal.addEventListener('click', startRound);
  btnHit.addEventListener('click', ()=>{
    btnDouble.disabled=true;
    hitHand(STATE.active);
    if(val(STATE.hands[STATE.active]).total>21){ setStatus(`Hand ${STATE.hands.length>1?STATE.active+1:''} busts`,'lose'); try{ __bagAudio && __bagAudio.thud(); }catch{}; nextHandOrDealer(); }
  });
  btnStand.addEventListener('click', ()=>{ setStatus(`Hand ${STATE.hands.length>1?STATE.active+1:''} stands`); nextHandOrDealer(); });
  btnDouble.addEventListener('click', ()=>{
    const h=STATE.hands[STATE.active]; if(h.length!==2) return alert('Double only on first turn');
    if(!spendBAG(STATE.locked)) return alert('Insufficient balance');
    h._dbl=true; hitHand(STATE.active); nextHandOrDealer();
  });
  btnSplit.addEventListener('click', ()=>{
    const h=STATE.hands[0]; if(!canSplit(h)) return;
    if(!spendBAG(STATE.locked)) return alert('Insufficient balance');
    STATE.split=true;
    const a=h[0], b=h[1];
    STATE.hands=[ [a], [b] ];
    D('playerCards').innerHTML=''; D('playerTotal').textContent='0';
    addSplitRow(1);
    D('playerCards').appendChild(cardEl(a));
    D('pC_1').appendChild(cardEl(b));
    hitHand(0); hitHand(1);
    updateTotals();
    STATE.active=0; btnSplit.disabled=true; btnDouble.disabled=false;
  });
  btnAgain.addEventListener('click', ()=>{ clearCards(); btnDeal.disabled=false; btnHit.disabled=true; btnStand.disabled=true; btnDouble.disabled=true; btnSplit.disabled=true; btnAgain.style.display='none'; setStatus('Place a stake, then Deal'); last('‚Äî'); });

  // HUD (mode/balance/bet/last)
  (function(){
    const curToggle = document.getElementById('curToggle');
    function PR(){ return window.__PRICES__ || { bagUsd:0, xrpUsd:0 }; }
    function fmt(n, max=6){ const x=Number(n); if(!Number.isFinite(x)) return '‚Äî'; return x.toLocaleString(undefined,{maximumFractionDigits:max}); }
    function currentCurrency(){ const el = curToggle?.querySelector('input[name="betCur"]:checked'); return el ? String(el.value).toUpperCase() : 'XRP'; }
    function getBalances(){
      const sess = (window.__bagSession && window.__bagSession.get && window.__bagSession.get()) || {};
      const bag = Number(sess.bag) || 0;
      let xrp = Number(sess.xrp);
      if (!(xrp > 0)) {
        const { bagUsd, xrpUsd } = PR();
        if (bagUsd > 0 && xrpUsd > 0) xrp = bag * (bagUsd / xrpUsd);
        else xrp = 0;
      }
      return { bag, xrp };
    }
    function currentBet(){
      const v = parseFloat(betQtyEl?.value || '0');
      if (!Number.isFinite(v) || v < 0) return 0;
      return Math.max(0, Math.floor(v));
    }
    function renderHud(){
      try{
        const balLbl=document.getElementById('balLbl'), ccyLbl=document.getElementById('ccyLbl'), betLbl=document.getElementById('betLbl'), modeLbl=document.getElementById('modeLbl'), lastLbl=document.getElementById('lastLbl');
        const mode = (window.__BAG_FORCE_DEMO === true) ? 'Demo' : 'Live';
        const ccy  = currentCurrency();
        const { bag, xrp } = getBalances();
        if (modeLbl) modeLbl.textContent = mode;
        if (betLbl)  betLbl.textContent  = String(currentBet());
        if (lastLbl) lastLbl.textContent = String(window.__BJ_LAST__ || '‚Äî');
        if (balLbl && ccyLbl){
          if (ccy === 'XRP'){ balLbl.textContent = fmt(xrp, 6); ccyLbl.textContent = 'XRP'; }
          else { balLbl.textContent = fmt(bag, 6); ccyLbl.textContent = 'BAG'; }
        }
      }catch(e){}
    }
    [
      'bag:sessionStarted','bag:sessionToppedUp','bag:sessionEnded',
      'bag:pricesUpdated','bag:walletConnected','bag:walletDisconnected',
      'bag:hudRefresh'
    ].forEach(ev => addEventListener(ev, renderHud));
    document.getElementById('betQty')?.addEventListener('input', renderHud);
    curToggle?.addEventListener('change', renderHud);
    addEventListener('storage', (e)=>{ if (e && e.key === '__bag_demo_bag_v1') renderHud(); });
    renderHud(); let tries = 0; const iv = setInterval(()=>{ renderHud(); if(++tries>40) clearInterval(iv); }, 500);
  })();

  // Boot
  function forceBetXRP1(){
    const usd  = document.getElementById('usdBet');
    const unit = document.querySelector('.unit');
    const xrpRadio = document.querySelector('#curToggle input[value="XRP"]');
    const bet  = document.getElementById('betQty');

    if (xrpRadio && !xrpRadio.checked){
      xrpRadio.checked = true;
      xrpRadio.dispatchEvent(new Event('change', {bubbles:true}));
    }
    if (unit) unit.textContent = 'XRP';
    if (bet){
      bet.value = '1';
      bet.dispatchEvent(new Event('input', {bubbles:true}));
      bet.dispatchEvent(new Event('change', {bubbles:true}));
    }
    if (usd){
      // IMPORTANT: don‚Äôt mark as userTyped so live price auto-fills $ for 1 XRP
      usd.dataset.userTyped = '0';
      usd.dispatchEvent(new Event('input', {bubbles:true}));
      usd.dispatchEvent(new Event('change', {bubbles:true}));
    }
    window.dispatchEvent(new CustomEvent('bag:hudRefresh'));
  }

  function boot(){ buildShoe(); forceBetXRP1(); }
  boot();
  setInterval(()=>{ if(shoe.length<15) buildShoe(); }, 2000);
})();
</script>

<!-- Practice Mode Wrapper (Demo by default; Live only with ?live=1) -->
<script>
(function(){
  const qs = new URLSearchParams(location.search);
  const forceLive = qs.get('live') === '1';

  const DEMO_KEY = '__bag_demo_bag_v1';
  const START_BAG = 1000;

  function getBal(){ try{ const n=Number(localStorage.getItem(DEMO_KEY)); return Number.isFinite(n)&&n>0?n:START_BAG; }catch{ return START_BAG; } }
  function setBal(v){ try{ localStorage.setItem(DEMO_KEY, String(Math.max(0, Number(v)))) }catch{} }
  if(localStorage.getItem(DEMO_KEY)==null) setBal(START_BAG);

  function renderDemo(){
    const bag=getBal();
    const bagUsd=(window.__PRICES__?.bagUsd||0)*bag;
    const statusEl=document.getElementById('status');
    if(statusEl){
      statusEl.innerHTML='Practice: <span style="color:#2fbf6b)">'+(Number(bag).toLocaleString())+' BAG</span>' +
        (bagUsd?` <span class="micro" style="opacity:.75">($${bagUsd.toFixed(2)})</span>`:'');
    }
  }

  const demoSession={
    active:()=>true,
    get:()=>({addr:'demo',bag:getBal(),ts:Date.now()}),
    set:()=>{},
    spend(bag){ const b=getBal(); if(!(bag>0)||b<bag) return false; setBal(b-bag); renderDemo(); return true; },
    credit(bag){ if(!(bag>0)) return false; setBal(getBal()+bag); renderDemo(); return true; }
  };

  function enableDemo(){
    try{ Object.defineProperty(window,'__BAG_FORCE_DEMO',{value:true, configurable:true}); }catch{ window.__BAG_FORCE_DEMO=true; }
    window.__bagSession = demoSession;
    renderDemo();

    // Force the bet UI to 1 XRP immediately + next tick + after prices land (so USD shows XRP price, not 1.00)
    (function forceBet(){
      const apply=()=>{ try{ const f=window.forceBetXRP1 || null; }catch{} };
    })();
    const apply = function(){ try{
      const bet  = document.getElementById('betQty');
      const usd  = document.getElementById('usdBet');
      const unit = document.querySelector('.unit');
      const xrpRadio = document.querySelector('#curToggle input[value="XRP"]');
      if (xrpRadio && !xrpRadio.checked){ xrpRadio.checked = true; xrpRadio.dispatchEvent(new Event('change',{bubbles:true})); }
      if (unit) unit.textContent='XRP';
      if (bet){ bet.value='1'; bet.dispatchEvent(new Event('input',{bubbles:true})); bet.dispatchEvent(new Event('change',{bubbles:true})); }
      if (usd){ usd.dataset.userTyped='0'; usd.dispatchEvent(new Event('input',{bubbles:true})); usd.dispatchEvent(new Event('change',{bubbles:true})); }
      window.dispatchEvent(new CustomEvent('bag:hudRefresh'));
    }catch{} };
    apply(); setTimeout(apply,0);
    const once = ()=>{ apply(); window.removeEventListener('bag:pricesUpdated', once); };
    window.addEventListener('bag:pricesUpdated', once);
  }

  function enableLive(){
    window.__BAG_FORCE_DEMO=false;
    window.dispatchEvent(new CustomEvent('bag:pricesUpdated'));
  }

  if (forceLive) enableLive(); else enableDemo();

  window.addEventListener('bag:pricesUpdated', ()=>{ if(window.__BAG_FORCE_DEMO) renderDemo(); });
})();
</script>

<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js').catch(()=>{});
}
</script>

<footer class="footer">
  <small>¬© 2025 $BAG Protocol ¬∑ getthebag.io ¬∑ Powered by $XRP</small>
  <div class="links">
    <a href="https://x.com/getthebag_io" target="_blank" rel="noopener">ùïè @getthebag_io</a>
    <span style="opacity:.45">|</span>
    <a href="https://t.me/getthebag_io" target="_blank" rel="noopener">Telegram @getthebag_io</a>
  </div>
</footer>

</body>
</html>
