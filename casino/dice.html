<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>$BAG Dice</title>

<link rel="preconnect" href="https://api.coingecko.com" crossorigin>

<style>
  *{box-sizing:border-box}
  :root{
    --gold:#ffd700;--bg:#020703;--panel:#0b1b13;--panel2:#0d2217;--muted:#aeb7af;--fg:#f5f7f4;
    --green:#2fbf6b;--green2:#34c759;--line:#173524;--shadow:rgba(0,0,0,.35);
    --red:#e25b5b;
  }
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.55}
  img{display:block;max-width:100%;height:auto}
  button,input{font-size:16px}

  .wrap{max-width:980px;margin:0 auto;padding:20px 16px}
  .panel{background:linear-gradient(180deg,var(--panel) 0%,var(--panel2) 100%);border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 24px var(--shadow);padding:16px}
  .section-title{font-weight:800;font-size:1.15rem;margin:0 0 10px}
  .stack{display:grid;gap:10px}
  .choice{display:flex;gap:10px;flex-wrap:wrap}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;border:1px solid #2b6a48;background:#0e2a1c;color:#e9efe9;font-weight:800}
  .chip input{accent-color:#2fbf6b}
  .mono{font-variant-numeric:tabular-nums}
  .micro{font-size:.85rem;color:#a8b5ab}
  .muted{color:#cfd6cf}
  .divider{height:1px;background:#123221;margin:10px 0}
  .callout{margin-top:12px;padding:12px;border:1px dashed #29543d;border-radius:12px;background:#0c2418;color:#e4efe7}

  .btn-roll{
    width:100%;margin-top:12px;padding:16px 22px;font-size:1.15rem;font-weight:900;text-transform:uppercase;
    letter-spacing:.5px;border:0;border-radius:14px;color:#08130d;background:linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);
    box-shadow:0 6px 0 #b08a19, 0 16px 32px rgba(255,225,117,.18), inset 0 1px 0 rgba(255,255,255,.35);
    transition:transform .06s ease, box-shadow .2s ease, filter .2s ease; cursor:pointer;
  }
  .btn-roll:hover{filter:brightness(1.05);box-shadow:0 6px 0 #b08a19, 0 22px 40px rgba(255,225,117,.26), inset 0 1px 0 rgba(255,255,255,.4)}
  .btn-roll:active{transform:translateY(2px);box-shadow:0 4px 0 #9a7315, 0 12px 24px rgba(255,225,117,.2), inset 0 1px 0 rgba(255,255,255,.3)}
  .btn-roll:disabled{opacity:.65;cursor:not-allowed;transform:none;box-shadow:0 6px 0 #6e6e6e, 0 10px 20px rgba(0,0,0,.2)!important}

  /* Dice table */
  .table{display:grid;grid-template-columns:1fr 1fr;gap:18px}
  @media (max-width: 780px){ .table{grid-template-columns:1fr} }

  .dice-area{display:flex;align-items:center;justify-content:center;padding:18px;border-radius:12px;background:radial-gradient(120% 140% at 50% -20%, #0a1e15 0%, #06100c 60%, #060a08 100%);border:1px solid #1a3625}
  .dice{display:flex;gap:20px}
  .die{
    width:84px;height:84px;border-radius:12px;background:#0d2318;border:1px solid #264a35;position:relative;box-shadow:inset 0 0 30px rgba(0,0,0,.35);
    display:grid;place-items:center;font:800 28px/1 system-ui;color:#e6f4eb;
  }
  .die.rolling{animation: r .5s linear infinite}
  @keyframes r{ from{transform:rotate(0)} to{transform:rotate(360deg)} }

  .result{margin-top:12px;padding:12px;border:1px solid #1b4a2f;border-radius:12px;background:#0b2217;display:flex;align-items:center;gap:10px}
  .result .n{font-weight:900;font-size:1.05rem}

  /* Tiny toast for wins */
  .cele{position:fixed;left:50%;top:14%;transform:translateX(-50%);display:none;padding:10px 16px;border-radius:999px;background:rgba(0,0,0,.45);border:1px solid #2c5740;color:#c7f7df;font-weight:900}
  .cele.show{display:block;animation:fade .9s ease}
  @keyframes fade{0%{opacity:0;transform:translate(-50%,-10px)}40%{opacity:1;transform:translate(-50%,0)}100%{opacity:0}}
</style>
</head>
<body>
<div class="wrap">
  <h2 style="margin:6px 0 14px">üé≤ $BAG Dice</h2>

  <div class="table">
    <!-- LEFT: Game -->
    <div class="panel">
      <div class="section-title">Dice</div>
      <div class="dice-area">
        <div class="dice" id="diceBox">
          <div class="die" id="die1">‚Äî</div>
          <div class="die" id="die2">‚Äî</div>
        </div>
      </div>

      <div class="result" style="margin-top:12px">
        <div class="n">Result:</div>
        <div id="resText" class="t">‚Äî</div>
      </div>

      <div style="margin-top:18px;text-align:center">
        <button id="rollBtn" class="btn-roll" style="width:min(360px,90%)">Roll</button>
      </div>
      <div class="micro" style="text-align:center;opacity:.7;margin-top:6px">
        üîä If you don‚Äôt hear sound: press Roll once, turn off Silent mode, and raise volume.
      </div>
    </div>

    <!-- RIGHT: Stake / Prices / Payouts -->
    <div class="panel">
      <div class="section-title">Stake & Prices</div>
      <div class="stack">
        <div>
          <div style="display:flex;align-items:center;gap:6px">
            <input id="usdBet" class="mono" type="tel" inputmode="decimal" pattern="[0-9.]*"
              min="0" max="2000" step="0.01" placeholder="0.00" aria-label="Stake in USD"
              style="width:140px;background:#0b2217;border:1px solid #1b4a2f;border-radius:10px;color:#f3f5f0;padding:10px">
            <span class="micro" aria-hidden="true">USD</span>
          </div>
        </div>

        <div>
          <div class="micro">Bet currency</div>
          <div class="choice" id="curToggle" role="radiogroup" aria-label="Bet currency">
            <label class="chip"><input type="radio" name="betCur" value="XRP" checked> XRP</label>
            <label class="chip"><input type="radio" name="betCur" value="BAG"> BAG</label>
          </div>
        </div>

        <div>
          <div class="micro">Bet amount</div>
          <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
            <div>
              <input id="demoBet" class="mono" type="tel" inputmode="decimal" pattern="[0-9.]*"
                min="0" step="any" value="1" aria-label="Stake units"
                style="width:140px;background:#0b2217;border:1px solid #1b4a2f;border-radius:10px;color:#f3f5f0;padding:10px">
              <span class="unit">XRP</span>
            </div>
          </div>
        </div>

        <div class="divider"></div>

        <div class="micro">Live prices</div>
        <div class="muted mono" aria-live="polite">
          <span id="liveDot">‚óè</span>
          <span> BAG $<span id="liveBAG">‚Äî</span> ¬∑ XRP $<span id="liveXRP">‚Äî</span> <span id="liveNote"></span></span>
          <div class="micro" id="liveConv" style="margin-top:4px;opacity:.9;">1 BAG ‚âà ‚Äî XRP ¬∑ 1 XRP ‚âà ‚Äî BAG</div>
          <div id="bagDiag" class="micro" style="opacity:.55;margin-top:4px;"></div>
        </div>

        <div class="divider"></div>

        <div class="micro">Game state</div>
        <div class="muted" id="stateText">Ready ‚Äî press Roll</div>

        <div class="callout mono">
          <div style="font-weight:700;margin-bottom:6px">Payouts</div>
          <div class="payout-grid" style="display:grid;gap:4px">
            <div class="row" style="display:flex;justify-content:space-between">
              <div class="lab"><strong>Scratch</strong> (0.00√ó):</div>
              <div class="val" id="payScratch">‚Äî</div>
            </div>
            <div class="row" style="display:flex;justify-content:space-between">
              <div class="lab"><strong>Win</strong> (1.25√ó):</div>
              <div class="val" id="payWin">‚Äî <span class="micro" id="payWinGain" style="opacity:.9"></span></div>
            </div>
            <div class="row" style="display:flex;justify-content:space-between">
              <div class="lab"><strong>Jackpot</strong> (2.00√ó):</div>
              <div class="val" id="payJackpot">‚Äî <span class="micro" id="payJackpotGain" style="opacity:.9"></span></div>
            </div>
          </div>
          <div class="micro" style="margin-top:6px;opacity:.85;">Min $1 ¬∑ Max $2,000. Bets shown in selected currency; $BAG amount and USD shown per live price.</div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="cele" class="cele" aria-live="polite"></div>

<!-- === AUDIO (shared across games; includes real THUD lose) === -->
<script>
(function(){
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let AC=null, MASTER=null, lastInteractTs=0, watchdog=null;

  function makeAC(){
    if(!AudioCtx) return null;
    const ac=new AudioCtx();
    const master=ac.createGain(); master.gain.value=0.28; master.connect(ac.destination);
    AC=ac; MASTER=master;
    ac.onstatechange=()=>{ if(ac.state==='suspended') tryResume(); };
    return ac;
  }
  function getAC(){ if(AC && AC.state!=='closed') return AC; return makeAC(); }
  async function tryResume(){ const ac=getAC(); if(!ac) return; if(ac.state==='suspended'){ try{await ac.resume();}catch{} } }
  async function ensureInteractive(){ const ac=getAC(); if(!ac) return null; if(ac.state!=='running') await tryResume(); return ac; }
  function markInteract(){ lastInteractTs=Date.now(); tryResume(); }

  function mkComp(ac){ const c=ac.createDynamicsCompressor(); c.threshold.value=-18; c.knee.value=22; c.ratio.value=3.8; c.attack.value=0.002; c.release.value=0.14; c.connect(MASTER); return c; }

  function playPeg(){
    const ac=getAC(); if(!ac || ac.state!=='running') return;
    const now=ac.currentTime, comp=mkComp(ac);
    const o=ac.createOscillator(), g=ac.createGain();
    o.type='triangle'; o.frequency.setValueAtTime(2300, now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(0.13, now+0.006);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.09);
    o.connect(g).connect(comp); o.start(now); o.stop(now+0.11);
  }

  function playWall(){
    const ac=getAC(); if(!ac || ac.state!=='running') return;
    const now=ac.currentTime, comp=mkComp(ac); const o=ac.createOscillator(), g=ac.createGain();
    o.type='square'; o.frequency.setValueAtTime(380, now); o.frequency.exponentialRampToValueAtTime(180, now+0.12);
    g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.09, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.14);
    o.connect(g).connect(comp); o.start(now); o.stop(now+0.16);
  }

  // üîä THUD lose (low kick + noise body) ‚Äî matches Slots/Plinko expected sound
  function playLose(){
    const ac=getAC(); if(!ac || ac.state!=='running') return;
    const now=ac.currentTime, comp=mkComp(ac);

    // Low sine "kick"
    const o=ac.createOscillator(), og=ac.createGain();
    o.type='sine'; o.frequency.setValueAtTime(220, now);
    o.frequency.exponentialRampToValueAtTime(70, now+0.22);
    og.gain.setValueAtTime(0.0001, now);
    og.gain.linearRampToValueAtTime(0.22, now+0.01);
    og.gain.exponentialRampToValueAtTime(0.0001, now+0.26);
    o.connect(og).connect(comp);
    o.start(now); o.stop(now+0.28);

    // Short noise "body"
    const nBuf=ac.createBuffer(1, Math.floor(ac.sampleRate*0.08), ac.sampleRate);
    const d=nBuf.getChannelData(0);
    for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*0.45*(1-i/d.length); }
    const nSrc=ac.createBufferSource(); nSrc.buffer=nBuf;
    const bp=ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=180; bp.Q.value=0.8;
    const ng=ac.createGain(); ng.gain.setValueAtTime(0.16, now); ng.gain.exponentialRampToValueAtTime(0.0001, now+0.12);
    nSrc.connect(bp).connect(ng).connect(comp); nSrc.start(now); nSrc.stop(now+0.13);
  }

  function playWin(jackpot=false){
    const ac=getAC(); if(!ac || ac.state!=='running') return;
    const now=ac.currentTime, comp=mkComp(ac);
    const notes = jackpot ? [880, 1175, 1568, 2093] : [660, 880, 1175];
    notes.forEach((f,i)=>{ const t=now+i*0.06; const o=ac.createOscillator(), g=ac.createGain();
      o.type='triangle'; o.frequency.setValueAtTime(f,t);
      g.gain.setValueAtTime(0.0001,t); g.gain.linearRampToValueAtTime(0.12,t+0.01); g.gain.exponentialRampToValueAtTime(0.0001,t+0.14);
      o.connect(g).connect(comp); o.start(t); o.stop(t+0.16);
    });
  }

  window.__bagAudio = {
    ensureInteractive,
    peg: playPeg,
    wall: playWall,
    win: (jp=false)=>playWin(!!jp),
    lose: playLose
  };

  if(!watchdog){ watchdog=setInterval(()=>{ const ac=AC; if(!ac) return; const active=Date.now()-lastInteractTs<30000; if(active && ac.state==='suspended') tryResume(); },1500); }
  ['pointerdown','mousedown','touchstart','keydown','click'].forEach(ev=>addEventListener(ev,markInteract,{passive:true,capture:true}));
})();
</script>

<!-- === PRICES (live-first AMM BAG/XRP; fallback caches) === -->
<script>
(function(){
  const PRICE_REFRESH_MS = 15000;
  const FETCH_TIMEOUT_MS = 8000;
  const LIVE_CACHE_TTL_MS = 24*60*60*1000;
  const VIEW_CACHE_TTL_MS = 6*60*60*1000;

  const XRPL_WSS = 'wss://s1.ripple.com';
  const BAG_ISSUER = 'rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr';
  const BAG_CODE = 'BAG';

  const PRICES = (window.__PRICES__ = { bagUsd:0, xrpUsd:0, source:'‚Äî', ts:0 });

  const liveDot = document.getElementById('liveDot');
  const liveBAG = document.getElementById('liveBAG');
  const liveXRP = document.getElementById('liveXRP');
  const liveNote = document.getElementById('liveNote');
  const liveConv = document.getElementById('liveConv');
  const diagSpan = document.getElementById('bagDiag');

  const VIEW_CACHE_KEY = 'bag_prices_v8';
  const LAST_LIVE_KEY  = 'bag_last_live_v1';
  const XRP_KEY        = 'xrp_usd';

  function fmt(n){ if (!Number.isFinite(n)) return '‚Äî'; return n.toLocaleString(undefined,{maximumFractionDigits:6}); }
  function cacheSet(k,v){ try{ localStorage.setItem(k, JSON.stringify({t:Date.now(), v})); }catch{} }
  function cacheGet(k, ttlMs){
    try{
      const o=JSON.parse(localStorage.getItem(k)||'null');
      if(!o) return null;
      const age = Date.now() - (o.t||0);
      return age<=ttlMs ? o.v : null;
    }catch{ return null; }
  }
  function timedFetch(url, opts={}, timeout=FETCH_TIMEOUT_MS){
    const ctrl = new AbortController(); const id = setTimeout(()=>ctrl.abort(new Error('timeout')), timeout);
    try{
      const u = new URL(url, location.origin);
      u.searchParams.set('_ts', Date.now().toString());
      return fetch(u.toString(), { ...opts, headers: { Accept:'application/json', ...(opts.headers||{}) }, mode:'cors', cache:'no-store', credentials:'omit', referrerPolicy:'no-referrer', signal: ctrl.signal });
    } finally { setTimeout(()=>clearTimeout(id),0); }
  }

  function updateLiveLine(){
    if (liveBAG)  liveBAG.textContent  = fmt(PRICES.bagUsd);
    if (liveXRP)  liveXRP.textContent  = fmt(PRICES.xrpUsd);
    if (liveDot)  liveDot.style.color  = (PRICES.source==='live-amm' ? '#2fbf6b' : PRICES.source==='last-live' ? '#e8a85c' : '#e25b5b');
    if (liveNote) liveNote.textContent = (PRICES.source==='live-amm' ? ' (AMM live)' : PRICES.source==='last-live' ? ' (last live)' : ' (unavailable)');
    if (liveConv){
      if(PRICES.bagUsd>0 && PRICES.xrpUsd>0){
        const xrpPerBag = PRICES.bagUsd/PRICES.xrpUsd;
        const bagPerXrp = PRICES.xrpUsd/PRICES.bagUsd;
        liveConv.textContent = `1 BAG ‚âà ${xrpPerBag.toLocaleString(undefined,{maximumFractionDigits:6})} XRP ¬∑ 1 XRP ‚âà ${bagPerXrp.toLocaleString(undefined,{maximumFractionDigits:6})} BAG`;
      } else liveConv.textContent = '1 BAG ‚âà ‚Äî XRP ¬∑ 1 XRP ‚âà ‚Äî BAG';
    }
    window.dispatchEvent(new CustomEvent('bag:pricesUpdated'));
  }

  async function fetchXrpUsdLive(){
    try{
      const r = await timedFetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
      if(!r.ok) throw 0;
      const v = (await r.json())?.ripple?.usd;
      if(Number(v)>0){
        PRICES.xrpUsd = Number(v);
        cacheSet(XRP_KEY, PRICES.xrpUsd);
        return true;
      }
    }catch(_){}
    return false;
  }
  function parseXrpAmount(a){ if (a==null) return null; if (typeof a==='string') return Number(a)/1_000_000; if (typeof a==='object' && a.currency==='XRP') return Number(a.value); return null; }
  function parseIouAmount(a){ if (!a || typeof a!=='object') return null; return Number(a.value); }
  async function fetchBagViaAMMLive(){
    const req = { id:1, command:'amm_info', asset:{currency:BAG_CODE,issuer:BAG_ISSUER}, asset2:{currency:'XRP'} };
    const xrpPerBag = await new Promise((resolve)=>{
      const ws = new WebSocket(XRPL_WSS);
      const t = setTimeout(()=>{ try{ws.close();}catch{}; resolve(null); }, 8000);
      ws.onopen = ()=> ws.send(JSON.stringify(req));
      ws.onerror = ()=>{ clearTimeout(t); try{ws.close();}catch{}; resolve(null); };
      ws.onmessage = (ev)=>{
        try{
          const msg = JSON.parse(ev.data);
          if (msg.id!==1 || !msg.result || !msg.result.amm) return;
          clearTimeout(t); try{ws.close();}catch{};
          const amm = msg.result.amm;
          const bagBal = parseIouAmount(amm.amount);
          const xrpBal = parseXrpAmount(amm.amount2);
          if (!(bagBal>0) || !(xrpBal>0)) return resolve(null);
          const price = xrpBal / bagBal;
          if (!(price>0) || !isFinite(price)) return resolve(null);
          const diag = document.getElementById('bagDiag');
          if (diag) diag.textContent = `AMM pool ¬∑ BAG=${bagBal.toLocaleString()} ¬∑ XRP=${xrpBal.toLocaleString(undefined,{maximumFractionDigits:6})} ¬∑ spot ${price.toLocaleString(undefined,{maximumFractionDigits:10})} XRP/BAG`;
          resolve(price);
        }catch{ resolve(null); }
      };
    });
    if (!(xrpPerBag>0)) return false;
    if (!(PRICES.xrpUsd>0)) return false;
    PRICES.bagUsd = PRICES.xrpUsd * xrpPerBag;
    PRICES.source = 'live-amm';
    cacheSet(LAST_LIVE_KEY, { bagUsd: PRICES.bagUsd, xrpUsd: PRICES.xrpUsd });
    cacheSet(VIEW_CACHE_KEY, { bagUsd: PRICES.bagUsd, xrpUsd: PRICES.xrpUsd });
    return true;
  }

  function loadLastLiveBundle(){
    const v = cacheGet(LAST_LIVE_KEY, LIVE_CACHE_TTL_MS);
    if (v && Number(v.bagUsd)>0){
      PRICES.bagUsd = Number(v.bagUsd);
      if (Number(v.xrpUsd)>0) PRICES.xrpUsd = Number(v.xrpUsd);
      PRICES.source = 'last-live';
      return true;
    }
    return false;
  }
  function loadViewCache(){
    const v = cacheGet(VIEW_CACHE_KEY, VIEW_CACHE_TTL_MS);
    const x = cacheGet(XRP_KEY, VIEW_CACHE_TTL_MS);
    let ok=false;
    if (v && Number(v.bagUsd)>0){ PRICES.bagUsd = Number(v.bagUsd); if (Number(v.xrpUsd)>0) PRICES.xrpUsd = Number(v.xrpUsd); ok=true; }
    if (!PRICES.xrpUsd && Number(x)>0){ PRICES.xrpUsd = Number(x); ok=true; }
    if (ok && PRICES.source==='‚Äî') PRICES.source='last-live';
    return ok;
  }

  async function refreshPrices(){
    const gotX = await fetchXrpUsdLive();
    const gotB = await fetchBagViaAMMLive();
    if (!(gotX && gotB)){
      if (!loadLastLiveBundle()) loadViewCache();
    }
    updateLiveLine();
  }

  (async ()=>{ await refreshPrices(); setInterval(refreshPrices, PRICE_REFRESH_MS); })();

  window.addEventListener('storage', (e)=>{
    if (e.key === 'bag_prices_v8' || e.key === 'xrp_usd' || e.key === 'bag_last_live_v1'){
      if (!loadLastLiveBundle()) loadViewCache();
      updateLiveLine();
    }
  });
})();
</script>

<!-- === PRICES/STAKE SYNC (USD ‚Üî stake, currency-aware) === -->
<script>
(function(){
  const MIN_USD = 1;
  const MAX_USD = 2000;

  const $ = (s)=>document.querySelector(s);
  const usdInput   = $('#usdBet');
  const betInput   = $('#demoBet');
  const unitSpan   = document.querySelector('.unit');
  const curWrap    = $('#curToggle');
  const stateText  = $('#stateText');

  let syncing = false;

  function selectedCur(){
    return curWrap?.querySelector('input[name="betCur"]:checked')?.value || 'XRP';
  }
  function priceFor(cur){
    const P = window.__PRICES__ || {};
    return cur==='BAG' ? (P.bagUsd||0) : (P.xrpUsd||0);
  }
  function clampUsd(v){
    if (!Number.isFinite(v)) return 0;
    return Math.min(MAX_USD, Math.max(0, v));
  }
  function refreshUnit(){ if (unitSpan) unitSpan.textContent = selectedCur(); }

  function updateUsdFromBet(){
    if (!usdInput || !betInput || syncing) return;
    const px  = priceFor(selectedCur());
    const qty = Math.max(0, parseFloat(betInput.value||'0'));
    const usd = px>0 ? qty*px : 0;
    syncing = true;
    usdInput.value = usd>0 ? usd.toFixed(2) : '';
    syncing = false;
  }
  function updateBetFromUsd(){
    if (!usdInput || !betInput || syncing) return;
    const px  = priceFor(selectedCur());
    let usd   = clampUsd(parseFloat(usdInput.value||'0'));
    if (!Number.isFinite(usd) || usd<=0 || px<=0){ syncing = true; betInput.value = betInput.value; syncing = false; return; }
    const units = Math.floor(usd / px * 1e6)/1e6;
    syncing = true; betInput.value = String(Math.max(0, units)); syncing = false;
  }

  // Public helper
  function stakeUsdEquivalent(){
    const qty = Math.max(0, parseFloat(betInput?.value||0));
    const px  = priceFor(selectedCur());
    return px>0 ? qty*px : 0;
  }
  window.stakeUsdEquivalent = window.stakeUsdEquivalent || stakeUsdEquivalent;

  usdInput?.addEventListener('input', updateBetFromUsd);
  betInput?.addEventListener('input', updateUsdFromBet);
  curWrap?.addEventListener('change', ()=>{ refreshUnit(); updateUsdFromBet(); });

  window.addEventListener('bag:pricesUpdated', ()=>{
    const P = window.__PRICES__;
    if (stateText && P) {
      stateText.textContent = (P.source === 'live-amm') ? 'Live pricing ready' :
                              (P.bagUsd>0 ? 'Using cached pricing' : 'Waiting for pricing‚Ä¶');
    }
    updateUsdFromBet(); refreshUnit();
  });

  refreshUnit(); updateUsdFromBet();
})();
</script>

<!-- === Payout preview (auto-updates with stake / prices) === -->
<script>
(function(){
  const payScratch = document.getElementById('payScratch');
  const payWin = document.getElementById('payWin');
  const payWinGain = document.getElementById('payWinGain');
  const payJackpot = document.getElementById('payJackpot');
  const payJackpotGain = document.getElementById('payJackpotGain');

  function selectedCur(){
    const r = document.querySelector('#curToggle input[name="betCur"]:checked');
    return r ? r.value.toUpperCase() : 'XRP';
  }
  function PR(){ return window.__PRICES__ || { bagUsd:0, xrpUsd:0 }; }
  function fmt(n,max=6){ return Number.isFinite(n)? n.toLocaleString(undefined,{maximumFractionDigits:max}) : '‚Äî'; }
  function usd(n){ return '$'+(Number(n)||0).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}); }

  function stakeUnits(){
    const v = parseFloat(document.getElementById('demoBet')?.value||'');
    return Number.isFinite(v)&&v>0 ? v : 0;
  }
  function stakeBag(){
    const {bagUsd,xrpUsd} = PR();
    const q = stakeUnits();
    return (selectedCur()==='BAG') ? q : (bagUsd>0 && xrpUsd>0 ? q * (xrpUsd/bagUsd) : 0);
  }
  function stakeUsd(){
    const {bagUsd,xrpUsd} = PR();
    const q = stakeUnits();
    const px = (selectedCur()==='BAG') ? bagUsd : xrpUsd;
    return (px>0 ? q*px : 0);
  }

  function render(){
    const sBag = stakeBag()||0;
    const sUsd = stakeUsd()||0;
    const mWin = 1.25, mJack = 2.00;

    if (payScratch)      payScratch.textContent = `${fmt(0)} BAG (${usd(0)})`;
    if (payWin){
      const base = `${fmt(sBag*mWin)} BAG (${usd(sUsd*mWin)})`;
      if (payWin.firstChild) payWin.firstChild.nodeValue = base;
      else payWin.textContent = base;
      if (payWinGain) payWinGain.textContent = ` (+${fmt(sBag*(mWin-1))} BAG)`;
    }
    if (payJackpot){
      const base = `${fmt(sBag*mJack)} BAG (${usd(sUsd*mJack)})`;
      if (payJackpot.firstChild) payJackpot.firstChild.nodeValue = base;
      else payJackpot.textContent = base;
      if (payJackpotGain) payJackpotGain.textContent = ` (+${fmt(sBag*(mJack-1))} BAG)`;
    }
  }

  document.getElementById('demoBet')?.addEventListener('input', render);
  document.getElementById('curToggle')?.addEventListener('change', render);
  window.addEventListener('bag:pricesUpdated', render);
  render();
})();
</script>

<!-- === DICE GAME LOGIC (stable; pre-HUD) === -->
<script>
(function(){
  const die1 = document.getElementById('die1');
  const die2 = document.getElementById('die2');
  const resText = document.getElementById('resText');
  const rollBtn = document.getElementById('rollBtn');
  const stateText = document.getElementById('stateText');
  const celeEl = document.getElementById('cele');

  // Odds: keep consistent across all games:
  // LIVE: 42% win (1.25√ó), 2% jackpot (2√ó)
  // DEMO: 46% win (1.25√ó), 3% jackpot (2√ó)
  const WEIGHTS_LIVE = { L:56, W:42, J:2 };
  const WEIGHTS_DEMO = { L:51, W:46, J:3 };

  function isDemo(){ return window.__BAG_FORCE_DEMO === true; }
  function weights(){ return isDemo() ? WEIGHTS_DEMO : WEIGHTS_LIVE; }

  function pickOutcome(){
    const w = weights();
    const total = w.L + w.W + w.J;
    let r = Math.random()*total;
    if ((r -= w.J) <= 0) return 'J'; // jackpot
    if ((r -= w.W) <= 0) return 'W'; // win
    return 'L'; // lose
  }

  function rollFace(){ return 1 + Math.floor(Math.random()*6); }

  function setDice(a,b){ if(die1) die1.textContent=a; if(die2) die2.textContent=b; }
  function setRolling(on){ [die1,die2].forEach(d=>{ if(!d) return; d.classList.toggle('rolling', !!on); }); }

  function showToast(msg, color){
    if(!celeEl) return;
    celeEl.textContent = msg;
    celeEl.style.color = color || '#c7f7df';
    celeEl.classList.remove('show'); void celeEl.offsetWidth; // restart animation
    celeEl.classList.add('show');
    setTimeout(()=>celeEl.classList.remove('show'), 900);
  }

  function selectedCur(){ return document.querySelector('#curToggle input[name="betCur"]:checked')?.value || 'XRP'; }
  function stakeUnits(){ const v=parseFloat(document.getElementById('demoBet')?.value||''); return Number.isFinite(v)&&v>0 ? v : 0; }
  function PR(){ return window.__PRICES__ || { bagUsd:0, xrpUsd:0 }; }
  function stakeBag(){
    const {bagUsd,xrpUsd} = PR();
    const q = stakeUnits();
    return (selectedCur()==='BAG') ? q : (bagUsd>0 && xrpUsd>0 ? q * (xrpUsd/bagUsd) : 0);
  }

  function stakeUsdEquivalent(){
    const {bagUsd,xrpUsd} = PR();
    const q = stakeUnits();
    const px = (selectedCur()==='BAG') ? bagUsd : xrpUsd;
    return px>0 ? q*px : 0;
  }

  rollBtn?.addEventListener('click', async ()=>{
    try{ await window.__bagAudio?.ensureInteractive?.(); }catch{}
    if (stateText) stateText.textContent='Rolling‚Ä¶';
    if (resText) resText.textContent='‚Äî';

    // Min $1 gate
    const usd = stakeUsdEquivalent();
    const passesMin = usd > 0 ? usd >= 1 : (stakeUnits() >= 1);
    if (!passesMin){ if(resText) resText.textContent='Min $1'; return; }

    setRolling(true);
    let ticks = 12, t = 0;
    const anim = setInterval(()=>{
      setDice(rollFace(), rollFace());
      if (++t >= ticks){ clearInterval(anim); conclude(); }
    }, 60);

    function conclude(){
      setRolling(false);
      const outcome = pickOutcome();

      if (outcome === 'L'){
        if (resText) resText.textContent = 'Scratch (lose)';
        window.__bagAudio?.lose?.();
        if (stateText) stateText.textContent='Resolved';
        showToast('Scratch', '#eabcd0');
        return;
      }

      const sBag = stakeBag();
      if (outcome === 'J'){
        if (resText) resText.textContent = 'üéâ Jackpot 2√ó';
        window.__bagAudio?.win?.(true);
        showToast('JACKPOT!', '#ffe28c');
        if (stateText) stateText.textContent='Resolved';
      } else {
        if (resText) resText.textContent = 'Win 1.25√ó';
        window.__bagAudio?.win?.(false);
        showToast('WIN', '#baf2cd');
        if (stateText) stateText.textContent='Resolved';
      }
    }
  });
})();
</script>

<!-- === Practice Mode Switch (simple; always on for this stable build) === -->
<script>
(function(){
  // Keep practice mode on for this reset build.
  window.__BAG_FORCE_DEMO = true;
})();
</script>

<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js').catch(()=>{});
}
</script>
</body>
</html>
