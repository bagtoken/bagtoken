<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>BAG Dice â€” Clean Dice, Real Tumble</title>

<!-- Three.js (robust loader) -->
<script>
(function(){
  function load(src, ok, fail){
    var s=document.createElement('script'); s.src=src; s.async=true;
    s.onload=ok; s.onerror=fail; document.head.appendChild(s);
  }
  load('https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js',
    ()=>window.__THREE_READY__=true,
    ()=>load('https://unpkg.com/three@0.158.0/build/three.min.js',
      ()=>window.__THREE_READY__=true,
      ()=>window.__THREE_FAILED__=true
    )
  );
})();
</script>

<style>
  :root{
    --bg:#060b08; --felt:#0a1c13; --felt2:#0f2a1c; --line:#173524;
    --fg:#f5f7f4; --muted:#aeb7af; --good:#2fbf6b; --warn:#e8a85c; --bad:#e25b5b;
    --gold1:#ffe175; --gold2:#f5c94c;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  h1,h2,h3{margin:0 0 8px}
  .wrap{max-width:1100px;margin:0 auto;padding:22px 14px 40px}
  .hero{display:flex;align-items:end;gap:10px;justify-content:center;margin:14px 0 10px}
  .hero h1{font-size:clamp(1.2rem,3.2vw,1.6rem);opacity:.95}
  .table{background:linear-gradient(180deg,var(--felt),var(--felt2));border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 10px 32px rgba(0,0,0,.25)}
  .stage{height:300px;border:1px solid #214a31;border-radius:12px;overflow:hidden;background:radial-gradient(120% 100% at 50% 10%, #123425 0%, #091a13 70%)}
  .stage canvas{display:block;width:100%;height:100%}
  .row{display:flex;gap:14px;align-items:stretch;flex-wrap:wrap;margin-top:10px}
  .col{flex:1;min-width:260px}
  .btn{
    width:min(360px,95%);padding:14px 18px;border:0;border-radius:12px;font-weight:900;letter-spacing:.4px;
    color:#0a130e;background:linear-gradient(180deg,var(--gold1),var(--gold2));box-shadow:0 6px 0 #b08a19,0 14px 30px rgba(255,225,117,.18);cursor:pointer
  }
  .btn:active{transform:translateY(2px);box-shadow:0 4px 0 #9a7315,0 10px 24px rgba(255,225,117,.22)}
  .status{
    margin-top:10px;padding:10px 12px;border:1px solid #234e35;border-radius:12px;background:#0c2318;
    display:grid;gap:6px
  }
  .status .line{display:flex;justify-content:space-between;gap:10px;font-variant-numeric:tabular-nums}
  .status .note{font-size:.9rem;color:#cfe0d6}
  .ok{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}

  /* CSS fallback (minimal) */
  .css-dice{position:absolute;inset:0;display:none;place-items:center;gap:64px}
  .cube{position:relative;width:110px;height:110px;transform-style:preserve-3d;transition:transform .8s cubic-bezier(.2,.9,.2,1)}
  .face{position:absolute;inset:0;background:#f3f2ee;border-radius:20px;box-shadow:inset 0 0 0 2px #d9d7d2}
  .f1{transform:translateZ(55px)} .f6{transform:rotateX(180deg) translateZ(55px)}
  .f3{transform:rotateY(90deg) translateZ(55px)} .f4{transform:rotateY(-90deg) translateZ(55px)}
  .f2{transform:rotateX(-90deg) translateZ(55px)} .f5{transform:rotateX(90deg) translateZ(55px)}
  .css-dice.active{display:grid}
</style>
</head>
<body>
  <div class="wrap">
    <div class="hero">
      <h1>ðŸŽ² $BAG Dice â€” Pass Line</h1>
    </div>

    <div class="table">
      <div id="stage" class="stage" aria-label="3D dice area">
        <div id="cssFallback" class="css-dice"></div>
      </div>

      <div class="row" style="justify-content:center">
        <button id="rollBtn" class="btn">ROLL</button>
      </div>

      <div id="status" class="status" role="status" aria-live="polite">
        <div class="line"><span>Phase</span><strong id="phase">Come-out</strong></div>
        <div class="line"><span>Last roll</span><strong id="lastRoll">â€”</strong></div>
        <div class="line"><span>Point</span><strong id="pointVal">â€”</strong></div>
        <div id="cta" class="note">Need <b>7 or 11</b> to <span class="ok">WIN</span>. <b>2/3/12</b> is <span class="bad">CRAPS</span>. Any other sets the <b>Point</b>.</div>
      </div>
    </div>
  </div>

<!-- SOUND (safe) -->
<script>
(function(){
  const shake = new Audio('/assets/sounds/diceshake.mp3'), roll = new Audio('/assets/sounds/diceroll.mp3');
  [shake,roll].forEach(a=>{ a.preload='auto'; a.crossOrigin='anonymous'; a.setAttribute('playsinline',''); a.volume=.95; });
  let primed=false; function prime(){ if(primed) return; primed=true; try{ shake.muted=true; shake.play().then(()=>{shake.pause();shake.currentTime=0;shake.muted=false;}).catch(()=>{});}catch{} }
  addEventListener('pointerdown', prime, {once:true, passive:true});
  window.SFX = {
    async shake(){ try{ const a=shake.cloneNode(); a.volume=shake.volume; await a.play().catch(()=>{});}catch{} },
    async roll(){ try{ const a=roll.cloneNode(); a.volume=roll.volume; await a.play().catch(()=>{});}catch{} }
  };
})();
</script>

<!-- GAME + DICE -->
<script>
(function(){
  const stageEl = document.getElementById('stage');
  const cssWrap = document.getElementById('cssFallback');
  const rollBtn = document.getElementById('rollBtn');

  const phaseEl = document.getElementById('phase');
  const lastEl  = document.getElementById('lastRoll');
  const pointEl = document.getElementById('pointVal');
  const ctaEl   = document.getElementById('cta');

  const ROUND = { active:false, point:null };
  function resetComeOutUI(){
    phaseEl.textContent='Come-out';
    pointEl.textContent='â€”';
    ctaEl.innerHTML='Need <b>7 or 11</b> to <span class="ok">WIN</span>. <b>2/3/12</b> is <span class="bad">CRAPS</span>. Any other sets the <b>Point</b>.';
  }
  function setPointUI(p){
    ROUND.active=true; ROUND.point=p;
    phaseEl.textContent='Point';
    pointEl.textContent=String(p);
    ctaEl.innerHTML=`Point is <b>${p}</b> â€” Roll <b>${p}</b> to <span class="ok">WIN</span> before <b>7</b> (<span class="bad">SEVEN OUT</span>).`;
  }
  function winUI(msg){ ctaEl.innerHTML=`<span class="ok">WIN</span> â€” ${msg}`; }
  function loseUI(msg){ ctaEl.innerHTML=`<span class="bad">LOSE</span> â€” ${msg}`; }
  resetComeOutUI();

  /* -------------------- THREE: brand-new physical dice -------------------- */
  function bootThree(){
    const THREE = window.THREE;
    const w = stageEl.clientWidth, h = stageEl.clientHeight;
    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(35, w/h, 0.1, 100);
    camera.position.set(0.8, 1.7, 6.2); camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio||1, 2));
    renderer.setSize(w,h);
    renderer.shadowMap.enabled=true; renderer.shadowMap.type=THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.06;
    stageEl.innerHTML=''; stageEl.appendChild(renderer.domElement);

    addEventListener('resize', ()=>{
      const W = stageEl.clientWidth, H = stageEl.clientHeight;
      camera.aspect = W/H; camera.updateProjectionMatrix();
      renderer.setSize(W,H);
    });

    // Table felt
    const felt = new THREE.Mesh(
      new THREE.CylinderGeometry(3.8,3.8,0.02,64),
      new THREE.MeshStandardMaterial({color:0x0e2419, roughness:.92})
    );
    felt.rotation.x = -Math.PI/2; felt.position.y = -1.06; felt.receiveShadow = true;
    scene.add(felt);

    // Lights: punchy, cinematic
    const key = new THREE.DirectionalLight(0xffffff,1.15); key.position.set(3.5,5.8,4.2); key.castShadow=true;
    key.shadow.mapSize.set(1024,1024); key.shadow.radius=3;
    key.shadow.camera.near=1; key.shadow.camera.far=20;
    key.shadow.camera.left=-7; key.shadow.camera.right=7; key.shadow.camera.top=7; key.shadow.camera.bottom=-7;
    const fill = new THREE.DirectionalLight(0xffffff,.46); fill.position.set(-4.2,3,2);
    const rim  = new THREE.DirectionalLight(0xffffff,.28); rim.position.set(0,6.5,-5.5);
    const amb  = new THREE.AmbientLight(0xcfd7e2,.34);
    scene.add(key,fill,rim,amb);

    // Rounded cube generator (clean chamfer)
    function RoundedBox(w,h,d,r=0.19, seg=4){
      const g=new THREE.BoxGeometry(w,h,d,seg,seg,seg);
      const pos=g.attributes.position, hx=w/2,hy=h/2,hz=d/2, rx=Math.min(r,hx),ry=Math.min(r,hy),rz=Math.min(r,hz);
      for(let i=0;i<pos.count;i++){
        const x=pos.getX(i), y=pos.getY(i), z=pos.getZ(i);
        const ix=Math.max(-hx+rx,Math.min(hx-rx,x));
        const iy=Math.max(-hy+ry,Math.min(hy-ry,y));
        const iz=Math.max(-hz+rz,Math.min(hz-rz,z));
        const dx=x-ix, dy=y-iy, dz=z-iz, len=Math.hypot(dx,dy,dz);
        if(len>1e-6) pos.setXYZ(i, ix+dx/len*rx, iy+dy/len*ry, iz+dz/len*rz);
      }
      pos.needsUpdate=true; g.computeVertexNormals(); return g;
    }

    // Materials: pearl body + matte inlaid pips + micro inked edge
    const bodyMat = new THREE.MeshPhysicalMaterial({
      color:0xf3efe8, roughness:.38, metalness:0.02,
      sheen:1.0, sheenColor:new THREE.Color(0xffffff), sheenRoughness:.6,
      clearcoat:.7, clearcoatRoughness:.25, iridescence:.1, iridescenceIOR:1.2, iridescenceThicknessRange:[100,300],
      envMapIntensity:1.0
    });
    const pipMat  = new THREE.MeshPhysicalMaterial({
      color:0x0b0b0b, roughness:.6, metalness:.05, clearcoat:.2, clearcoatRoughness:.45
    });
    const edgeMat = new THREE.MeshStandardMaterial({ color:0xd9d7d2, roughness:.7, metalness:0 });

    function makeDie(size=1.08){
      const g = new THREE.Group();

      // Body
      const body = new THREE.Mesh(RoundedBox(size,size,size,0.19,4), bodyMat);
      body.castShadow = true; body.receiveShadow = false;
      g.add(body);

      // Thin â€œinkedâ€ edge card (subtle outline look)
      const ink = new THREE.Mesh(new THREE.BoxGeometry(size*0.998,size*0.998,size*0.998), edgeMat);
      ink.scale.set(1.002,1.002,1.002);
      g.add(ink);

      // Inlaid pips â€” real geometry (cylinders) slightly embedded
      const pipR = size*0.08, pipH = size*0.14, inset = size*0.52; // push into face
      const pipGeom = new THREE.CylinderGeometry(pipR, pipR, pipH, 32);
      const mkPip = (x,y,z, rx=0,ry=0,rz=0)=>{
        const p = new THREE.Mesh(pipGeom, pipMat);
        p.rotation.set(rx,ry,rz);
        p.position.set(x,y,z);
        p.castShadow=true; p.receiveShadow=false;
        g.add(p);
      };

      // Grid offsets on a face
      const m = size*0.28, c = 0; // center
      const positions = {
        1:[[c,c]],
        2:[[-m,-m],[m,m]],
        3:[[-m,-m],[c,c],[m,m]],
        4:[[-m,-m],[m,-m],[-m,m],[m,m]],
        5:[[-m,-m],[m,-m],[c,c],[-m,m],[m,m]],
        6:[[-m,-m],[m,-m],[-m,c],[m,c],[-m,m],[m,m]],
      };

      // Face mapping (matches craps die standard; opposite sum = 7)
      // +X=3, -X=4, +Y=1 (top), -Y=6 (bottom), +Z=2 (front), -Z=5 (back)
      function addFace(face, normal){
        const [nx,ny,nz] = normal;
        const rx = ny!==0 ? 0 : (nz!==0 ? Math.PI/2 : 0);
        const ry = nx!==0 ? 0 : (nz!==0 ? 0 : (nx===0 && nz===0 ? 0 : 0));
        const rz = 0;
        const rot = new THREE.Euler(
          nz!==0 ? 0 : (ny>0?0: (ny<0?Math.PI:0)),
          nz!==0 ? 0 : (nx>0?-Math.PI/2: (nx<0?Math.PI/2:0)),
          nz>0?0:(nz<0?Math.PI:0)
        ); // we'll override per-axis below for correctness

        // orientation per axis so pips read correctly:
        let orient = new THREE.Quaternion();
        if(nx>0){ orient.setFromEuler(new THREE.Euler(0, Math.PI/2, 0)); }        // +X
        if(nx<0){ orient.setFromEuler(new THREE.Euler(0,-Math.PI/2, 0)); }        // -X
        if(ny>0){ orient.setFromEuler(new THREE.Euler(-Math.PI/2,0,0)); }         // +Y (top)
        if(ny<0){ orient.setFromEuler(new THREE.Euler( Math.PI/2,0,0)); }         // -Y (bottom)
        if(nz>0){ orient.setFromEuler(new THREE.Euler(0,0,0)); }                  // +Z (front)
        if(nz<0){ orient.setFromEuler(new THREE.Euler(0,Math.PI,0)); }            // -Z (back)

        const arr = positions[face];
        arr.forEach(([u,v])=>{
          // local face coordinates
          const local = new THREE.Vector3(u, v, 0);
          local.applyQuaternion(orient);
          // place on face plane with slight inset along normal
          const pos = new THREE.Vector3(
            local.x + nx*inset,
            local.y + ny*inset,
            local.z + nz*inset
          );
          const pip = new THREE.Mesh(pipGeom, pipMat);
          // rotate cylinder so its axis points along the normal
          if(nx!==0){ pip.rotation.z = Math.PI/2; }
          if(ny!==0){ pip.rotation.x = 0; pip.rotation.z = 0; }
          if(nz!==0){ pip.rotation.x = Math.PI/2; }
          pip.position.copy(pos);
          pip.castShadow = true;
          g.add(pip);
        });
      }

      // Build all faces
      addFace(3,[+1,0,0]);
      addFace(4,[-1,0,0]);
      addFace(1,[0,+1,0]);
      addFace(6,[0,-1,0]);
      addFace(2,[0,0,+1]);
      addFace(5,[0,0,-1]);

      // Helper: pose to show specific top face with optional yaw
      g.__setTop = function(value, yaw=0){
        const m={
          1:[0,yaw,0], 2:[-Math.PI/2,yaw,0], 3:[0,yaw+Math.PI/2,0],
          4:[0,yaw-Math.PI/2,0], 5:[Math.PI/2,yaw,0], 6:[Math.PI,yaw,0],
        }[value]||[0,yaw,0];
        g.rotation.set(m[0],m[1],m[2]);
      };
      return g;
    }

    const stage = new THREE.Group(); scene.add(stage);
    const A = makeDie(1.08), B = makeDie(1.08);
    stage.add(A,B);

    function centerPose(){
      A.position.set(-0.95, 0.28, 0.0);
      B.position.set( 0.95, 0.28,  0.0);
    }
    centerPose();

    // Render loop
    (function loop(){ renderer.render(scene,camera); requestAnimationFrame(loop); })();

    // Tiny camera/scene shake on impact
    async function impact(ms=140, px=0.055){
      const t0=performance.now(); const ox=stage.position.x, oy=stage.position.y;
      await new Promise(res=>{
        (function step(t){
          const p=Math.min(1,(t-t0)/ms), k=(1-p);
          stage.position.x = ox + (Math.random()*2-1)*px*k;
          stage.position.y = oy + (Math.random()*2-1)*px*k*0.6;
          if(p<1) requestAnimationFrame(step); else{ stage.position.set(ox,oy,0); res(); }
        })(t0);
      });
    }

    // Throw: heavier spin, clean settle
    async function throwTo(a,b, totalMs=1250){
      const endY=0.28, startXA=-2.6, startXB= 2.6, startY=0.75;
      A.position.set(startXA,startY,0); B.position.set(startXB,startY,0);
      A.rotation.set(Math.random()*6,Math.random()*6,Math.random()*6);
      B.rotation.set(Math.random()*6,Math.random()*6,Math.random()*6);

      const yawA=(Math.random()*Math.PI*2-Math.PI), yawB=(Math.random()*Math.PI*2-Math.PI);
      const sA=36+Math.random()*8, sB=35+Math.random()*8;

      const t0=performance.now();
      await new Promise(res=>{
        function step(t){
          const raw=Math.min(1,(t-t0)/totalMs);
          const pAir=Math.min(1, raw/0.78), pDrop=Math.max(0,(raw-0.78)/0.22);
          const ease=(x)=>1-Math.pow(1-x,3);

          const xA=startXA+(-0.95-startXA)*ease(pAir);
          const xB=startXB+( 0.95-startXB)*ease(pAir);
          const arc = 0.66*(1 - (2*pAir-1)**2);
          const y=endY+arc+0.12;
          A.position.set(xA,y,0); B.position.set(xB,y,0);

          const dt=0.016;
          A.rotation.x+=1.18*sA*dt; A.rotation.y+=1.42*sA*dt; A.rotation.z+=0.82*sA*dt;
          B.rotation.x+=1.05*sB*dt; B.rotation.y+=1.30*sB*dt; B.rotation.z+=0.74*sB*dt;

          if(pDrop>0){
            const k=ease(pDrop);
            const toA={1:[0,yawA,0],2:[-Math.PI/2,yawA,0],3:[0,yawA+Math.PI/2,0],4:[0,yawA-Math.PI/2,0],5:[Math.PI/2,yawA,0],6:[Math.PI,yawA,0]}[a];
            const toB={1:[0,yawB,0],2:[-Math.PI/2,yawB,0],3:[0,yawB+Math.PI/2,0],4:[0,yawB-Math.PI/2,0],5:[Math.PI/2,yawB,0],6:[Math.PI,yawB,0]}[b];
            A.rotation.set(A.rotation.x+(toA[0]-A.rotation.x)*k, A.rotation.y+(toA[1]-A.rotation.y)*k, A.rotation.z+(toA[2]-A.rotation.z)*k);
            B.rotation.set(B.rotation.x+(toB[0]-B.rotation.x)*k, B.rotation.y+(toB[1]-B.rotation.y)*k, B.rotation.z+(toB[2]-B.rotation.z)*k);
          }
          if(raw<1) requestAnimationFrame(step); else res();
        }
        requestAnimationFrame(step);
      });

      A.__setTop(a,yawA); B.__setTop(b,yawB);
      A.position.y=B.position.y=endY;

      await impact(140,0.06);

      const wob0=performance.now();
      await new Promise(res=>{
        (function wob(ts){
          const t=(ts-wob0)/320; const k=Math.max(0,1-t);
          if(k<=0) return res();
          const w=0.06*k*Math.sin(ts*0.06);
          A.rotation.x+=w*0.02; B.rotation.y-=w*0.02;
          requestAnimationFrame(wob);
        })(wob0);
      });
    }

    // Public roll impl
    window.__rollDiceImpl = async function(a,b){
      await window.SFX?.shake();
      window.SFX?.roll();
      await throwTo(a,b,1250);
    };

    // Default idle pose
    A.__setTop(3, 0.2); B.__setTop(4, -0.3);
  }

  /* -------------------- CSS fallback (basic) -------------------- */
  function bootCSS(){
    cssWrap.innerHTML=''; cssWrap.classList.add('active');
    function makeCube(){
      const c=document.createElement('div'); c.className='cube';
      ['f1','f2','f3','f4','f5','f6'].forEach(cls=>{
        const d=document.createElement('div'); d.className='face '+cls; c.appendChild(d);
      });
      cssWrap.appendChild(c); return c;
    }
    const A=makeCube(), B=makeCube();

    function setTop(el, val, yaw=0){
      const map={
        1:`rotateX(0rad) rotateY(${yaw}rad)`,
        2:`rotateX(-1.5708rad) rotateY(${yaw}rad)`,
        3:`rotateY(${yaw+1.5708}rad)`,
        4:`rotateY(${yaw-1.5708}rad)`,
        5:`rotateX(1.5708rad) rotateY(${yaw}rad)`,
        6:`rotateX(3.1416rad) rotateY(${yaw}rad)`,
      }[val]||`rotateX(0rad) rotateY(${yaw}rad)`;
      el.style.transform = map;
    }

    window.__rollDiceImpl = async function(a,b){
      A.style.transition=B.style.transition='transform .8s cubic-bezier(.2,.9,.2,1)';
      A.style.transform=`rotateX(${Math.random()*8}rad) rotateY(${Math.random()*8}rad)`;
      B.style.transform=`rotateX(${Math.random()*8}rad) rotateY(${Math.random()*8}rad)`;
      await new Promise(r=>setTimeout(r, 560));
      setTop(A,a, Math.random()*6-3);
      setTop(B,b, Math.random()*6-3);
      await new Promise(r=>setTimeout(r, 220));
    };
  }

  // Boot
  (function boot(){
    let tries=0;
    function tick(){
      if (window.__THREE_READY__ && window.THREE){ bootThree(); wireRoll(); }
      else if (window.__THREE_FAILED__ || tries>30){ bootCSS(); wireRoll(); }
      else { tries++; setTimeout(tick, 100); }
    }
    tick();
  })();

  /* -------------------- Game rules + UI -------------------- */
  function isComeOut(){ return !ROUND.active || ROUND.point==null; }

  function setStatus(rollA, rollB, extra){
    const sum = rollA+rollB;
    lastEl.textContent = `${rollA} + ${rollB} = ${sum}` + (extra?`  Â·  ${extra}`:'');
  }

  function wireRoll(){
    rollBtn.addEventListener('click', async ()=>{
      if (!window.__rollDiceImpl) return;
      rollBtn.disabled=true;

      const a = 1 + (Math.random()*6|0);
      const b = 1 + (Math.random()*6|0);
      const sum = a + b;

      await window.__rollDiceImpl(a,b);

      if (isComeOut()){
        if (sum===7 || sum===11){
          setStatus(a,b,'Come-out WIN (1.25Ã—)');
          winUI('Come-out 7/11');
          ROUND.active=false; ROUND.point=null; resetComeOutUI();
        } else if (sum===2 || sum===3 || sum===12){
          setStatus(a,b,'CRAPS');
          loseUI('CRAPS on come-out');
          ROUND.active=false; ROUND.point=null; resetComeOutUI();
        } else {
          setStatus(a,b,'Point set');
          setPointUI(sum);
        }
      } else {
        if (sum===ROUND.point){
          setStatus(a,b,'POINT MADE (1.00Ã—)');
          winUI(`Point ${ROUND.point} made`);
          ROUND.active=false; ROUND.point=null; resetComeOutUI();
        } else if (sum===7){
          setStatus(a,b,'SEVEN OUT');
          loseUI('Seven out');
          ROUND.active=false; ROUND.point=null; resetComeOutUI();
        } else {
          setStatus(a,b,'Neutral â€” roll again');
        }
      }

      rollBtn.disabled=false;
    });
  }
})();
</script>
</body>
</html>
