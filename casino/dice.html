<!-- AUDIO ENGINE -->
<script>
(function(){
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let AC = null, MASTER = null, lastInteractTs = 0, watchdogTimer = null;

  // Dice MP3 source and preloaded element
  const DICE_SRC = '/assets/rolling_dice.mp3';
  let dicePrimed = false;
  const baseDiceEl = new Audio(DICE_SRC);
  baseDiceEl.preload = 'auto';
  baseDiceEl.crossOrigin = 'anonymous';
  baseDiceEl.setAttribute('playsinline','');
  baseDiceEl.volume = 0.9;

  function makeAC(){
    if(!AudioCtx) return null;
    const ac = new AudioCtx();
    const master = ac.createGain();
    master.gain.value = 0.22;
    master.connect(ac.destination);
    AC = ac; MASTER = master;
    ac.onstatechange = function(){ if(ac.state==='suspended') tryResume(); };
    return ac;
  }
  function getAC(){ if(AC && AC.state!=='closed') return AC; return makeAC(); }
  function silentTick(ac){
    const o=ac.createOscillator(); const g=ac.createGain();
    g.gain.value=0.00001; o.connect(g).connect(MASTER);
    o.start(); o.stop(ac.currentTime+0.01);
  }
  async function tryResume(){
    const ac=getAC(); if(!ac) return;
    if(ac.state==='suspended'){ try{ await ac.resume(); }catch(e){} }
    if(ac.state==='running'){ silentTick(ac); }
  }
  function markInteract(){ lastInteractTs=Date.now(); tryResume(); primeDiceOnce(); }
  async function ensureInteractive(){ const ac=getAC(); if(!ac) return null; if(ac.state!=='running'){ await tryResume(); } return ac; }

  // One-time prime to satisfy mobile autoplay rules
  function primeDiceOnce(){
    if(dicePrimed) return;
    try{
      baseDiceEl.muted = true;
      baseDiceEl.currentTime = 0;
      const p = baseDiceEl.play();
      if(p && p.then){
        p.then(()=>{ baseDiceEl.pause(); baseDiceEl.muted = false; dicePrimed = true; })
         .catch(()=>{ /* ignored until next interaction */ });
      }else{
        // If play doesn't return a promise on older browsers
        baseDiceEl.pause(); baseDiceEl.muted = false; dicePrimed = true;
      }
    }catch(e){ /* try again on next interaction */ }
  }

  // Simple noise helper still used by nudge/chime effects
  function makeNoise(ac,dur=0.08){
    const len=Math.max(1,Math.floor(dur*ac.sampleRate));
    const buf=ac.createBuffer(1,len,ac.sampleRate);
    const data=buf.getChannelData(0);
    for(let i=0;i<len;i++) data[i]=(Math.random()*2-1)*0.9;
    const src=ac.createBufferSource(); src.buffer=buf;
    const bp=ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1200; bp.Q.value=2.0;
    const g=ac.createGain(); g.gain.value=0;
    src.connect(bp).connect(g);
    return {src,g};
  }

  function chime(){
    const ac=getAC(); if(!ac) return; if(ac.state!=='running'){ tryResume(); return; }
    const now=ac.currentTime; const notes=[880,1175,1760];
    notes.forEach((f,i)=>{
      const o=ac.createOscillator(); const g=ac.createGain();
      o.type='triangle'; o.frequency.value=f;
      g.gain.setValueAtTime(0.0001,now+i*0.02);
      g.gain.linearRampToValueAtTime(0.18,now+i*0.02+0.03);
      g.gain.exponentialRampToValueAtTime(0.0001,now+i*0.02+0.28);
      o.connect(g).connect(MASTER);
      o.start(now+i*0.02); o.stop(now+i*0.02+0.3);
    });
  }

  function nudge(){
    const ac=getAC(); if(!ac) return; if(ac.state!=='running'){ tryResume(); return; }
    const now=ac.currentTime;
    const comp=ac.createDynamicsCompressor();
    comp.threshold.value=-26; comp.knee.value=16; comp.ratio.value=3.5; comp.attack.value=0.003; comp.release.value=0.08;
    comp.connect(MASTER);

    const {src:nSrc,g:nGain}=makeNoise(ac,0.06);
    nGain.connect(comp);
    nGain.gain.setValueAtTime(0.0001,now);
    nGain.gain.linearRampToValueAtTime(0.12,now+0.008);
    nGain.gain.exponentialRampToValueAtTime(0.0001,now+0.08);
    nSrc.start(now); nSrc.stop(now+0.09);

    const o=ac.createOscillator(); const g=ac.createGain();
    o.type='sine';
    o.frequency.setValueAtTime(420,now);
    o.frequency.exponentialRampToValueAtTime(200,now+0.18);
    g.gain.setValueAtTime(0.0001,now);
    g.gain.linearRampToValueAtTime(0.10,now+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001,now+0.22);
    o.connect(g).connect(comp);
    o.start(now); o.stop(now+0.24);
  }

  // Dice roll sound â€” uses your hosted MP3 instead of synthesized audio
  function dice(){
    // Ensure audio context is running for consistency with the rest of the engine
    const ac = getAC(); if(!ac) return; if(ac.state!=='running'){ tryResume(); }

    // Clone the preloaded element so rapid rolls can overlap cleanly
    try{
      const el = baseDiceEl.cloneNode(true);
      el.currentTime = 0;
      el.volume = 0.9;
      el.play().catch(()=>{ /* ignore if user has not interacted yet */ });
    }catch(e){ /* noop */ }
  }

  const INTERACT_EVENTS=['pointerdown','mousedown','touchstart','keydown','click'];
  INTERACT_EVENTS.forEach(ev=>addEventListener(ev,markInteract,{passive:true,capture:true}));
  addEventListener('visibilitychange',()=>{ if(!document.hidden) tryResume(); });
  addEventListener('pageshow',()=>{ tryResume(); });
  addEventListener('focus',()=>{ tryResume(); });

  function startWatchdog(){
    if(watchdogTimer) return;
    watchdogTimer=setInterval(()=>{
      const ac=AC; if(!ac) return;
      const active=Date.now()-lastInteractTs<30_000;
      if(active && ac.state==='suspended') tryResume();
    },1500);
  }
  startWatchdog();

  // Expose controls
  window.__bagAudio={ensureInteractive,chime,nudge,dice};
})();
</script>
