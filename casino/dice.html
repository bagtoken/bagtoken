<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, proxy-revalidate, max-age=0" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>$BAG Dice â€” Clean Dice, Real Tumble (ESM)</title>

<style>
  :root{
    --bg:#060b08; --felt:#0a1c13; --felt2:#0f2a1c; --line:#173524;
    --fg:#f5f7f4; --muted:#aeb7af; --good:#2fbf6b; --warn:#e8a85c; --bad:#e25b5b;
    --gold1:#ffe175; --gold2:#f5c94c;
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1100px;margin:0 auto;padding:22px 14px 40px}
  .hero{display:flex;align-items:end;gap:10px;justify-content:center;margin:14px 0 10px}
  .hero h1{font-size:clamp(1.2rem,3.2vw,1.6rem);opacity:.95}
  .table{background:linear-gradient(180deg,var(--felt),var(--felt2));border:1px solid var(--line);border-radius:14px;padding:14px;box-shadow:0 10px 32px rgba(0,0,0,.25)}
  .stage{height:300px;border:1px solid #214a31;border-radius:12px;overflow:hidden;background:radial-gradient(120% 100% at 50% 10%, #123425 0%, #091a13 70%)}
  .stage canvas{display:block;width:100%;height:100%}
  .row{display:flex;gap:14px;align-items:stretch;flex-wrap:wrap;margin-top:10px}
  .btn{
    width:min(360px,95%);padding:14px 18px;border:0;border-radius:12px;font-weight:900;letter-spacing:.4px;
    color:#0a130e;background:linear-gradient(180deg,var(--gold1),var(--gold2));box-shadow:0 6px 0 #b08a19,0 14px 30px rgba(255,225,117,.18);cursor:pointer
  }
  .btn:active{transform:translateY(2px)}
  .status{margin-top:10px;padding:10px 12px;border:1px solid #234e35;border-radius:12px;background:#0c2318;display:grid;gap:6px}
  .status .line{display:flex;justify-content:space-between;gap:10px;font-variant-numeric:tabular-nums}
  .status .note{font-size:.9rem;color:#cfe0d6}
  .ok{color:var(--good)} .warn{color:var(--warn)} .bad{color:var(--bad)}

  /* Debug badge */
  .dbg{position:absolute;top:8px;left:8px;z-index:9;font:700 12px/1.2 Inter,system-ui,sans-serif;padding:6px 8px;border-radius:8px;background:#0b1b13;box-shadow:0 0 0 1px #234e35;color:#d2f5e3}
  #stage{position:relative}
</style>
</head>
<body>
  <div class="wrap">
    <div class="hero"><h1>ðŸŽ² $BAG Dice â€” Pass Line</h1></div>

    <div class="table">
      <div id="stage" class="stage" aria-label="3D dice area">
        <div id="dbg" class="dbg">BUILD: <b id="buildId"></b> Â· Bootingâ€¦</div>
      </div>

      <div class="row" style="justify-content:center">
        <button id="rollBtn" class="btn">ROLL</button>
      </div>

      <div id="status" class="status" role="status" aria-live="polite">
        <div class="line"><span>Phase</span><strong id="phase">Come-out</strong></div>
        <div class="line"><span>Last roll</span><strong id="lastRoll">â€”</strong></div>
        <div class="line"><span>Point</span><strong id="pointVal">â€”</strong></div>
        <div id="cta" class="note">Need <b>7 or 11</b> to <span class="ok">WIN</span>. <b>2/3/12</b> is <span class="bad">CRAPS</span>. Any other sets the <b>Point</b>.</div>
      </div>
    </div>
  </div>

<!-- SOUND -->
<script>
(function(){
  const shake = new Audio('/assets/sounds/diceshake.mp3'), roll = new Audio('/assets/sounds/diceroll.mp3');
  [shake,roll].forEach(a=>{ a.preload='auto'; a.crossOrigin='anonymous'; a.setAttribute('playsinline',''); a.volume=.95; });
  let primed=false; function prime(){ if(primed) return; primed=true; try{ shake.muted=true; shake.play().then(()=>{shake.pause();shake.currentTime=0;shake.muted=false;}).catch(()=>{});}catch{} }
  addEventListener('pointerdown', prime, {once:true, passive:true});
  window.SFX = {
    async shake(){ try{ const a=shake.cloneNode(); a.volume=shake.volume; await a.play().catch(()=>{});}catch{} },
    async roll(){ try{ const a=roll.cloneNode(); a.volume=roll.volume; await a.play().catch(()=>{});}catch{} }
  };
})();
</script>

<!-- MAIN (ES MODULE) -->
<script type="module">
  import * as THREE from 'https://unpkg.com/three@0.158.0/build/three.module.js';
  import { RoomEnvironment } from 'https://unpkg.com/three@0.158.0/examples/jsm/environments/RoomEnvironment.js';

  // DOM
  const stageEl = document.getElementById('stage');
  const rollBtn = document.getElementById('rollBtn');
  const dbgEl   = document.getElementById('dbg');
  const buildIdEl = document.getElementById('buildId');

  const phaseEl = document.getElementById('phase');
  const lastEl  = document.getElementById('lastRoll');
  const pointEl = document.getElementById('pointVal');
  const ctaEl   = document.getElementById('cta');

  // Build badge
  const BUILD = new Date().toISOString().replace('T',' ').slice(0,19);
  buildIdEl.textContent = BUILD;
  const shout = (msg)=>{ dbgEl.textContent = 'BUILD: ' + BUILD + ' Â· ' + msg; console.log('[BAG DICE]', msg); };

  // Game state
  const ROUND = { active:false, point:null };
  const resetComeOutUI = ()=>{
    phaseEl.textContent='Come-out';
    pointEl.textContent='â€”';
    ctaEl.innerHTML='Need <b>7 or 11</b> to <span class="ok">WIN</span>. <b>2/3/12</b> is <span class="bad">CRAPS</span>. Any other sets the <b>Point</b>.';
  };
  const setPointUI=(p)=>{
    ROUND.active=true; ROUND.point=p;
    phaseEl.textContent='Point';
    pointEl.textContent=String(p);
    ctaEl.innerHTML=`Point is <b>${p}</b> â€” Roll <b>${p}</b> to <span class="ok">WIN</span> before <b>7</b> (<span class="bad">SEVEN OUT</span>).`;
  };
  const winUI =(msg)=>{ ctaEl.innerHTML=`<span class="ok">WIN</span> â€” ${msg}`; };
  const loseUI=(msg)=>{ ctaEl.innerHTML=`<span class="bad">LOSE</span> â€” ${msg}`; };
  resetComeOutUI();

  /* -------------------- THREE: 3D dice with real inlaid pips -------------------- */
  function RoundedBox(w,h,d,r=0.19, seg=4){
    const g=new THREE.BoxGeometry(w,h,d,seg,seg,seg);
    const pos=g.attributes.position, hx=w/2,hy=h/2,hz=d/2, rx=Math.min(r,hx),ry=Math.min(r,hy),rz=Math.min(r,hz);
    for(let i=0;i<pos.count;i++){
      const x=pos.getX(i), y=pos.getY(i), z=pos.getZ(i);
      const ix=Math.max(-hx+rx,Math.min(hx-rx,x));
      const iy=Math.max(-hy+ry,Math.min(hy-ry,y));
      const iz=Math.max(-hz+rz,Math.min(hz-rz,z));
      const dx=x-ix, dy=y-iy, dz=z-iz, len=Math.hypot(dx,dy,dz);
      if(len>1e-6) pos.setXYZ(i, ix+dx/len*rx, iy+dy/len*ry, iz+dz/len*rz);
    }
    pos.needsUpdate=true; g.computeVertexNormals(); return g;
  }

  function makeDie(size=1.08){
    const g = new THREE.Group();

    // Materials
    const bodyMat = new THREE.MeshPhysicalMaterial({
      color:0xf3efe8, roughness:.38, metalness:0.02,
      sheen:1.0, sheenColor:new THREE.Color(0xffffff), sheenRoughness:.6,
      clearcoat:.7, clearcoatRoughness:.25, iridescence:.1, iridescenceIOR:1.2, iridescenceThicknessRange:[100,300],
      envMapIntensity:1.0
    });
    const pipMat  = new THREE.MeshPhysicalMaterial({
      color:0x0b0b0b, roughness:.6, metalness:.05, clearcoat:.2, clearcoatRoughness:.45
    });
    const edgeMat = new THREE.MeshStandardMaterial({ color:0xd9d7d2, roughness:.7, metalness:0 });

    // Body + subtle outline
    const body = new THREE.Mesh(RoundedBox(size,size,size,0.19,4), bodyMat);
    body.castShadow = true; g.add(body);
    const ink = new THREE.Mesh(new THREE.BoxGeometry(size*0.998,size*0.998,size*0.998), edgeMat);
    ink.scale.set(1.002,1.002,1.002); g.add(ink);

    // Inlaid pip cylinders
    const pipR = size*0.08, pipDepth = size*0.14, inset = size*0.52;
    const pipGeom = new THREE.CylinderGeometry(pipR, pipR, pipDepth, 32);
    const m = size*0.28, c = 0;
    const positions = {
      1:[[c,c]],
      2:[[-m,-m],[m,m]],
      3:[[-m,-m],[c,c],[m,m]],
      4:[[-m,-m],[m,-m],[-m,m],[m,m]],
      5:[[-m,-m],[m,-m],[c,c],[-m,m],[m,m]],
      6:[[-m,-m],[m,-m],[-m,c],[m,c],[-m,m],[m,m]],
    };
    const addFace = (face, nx,ny,nz)=>{
      positions[face].forEach(([u,v])=>{
        const pip = new THREE.Mesh(pipGeom, pipMat);
        if(nx!==0){ pip.rotation.z = Math.PI/2; }
        if(nz!==0){ pip.rotation.x = Math.PI/2; }
        pip.position.set(u + nx*inset, v + ny*inset, nz*inset);
        pip.castShadow = true; g.add(pip);
      });
    };
    // Opposites sum to 7
    addFace(3,+1,0,0); // +X
    addFace(4,-1,0,0); // -X
    addFace(1,0,+1,0); // +Y
    addFace(6,0,-1,0); // -Y
    addFace(2,0,0,+1); // +Z
    addFace(5,0,0,-1); // -Z

    // Pose helper
    g.__setTop = function(value, yaw=0){
      const m={
        1:[0,yaw,0], 2:[-Math.PI/2,yaw,0], 3:[0,yaw+Math.PI/2,0],
        4:[0,yaw-Math.PI/2,0], 5:[Math.PI/2,yaw,0], 6:[Math.PI,yaw,0],
      }[value]||[0,yaw,0];
      g.rotation.set(m[0],m[1],m[2]);
    };
    return g;
  }

  // Scene
  const w = stageEl.clientWidth, h = stageEl.clientHeight;
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(35, w/h, 0.1, 100);
  camera.position.set(0.8, 1.7, 6.2); camera.lookAt(0,0,0);

  const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true});
  renderer.setPixelRatio(Math.min(devicePixelRatio||1, 2));
  renderer.setSize(w,h);
  renderer.shadowMap.enabled=true; renderer.shadowMap.type=THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.06;
  stageEl.innerHTML=''; stageEl.appendChild(renderer.domElement);

  // Resize
  addEventListener('resize', ()=>{
    const W = stageEl.clientWidth, H = stageEl.clientHeight;
    camera.aspect = W/H; camera.updateProjectionMatrix();
    renderer.setSize(W,H);
  });

  // Environment â€” ESM, no legacy warning; sigma clamped
  const pmrem = new THREE.PMREMGenerator(renderer);
  const envRT = pmrem.fromScene(new RoomEnvironment(), 0.025);
  scene.environment = envRT.texture;

  // Felt
  const felt = new THREE.Mesh(
    new THREE.CylinderGeometry(3.8,3.8,0.02,64),
    new THREE.MeshStandardMaterial({color:0x0e2419, roughness:.92})
  );
  felt.rotation.x = -Math.PI/2; felt.position.y = -1.06; felt.receiveShadow = true;
  scene.add(felt);

  // Lights
  const key = new THREE.DirectionalLight(0xffffff,1.15); key.position.set(3.5,5.8,4.2); key.castShadow=true;
  key.shadow.mapSize.set(1024,1024); key.shadow.radius=3;
  key.shadow.camera.near=1; key.shadow.camera.far=20;
  key.shadow.camera.left=-7; key.shadow.camera.right=7; key.shadow.camera.top=7; key.shadow.camera.bottom=-7;
  const fill = new THREE.DirectionalLight(0xffffff,.46); fill.position.set(-4.2,3,2);
  const rim  = new THREE.DirectionalLight(0xffffff,.28); rim.position.set(0,6.5,-5.5);
  const amb  = new THREE.AmbientLight(0xcfd7e2,.34);
  scene.add(key,fill,rim,amb);

  // Dice
  const stage = new THREE.Group(); scene.add(stage);
  const A = makeDie(1.08), B = makeDie(1.08);
  stage.add(A,B);
  const centerPose = ()=>{
    A.position.set(-0.95, 0.28, 0.0);
    B.position.set( 0.95, 0.28,  0.0);
  };
  centerPose();

  // Hooks (debug)
  window.__setDiePoseHook = (a,b)=>{ try{ A.__setTop(a,0.15); B.__setTop(b,-0.2); }catch{} };
  window.__tweakDieLook = ({pipDepth, bodyTint})=>{
    try{
      A.children.concat(B.children).forEach(m=>{
        if (m.geometry && m.geometry.type === 'CylinderGeometry') {
          const n = m.position.clone().normalize().multiplyScalar((pipDepth||0.18));
          m.position.copy(n);
        }
      });
      if (bodyTint){ A.children[0].material.color.set(bodyTint); B.children[0].material.color.set(bodyTint); }
    }catch(e){}
  };

  // Render loop
  (function loop(){ renderer.render(scene,camera); requestAnimationFrame(loop); })();

  // Impact shake
  async function impact(ms=140, px=0.055){
    const t0=performance.now(); const ox=stage.position.x, oy=stage.position.y;
    await new Promise(res=>{
      (function step(t){
        const p=Math.min(1,(t-t0)/ms), k=(1-p);
        stage.position.x = ox + (Math.random()*2-1)*px*k;
        stage.position.y = oy + (Math.random()*2-1)*px*k*0.6;
        if(p<1) requestAnimationFrame(step); else{ stage.position.set(ox,oy,0); res(); }
      })(t0);
    });
  }

  // Throw & settle
  async function throwTo(a,b, totalMs=1250){
    const endY=0.28, startXA=-2.6, startXB= 2.6, startY=0.75;
    A.position.set(startXA,startY,0); B.position.set(startXB,startY,0);
    A.rotation.set(Math.random()*6,Math.random()*6,Math.random()*6);
    B.rotation.set(Math.random()*6,Math.random()*6,Math.random()*6);

    const yawA=(Math.random()*Math.PI*2-Math.PI), yawB=(Math.random()*Math.PI*2-Math.PI);
    const sA=36+Math.random()*8, sB=35+Math.random()*8;

    const t0=performance.now();
    await new Promise(res=>{
      function step(t){
        const raw=Math.min(1,(t-t0)/totalMs);
        const pAir=Math.min(1, raw/0.78), pDrop=Math.max(0,(raw-0.78)/0.22);
        const ease=(x)=>1-Math.pow(1-x,3);

        const xA=startXA+(-0.95-startXA)*ease(pAir);
        const xB=startXB+( 0.95-startXB)*ease(pAir);
        const arc = 0.66*(1 - (2*pAir-1)**2);
        const y=endY+arc+0.12;
        A.position.set(xA,y,0); B.position.set(xB,y,0);

        const dt=0.016;
        A.rotation.x+=1.18*sA*dt; A.rotation.y+=1.42*sA*dt; A.rotation.z+=0.82*sA*dt;
        B.rotation.x+=1.05*sB*dt; B.rotation.y+=1.30*sB*dt; B.rotation.z+=0.74*sB*dt;

        if(pDrop>0){
          const k=ease(pDrop);
          const toA={1:[0,yawA,0],2:[-Math.PI/2,yawA,0],3:[0,yawA+Math.PI/2,0],4:[0,yawA-Math.PI/2,0],5:[Math.PI/2,yawA,0],6:[Math.PI,yawA,0]}[a];
          const toB={1:[0,yawB,0],2:[-Math.PI/2,yawB,0],3:[0,yawB+Math.PI/2,0],4:[0,yawB-Math.PI/2,0],5:[Math.PI/2,yawB,0],6:[Math.PI,yawB,0]}[b];
          A.rotation.set(A.rotation.x+(toA[0]-A.rotation.x)*k, A.rotation.y+(toA[1]-A.rotation.y)*k, A.rotation.z+(toA[2]-A.rotation.z)*k);
          B.rotation.set(B.rotation.x+(toB[0]-B.rotation.x)*k, B.rotation.y+(toB[1]-B.rotation.y)*k, B.rotation.z+(toB[2]-B.rotation.z)*k);
        }
        if(raw<1) requestAnimationFrame(step); else res();
      }
      requestAnimationFrame(step);
    });

    A.__setTop(a,yawA); B.__setTop(b,yawB);
    A.position.y=B.position.y=endY;

    await impact(140,0.06);

    const wob0=performance.now();
    await new Promise(res=>{
      (function wob(ts){
        const t=(ts-wob0)/320; const k=Math.max(0,1-t);
        if(k<=0) return res();
        const w=0.06*k*Math.sin(ts*0.06);
        A.rotation.x+=w*0.02; B.rotation.y-=w*0.02;
        requestAnimationFrame(wob);
      })(wob0);
    });
  }

  // Public roll
  window.__rollDiceImpl = async function(a,b){
    await window.SFX?.shake();
    window.SFX?.roll();
    await throwTo(a,b,1250);
  };

  // Idle proof
  A.__setTop(1, 0.15); B.__setTop(6, -0.2);
  shout('THREE (ESM) + GEOMETRY PIPS âœ…');

  // UI wire
  const isComeOut = ()=> !ROUND.active || ROUND.point==null;
  const setStatus = (ra,rb,extra)=>{
    const sum = ra+rb;
    lastEl.textContent = `${ra} + ${rb} = ${sum}` + (extra?`  Â·  ${extra}`:'');
  };
  rollBtn.addEventListener('click', async ()=>{
    rollBtn.disabled=true;

    const a = 1 + (Math.random()*6|0);
    const b = 1 + (Math.random()*6|0);
    const sum = a + b;

    await window.__rollDiceImpl(a,b);

    if (isComeOut()){
      if (sum===7 || sum===11){
        setStatus(a,b,'Come-out WIN (1.25Ã—)');
        winUI('Come-out 7/11');
        ROUND.active=false; ROUND.point=null; resetComeOutUI();
      } else if (sum===2 || sum===3 || sum===12){
        setStatus(a,b,'CRAPS');
        loseUI('CRAPS on come-out');
        ROUND.active=false; ROUND.point=null; resetComeOutUI();
      } else {
        setStatus(a,b,'Point set');
        setPointUI(sum);
      }
    } else {
      if (sum===ROUND.point){
        setStatus(a,b,'POINT MADE (1.00Ã—)');
        winUI(`Point ${ROUND.point} made`);
        ROUND.active=false; ROUND.point=null; resetComeOutUI();
      } else if (sum===7){
        setStatus(a,b,'SEVEN OUT');
        loseUI('Seven out');
        ROUND.active=false; ROUND.point=null; resetComeOutUI();
      } else {
        setStatus(a,b,'Neutral â€” roll again');
      }
    }

    rollBtn.disabled=false;
  });

  // Cleanup PMREM target (optional)
  setTimeout(()=>{ envRT.dispose?.(); pmrem.dispose?.(); }, 0);
</script>
</body>
</html>
