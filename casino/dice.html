<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>$BAG Dice</title>

<link rel="preconnect" href="https://api.coingecko.com" crossorigin>
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>

<style>
  *{box-sizing:border-box}
  :root{
    --gold:#ffd700;--bg:#020703;--panel:#0b1b13;--panel2:#0d2217;--muted:#aeb7af;--fg:#f5f7f4;
    --green:#2fbf6b;--green2:#34c759;--line:#173524;--shadow:rgba(0,0,0,.35);
    --red:#e25b5b;
  }
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.55}
  img{display:block;max-width:100%;height:auto}
  button,input{font-size:16px}

  /* 🔙 Back to Casino button */
  .back-casino {
    position: fixed;
    top: 18px;
    left: 18px;
    z-index: 1000;
    background: linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);
    color: #08130d;
    text-decoration: none;
    font-weight: 800;
    padding: 8px 14px;
    border-radius: 10px;
    box-shadow: 0 4px 0 #b08a19;
    transition: all .15s ease;
  }
  .back-casino:hover {
    filter: brightness(1.05);
    box-shadow: 0 4px 0 #b08a19, 0 14px 28px rgba(255,225,117,.22);
  }
  .back-casino:active {
    transform: translateY(1px);
    box-shadow: 0 3px 0 #9a7315;
  }
  @media (max-width: 640px){
    .back-casino{ font-size:.9rem; padding:7px 12px; }
  }

  /* Game header */
  .game-header{text-align:center;padding:36px 10px 14px}
  .game-header img.hero-img{margin-bottom:10px;filter:drop-shadow(0 10px 24px rgba(46,191,107,.18))}
  .game-header h2{font-size:clamp(1.6rem,5vw,2.2rem);margin:6px 0 0}

  /* Desktop-only: tame the dice hero size */
  @media (min-width: 900px){
    .game-header img.hero-img{
      width: 34vw;
      max-width: 420px;
      margin-left: auto;
      margin-right: auto;
    }
  }

  /* Game area */
  .game-teaser{padding:10px 16px 60px;background:
    radial-gradient(1200px 600px at 10% -10%, #0e2c1d 0%, transparent 60%),
    radial-gradient(900px 500px at 110% 20%, #0b2318 0%, transparent 55%),#060806;
    border-top:1px solid #131313;border-bottom:1px solid #131313}
  .game-wrap{max-width:1080px;margin:0 auto;display:grid;grid-template-columns:1.12fr .88fr;gap:22px}
  @media (max-width:900px){.game-wrap{grid-template-columns:1fr}}

  .panel{background:linear-gradient(180deg,var(--panel) 0%,var(--panel2) 100%);border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 24px var(--shadow)}
  .mock{padding:16px}

  .section-title{font-weight:800;font-size:1.2rem;margin:0 0 12px}

  .stake-box{padding:14px}
  .stack{display:grid;gap:10px}
  .choice{display:flex;gap:10px;flex-wrap:wrap}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;border:1px solid #2b6a48;background:#0e2a1c;color:#e9efe9;font-weight:800}
  .chip input{accent-color:#2fbf6b}
  .mono{font-variant-numeric:tabular-nums}
  .micro{font-size:.85rem;color:#a8b5ab}
  .muted{color:#cfd6cf}
  .divider{height:1px;background:#123221;margin:10px 0}

  .callout{margin-top:12px;padding:12px;border:1px dashed #29543d;border-radius:12px;background:#0c2418;color:#e4efe7}
  .payout-grid{display:grid;gap:4px}
  .payout-grid .row{display:flex;justify-content:space-between}
  .payout-grid .lab{color:#cfd6cf}
  .payout-grid .val{font-variant-numeric:tabular-nums}

  .btn-roll{
    width:100%;margin-top:12px;padding:16px 22px;font-size:1.15rem;font-weight:900;text-transform:uppercase;
    letter-spacing:.5px;border:0;border-radius:14px;color:#08130d;background:linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);
    box-shadow:0 6px 0 #b08a19, 0 16px 32px rgba(255,225,117,.18), inset 0 1px 0 rgba(255,255,255,.35);
    transition:transform .06s ease, box-shadow .2s ease, filter .2s ease; cursor:pointer;
  }
  .btn-roll:hover{filter:brightness(1.05);box-shadow:0 6px 0 #b08a19, 0 22px 40px rgba(255,225,117,.26), inset 0 1px 0 rgba(255,255,255,.4)}
  .btn-roll:active{transform:translateY(2px);box-shadow:0 4px 0 #9a7315, 0 12px 24px rgba(255,225,117,.2), inset 0 1px 0 rgba(255,255,255,.3)}
  .btn-roll:disabled{opacity:.65;cursor:not-allowed;transform:none;box-shadow:0 6px 0 #6e6e6e, 0 10px 20px rgba(0,0,0,.2)!important}

  /* Dice visuals */
  .dice-area{margin-top:12px;display:flex;gap:16px;justify-content:center;align-items:center;perspective:700px;height:96px}
.cube{position:relative;width:76px;height:76px;transform-style:preserve-3d;transition:transform 900ms cubic-bezier(.2,.7,.2,1)}
/* was: .cube.rolling{animation:spin 900ms linear} */
.cube.rolling{ animation: spin 900ms linear infinite; }
  @keyframes spin{0%{transform:rotateX(0) rotateY(0)}100%{transform:rotateX(360deg) rotateY(360deg)}}
  .face{position:absolute;width:76px;height:76px;border-radius:12px;background:#fafafa;border:1px solid #ddd;box-shadow:inset 0 2px 10px rgba(0,0,0,.08),0 10px 20px rgba(0,0,0,.12)}
  .pip{position:absolute;width:10px;height:10px;border-radius:50%;background:#111;box-shadow:0 1px 0 rgba(255,255,255,.3)}
  .one {transform:rotateY(0deg) translateZ(38px)}
  .two {transform:rotateY(90deg) translateZ(38px)}
  .three{transform:rotateY(180deg) translateZ(38px)}
  .four{transform:rotateY(-90deg) translateZ(38px)}
  .five{transform:rotateX(90deg) translateZ(38px)}
  .six {transform:rotateX(-90deg) translateZ(38px)}
  .c{top:33px;left:33px}
  .tl{top:14px;left:14px}
  .tr{top:14px;right:14px}
  .bl{bottom:14px;left:14px}
  .br{bottom:14px;right:14px}
  .ml{top:33px;left:14px}
  .mr{top:33px;right:14px}
  .cube.show-1{transform:rotateX(0) rotateY(0)}
  .cube.show-2{transform:rotateX(0) rotateY(-90deg)}
  .cube.show-3{transform:rotateX(0) rotateY(-180deg)}
  .cube.show-4{transform:rotateX(0) rotateY(90deg)}
/* bring the positioned faces to the front correctly */
.cube.show-5{transform:rotateX(-90deg) rotateY(0)}
.cube.show-6{transform:rotateX(90deg) rotateY(0)}


  .result{margin-top:12px;padding:12px;border:1px solid #1b4a2f;border-radius:12px;background:#0b2217;display:flex;align-items:center;gap:10px}
  .result .n{font-weight:900;font-size:1.25rem}
  .ok{color:#2fbf6b}.warn{color:#e8a85c}.err{color:#e25b5b}
  .t.win{color:#2fbf6b}.t.lose{color:#e25b5b}

  /* WIN overlay */
  :root{ --win-fg:#fff; --win-glow:#00ffb2; --win-accent:#18a0fb; --win-bg: rgba(10,12,16,.70); }
  #win-overlay{ position:fixed; inset:0; display:none; place-items:center; background:radial-gradient(60% 60% at 50% 50%, rgba(24,160,251,.28), transparent 70%), var(--win-bg); z-index:2147483647; backdrop-filter:saturate(120%) blur(2px); }
  #win-card{ position:relative; text-align:center; padding:24px 32px; border-radius:16px; background:rgba(0,0,0,.35); box-shadow:0 10px 40px rgba(0,0,0,.45), inset 0 0 80px rgba(0,255,200,.06); transform:scale(.9); opacity:0; animation:win-pop .35s cubic-bezier(.2,.9,.2,1) forwards, win-float 1.8s ease-in-out .35s infinite; }
  #win-text{ font: 900 64px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; letter-spacing:.06em; background:linear-gradient(90deg, #fff, var(--win-glow), #fff); -webkit-background-clip:text; background-clip:text; color:transparent; text-shadow: 0 0 18px rgba(0,255,178,.35), 0 0 48px rgba(0,255,178,.25); filter:drop-shadow(0 4px 10px rgba(0,0,0,.35)); animation:shine 1.6s linear infinite; white-space:nowrap; }
  #win-sub{ margin-top:8px; color:#e7f6ff; opacity:.9; font: 600 16px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
  #win-close{ position:absolute; top:8px; right:10px; border:0; background:transparent; color:#cfeaff; font:700 20px/1 system-ui; cursor:pointer; padding:6px 8px; opacity:.7; }
  #win-canvas{ position:fixed; inset:0; pointer-events:none; z-index:2147483646; display:none; }
  @keyframes win-pop{ to{ transform:scale(1); opacity:1; } }
  @keyframes win-float{ 0%,100%{ transform:translateY(0) } 50%{ transform:translateY(-6px) } }
  @keyframes shine{ 0%{ background-position:0% 50% } 100%{ background-position:200% 50% } }
  @media (prefers-reduced-motion: reduce){ #win-card{ animation:none; transform:none; opacity:1; } #win-text{ animation:none; } }
</style>
</head>
<body>

<!-- 🔙 Back to Casino -->
<a href="/casino/" class="back-casino">⬅ Back to Casino</a>

<!-- Game header -->
<section class="game-header">
  <img src="/assets/bag-dice.png" alt="$BAG Dice" class="hero-img">
  <h2>🎲 $BAG Dice (Craps)</h2>
  <p class="micro" style="margin-top:4px;opacity:.9;">
    💰 <strong>All payouts are in $BAG.</strong> $XRP bets convert automatically at the live rate.
  </p>
</section>

<section class="game-teaser" aria-labelledby="game-teaser-title">
  <div class="game-wrap">

    <!-- LEFT: Demo & stake -->
    <div class="panel mock" id="bagDiceDemo">
      <div id="demo-badge" style="display:none;position:relative;margin:6px 0 10px 0;font:600 12px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;letter-spacing:.3px;">
        <span style="padding:6px 10px;border:1px solid #aaa;border-radius:6px;opacity:.9;">PRACTICE MODE — No real bets or payouts</span>
      </div>

      <!-- CONNECT -->
      <div id="connectRow" style="display:flex;justify-content:space-between;align-items:center;margin:-2px 0 10px 0;">
        <div id="connectStatus" class="micro" style="opacity:.9">Wallet: <span style="color:#e8a85c">not connected</span></div>
        <button id="connectBtn"
          style="padding:10px 14px;font-weight:800;border:0;border-radius:12px;color:#08130d;background:linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);box-shadow:0 4px 0 #b08a19;cursor:pointer;">
          Connect Xaman
        </button>
      </div>

      <!-- SESSION -->
      <div id="sessionRow" style="display:flex;justify-content:space-between;align-items:center;margin:6px 0 10px 0;">
        <div id="sessionStatus" class="micro" style="opacity:.9">Session: <span style="color:#e8a85c">not started</span></div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="startSessionBtn" style="padding:8px 12px;font-weight:800;border:0;border-radius:10px;color:#08130d;background:linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);box-shadow:0 3px 0 #b08a19;cursor:pointer;">Start Session</button>
          <button id="topUpBtn" style="padding:8px 12px;font-weight:800;border:0;border-radius:10px;color:#08130d;background:linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);box-shadow:0 3px 0 #b08a19;cursor:pointer;display:none;">Top Up</button>
          <button id="endSessionBtn" style="padding:8px 12px;font-weight:800;border:0;border-radius:10px;background:#15261c;color:#dfe9e2;border:1px solid #2b6a48;cursor:pointer;display:none;">End</button>
        </div>
      </div>

      <div class="section-title">Stake & Prices</div>

<div class="stake-box">
  <div class="stack">
    <!-- USD FIRST -->
    <div>
      <div class="micro">Amount (USD)</div>
      <div style="display:flex;align-items:center;gap:6px">
        <input id="usdBet" class="mono" type="number" inputmode="decimal" pattern="[0-9]*"
          min="0" max="2000" step="0.01" placeholder="0.00"
          style="width:140px;background:#0b2217;border:1px solid #1b4a2f;border-radius:10px;color:#f3f5f0;padding:10px">
        <span class="micro">USD</span>
      </div>
    </div>

    <!-- Bet currency tabs -->
    <div>
      <div class="micro">Bet currency</div>
      <div class="choice" id="curToggle">
        <label class="chip"><input type="radio" name="betCur" value="XRP" checked> XRP</label>
        <label class="chip"><input type="radio" name="betCur" value="BAG"> BAG</label>
      </div>
    </div>

    <!-- Crypto amount -->
    <div>
      <div class="micro">Bet amount</div>
      <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
        <div>
          <input id="demoBet" class="mono" type="number" inputmode="decimal" pattern="[0-9]*"
            min="0" step="any" value="1"
            style="width:140px;background:#0b2217;border:1px solid #1b4a2f;border-radius:10px;color:#f3f5f0;padding:10px">
          <span class="unit">XRP</span>
        </div>
      </div>
    </div>
  </div>
</div>


          <div class="divider"></div>

          <div class="micro">Game state</div>
          <div class="muted" id="stateText">Come-out roll — 7/11 win · 2/3/12 lose</div>
          <div class="micro" id="pointBadge" style="display:none;">Point: <b id="pointVal">—</b></div>

          <div class="divider"></div>

          <div class="micro">Live prices</div>
          <div class="muted mono" id="liveLine">
            <span id="liveDot" class="warn">●</span>
            <span> BAG $<span id="liveBAG">—</span> · XRP $<span id="liveXRP">—</span> <span id="liveNote"></span></span>
            <div class="micro" id="liveConv" style="margin-top:4px;opacity:.9;">1 BAG ≈ — XRP · 1 XRP ≈ — BAG</div>
            <div id="bagDiag" class="micro" style="opacity:.55;margin-top:4px;"></div>
          </div>

          <div class="callout mono" id="payoutBox">
            <div class="payout-grid">
              <div class="row"><div class="lab"><strong>Point Win</strong> (1.00×):</div><div class="val" id="payoutPoint">—</div></div>
              <div class="row"><div class="lab"><strong>Normal Win</strong> (1.25×):</div><div class="val" id="payoutNormal">— <span class="micro" id="payoutNormalGain" style="opacity:.9"></span></div></div>
              <div class="row"><div class="lab"><strong>Jackpot</strong> (2.00×):</div><div class="val" id="payoutJackpot">— <span class="micro" id="payoutJackpotGain" style="opacity:.9"></span></div></div>
            </div>
            <div class="micro" style="margin-top:6px;opacity:.85;">House edge (Pass Line): 1.41%</div>
          </div>

          <button id="rollBtn" class="btn-roll">Roll</button>

          <div class="micro" style="text-align:center;opacity:.7;margin-top:6px">
            If you don’t hear sound: tap Roll once, turn off Silent mode, and raise volume.
          </div>

          <div class="dice-area">
            <div class="cube" id="dieA">
              <div class="face one"><div class="pip c"></div></div>
              <div class="face two"><div class="pip tl"></div><div class="pip br"></div></div>
              <div class="face three"><div class="pip tl"></div><div class="pip c"></div><div class="pip br"></div></div>
              <div class="face four"><div class="pip tl"></div><div class="pip tr"></div><div class="pip bl"></div><div class="pip br"></div></div>
              <div class="face five"><div class="pip tl"></div><div class="pip tr"></div><div class="pip c"></div><div class="pip bl"></div><div class="pip br"></div></div>
              <div class="face six">
                <div class="pip tl"></div><div class="pip ml"></div><div class="pip bl"></div>
                <div class="pip tr"></div><div class="pip mr"></div><div class="pip br"></div>
              </div>
            </div>
            <div class="cube" id="dieB">
              <div class="face one"><div class="pip c"></div></div>
              <div class="face two"><div class="pip tl"></div><div class="pip br"></div></div>
              <div class="face three"><div class="pip tl"></div><div class="pip c"></div><div class="pip br"></div></div>
              <div class="face four"><div class="pip tl"></div><div class="pip tr"></div><div class="pip bl"></div><div class="pip br"></div></div>
              <div class="face five"><div class="pip tl"></div><div class="pip tr"></div><div class="pip c"></div><div class="pip bl"></div><div class="pip br"></div></div>
              <div class="face six">
                <div class="pip tl"></div><div class="pip ml"></div><div class="pip bl"></div>
                <div class="pip tr"></div><div class="pip mr"></div><div class="pip br"></div>
              </div>
            </div>
          </div>

          <div class="result">
            <div class="n" id="rollNumber">—</div>
            <div class="t" id="rollText">Tap Roll</div>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: Rules -->
    <div class="panel" style="padding:16px">
      <h3 style="margin:0 0 8px;font-size:1.2rem;">How it plays (Pass Line)</h3>
      <ul style="margin:0;padding-left:18px;color:#cfd6cf">
        <li><b>Come-out:</b> 7/11 win · 2/3/12 lose · else set the <b>Point</b></li>
        <li><b>Point phase:</b> roll until the point reappears (win) or 7 (lose)</li>
      </ul>

      <h4 style="margin:12px 0 6px;">Payouts:</h4>
      <ul style="margin:0;padding-left:18px;color:#cfd6cf">
        <li><b>Point Win:</b> get your bet back (1.00×, no gain).</li>
        <li><b>Normal Win (7/11):</b> 1.25× payout (+0.25× gain).</li>
        <li><b>Jackpot:</b> 2.00× payout (+1.00× gain).</li>
      </ul>

      <p class="micro" style="margin-top:10px">No wallet connection yet. Visual demo only while development continues.</p>
    </div>

  </div>
</section>

<!-- WIN overlay -->
<canvas id="win-canvas"></canvas>
<div id="win-overlay" role="dialog" aria-live="polite" aria-label="Win notification">
  <div id="win-card">
    <button id="win-close" aria-label="Close">×</button>
    <div id="win-text">WIN</div>
    <div id="win-sub">Nice roll</div>
  </div>
</div>

<!-- AUDIO ENGINE -->
<script>
(function(){
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let AC = null, MASTER = null, lastInteractTs = 0, watchdogTimer = null;
  function makeAC(){ if(!AudioCtx) return null; const ac=new AudioCtx(); const master=ac.createGain(); master.gain.value=0.22; master.connect(ac.destination); AC=ac; MASTER=master; ac.onstatechange=function(){ if(ac.state==='suspended') tryResume(); }; return ac; }
  function getAC(){ if(AC && AC.state!=='closed') return AC; return makeAC(); }
  function silentTick(ac){ const o=ac.createOscillator(); const g=ac.createGain(); g.gain.value=0.00001; o.connect(g).connect(MASTER); o.start(); o.stop(ac.currentTime+0.01); }
  async function tryResume(){ const ac=getAC(); if(!ac) return; if(ac.state==='suspended'){ try{await ac.resume();}catch(e){} } if(ac.state==='running'){ silentTick(ac); } }
  function markInteract(){ lastInteractTs=Date.now(); tryResume(); }
  async function ensureInteractive(){ const ac=getAC(); if(!ac) return null; if(ac.state!=='running'){ await tryResume(); } return ac; }
  function makeNoise(ac,dur=0.08){ const len=Math.max(1,Math.floor(dur*ac.sampleRate)); const buf=ac.createBuffer(1,len,ac.sampleRate); const data=buf.getChannelData(0); for(let i=0;i<len;i++) data[i]=(Math.random()*2-1)*0.9; const src=ac.createBufferSource(); src.buffer=buf; const bp=ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1200; bp.Q.value=2.0; const g=ac.createGain(); g.gain.value=0; src.connect(bp).connect(g); return {src,g}; }
  function chime(){ const ac=getAC(); if(!ac) return; if(ac.state!=='running'){ tryResume(); return; } const now=ac.currentTime; const notes=[880,1175,1760]; notes.forEach((f,i)=>{ const o=ac.createOscillator(); const g=ac.createGain(); o.type='triangle'; o.frequency.value=f; g.gain.setValueAtTime(0.0001,now+i*0.02); g.gain.linearRampToValueAtTime(0.18,now+i*0.02+0.03); g.gain.exponentialRampToValueAtTime(0.0001,now+i*0.02+0.28); o.connect(g).connect(MASTER); o.start(now+i*0.02); o.stop(now+i*0.02+0.3); }); }
  function nudge(){ const ac=getAC(); if(!ac) return; if(ac.state!=='running'){ tryResume(); return; } const now=ac.currentTime; const comp=ac.createDynamicsCompressor(); comp.threshold.value=-26; comp.knee.value=16; comp.ratio.value=3.5; comp.attack.value=0.003; comp.release.value=0.08; comp.connect(MASTER); const {src:nSrc,g:nGain}=makeNoise(ac,0.06); nGain.connect(comp); nGain.gain.setValueAtTime(0.0001,now); nGain.gain.linearRampToValueAtTime(0.12,now+0.008); nGain.gain.exponentialRampToValueAtTime(0.0001,now+0.08); nSrc.start(now); nSrc.stop(now+0.09); const o=ac.createOscillator(); const g=ac.createGain(); o.type='sine'; o.frequency.setValueAtTime(420,now); o.frequency.exponentialRampToValueAtTime(200,now+0.18); g.gain.setValueAtTime(0.0001,now); g.gain.linearRampToValueAtTime(0.10,now+0.02); g.gain.exponentialRampToValueAtTime(0.0001,now+0.22); o.connect(g).connect(comp); o.start(now); o.stop(now+0.24); }
function dice() {
  const ac = getAC();
  if (!ac) return;
  if (ac.state !== 'running') { tryResume(); return; }

  const now = ac.currentTime;
  const dur = 1.2; // total duration of the roll sound
  const hitCount = 10; // number of dice “clacks”

  // Low rumble while dice roll
  const rumble = ac.createOscillator();
  const g = ac.createGain();
  rumble.type = 'triangle';
  rumble.frequency.setValueAtTime(120, now);
  rumble.frequency.exponentialRampToValueAtTime(80, now + dur);
  g.gain.setValueAtTime(0.04, now);
  g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
  rumble.connect(g).connect(MASTER);
  rumble.start(now);
  rumble.stop(now + dur);

  // Add random “clack” transients
  for (let i = 0; i < hitCount; i++) {
    const t = now + Math.random() * dur * 0.9;
    const { src, g: gain } = makeNoise(ac, 0.04);
    const bp = ac.createBiquadFilter();
    bp.type = 'bandpass';
    bp.frequency.value = 1500 + Math.random() * 1000;
    src.connect(bp).connect(gain).connect(MASTER);
    gain.gain.setValueAtTime(0.0001, t);
    gain.gain.linearRampToValueAtTime(0.12, t + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.08);
    src.start(t);
    src.stop(t + 0.1);
  }
}
const INTERACT_EVENTS=['pointerdown','mousedown','touchstart','keydown','click']; INTERACT_EVENTS.forEach(ev=>addEventListener(ev,markInteract,{passive:true,capture:true})); addEventListener('visibilitychange',()=>{ if(!document.hidden) tryResume(); }); addEventListener('pageshow',()=>{ tryResume(); }); addEventListener('focus',()=>{ tryResume(); });
  function startWatchdog(){ if(watchdogTimer) return; watchdogTimer=setInterval(()=>{ const ac=AC; if(!ac) return; const active=Date.now()-lastInteractTs<30_000; if(active && ac.state==='suspended') tryResume(); },1500); } startWatchdog();
  window.__bagAudio={ensureInteractive,chime,nudge,dice};
})();
</script>

<!-- WIN overlay logic -->
<script>
(function(){
  const overlay=document.getElementById('win-overlay');
  const canvas=document.getElementById('win-canvas');
  const ctx=canvas.getContext('2d');
  const closeBtn=document.getElementById('win-close');
  const sub=document.getElementById('win-sub');
  const title=document.getElementById('win-text');
  let rafId=null, particles=[], start=0, dur=2000;
  function sizeCanvas(){ const dpr=Math.min(window.devicePixelRatio||1,2); canvas.width=Math.floor(innerWidth*dpr); canvas.height=Math.floor(innerHeight*dpr); canvas.style.width=innerWidth+'px'; canvas.style.height=innerHeight+'px'; ctx.setTransform(dpr,0,0,dpr,0,0); }
  sizeCanvas(); addEventListener('resize', sizeCanvas);
  function spawnConfetti(n){ particles.length=0; const colors=['#ffffff','#00ffb2','#18a0fb','#ffd166','#f72585']; for(let i=0;i<n;i++){ const x=innerWidth*0.25+Math.random()*innerWidth*0.5; const y=innerHeight*0.35+Math.random()*innerHeight*0.1; const speed=2+Math.random()*4; particles.push({ x,y, vx:(Math.random()-.5)*speed*1.2, vy:-(3+Math.random()*5), g:0.12+Math.random()*0.2, rot:Math.random()*6.28, vr:(Math.random()-.5)*0.2, sz:6+Math.random()*10, col:colors[(Math.random()*colors.length)|0], shape:Math.random()<.4?'circle':(Math.random()<.5?'square':'tri') }); } }
  function draw(){ ctx.clearRect(0,0,innerWidth,innerHeight); particles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.vy+=p.g; p.rot+=p.vr; ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot); ctx.fillStyle=p.col; const s=p.sz; if(p.shape==='circle'){ ctx.beginPath(); ctx.arc(0,0,s*0.6,0,Math.PI*2); ctx.fill(); } else if(p.shape==='square'){ ctx.fillRect(-s/2,-s/2,s,s); } else { ctx.beginPath(); ctx.moveTo(0,-s/1.2); ctx.lineTo(s/1.2,s/1.2); ctx.lineTo(-s/1.2,s/1.2); ctx.closePath(); ctx.fill(); } ctx.restore(); }); }
  function animate(ts){ if(!start) start=ts; draw(); if(ts-start<dur){ rafId=requestAnimationFrame(animate); } else { stop(); } }
  function startFx(){ if(matchMedia('(prefers-reduced-motion: reduce)').matches) return; start=0; dur=2200; canvas.style.display='block'; spawnConfetti(180); rafId=requestAnimationFrame(animate); }
  function stop(){ cancelAnimationFrame(rafId); ctx.clearRect(0,0,innerWidth,innerHeight); canvas.style.display='none'; }
  function show(){ overlay.style.display='grid'; addEventListener('keydown', e=>{ if(e.key==='Escape') hide(); }, {once:true}); }
  function hide(){ overlay.style.display='none'; stop(); }
  closeBtn.addEventListener('click', hide);
  overlay.addEventListener('click', e=>{ if(e.target===overlay) hide(); });
  window.showWin=function(opts={}){ const { message='WIN', subtext='Nice roll', duration=4000, sound=true }=opts; title.textContent=message; sub.textContent=subtext; show(); startFx(); if(sound){ try{ window.__bagAudio && __bagAudio.chime(); }catch(e){} } clearTimeout(window.__winTimer); window.__winTimer=setTimeout(hide, Math.max(1000,duration)); };
})();
</script>

<!-- Xaman wallet connect -->
<script>
(function(){
  const WALLET_KEY = 'bag_wallet_v1';
  const API_KEY = '48d8a5b2-0f90-4c5a-b5c2-3d7c8fd6113f';

  const btn = document.getElementById('connectBtn');
  const statusEl = document.getElementById('connectStatus');
  if (!btn || !statusEl) return;

  const read  = () => { try { return JSON.parse(localStorage.getItem(WALLET_KEY)||'null'); } catch { return null; } };
  const write = (w) => { try { localStorage.setItem(WALLET_KEY, JSON.stringify(w)); } catch {} };
  const clear = () => { try { localStorage.removeItem(WALLET_KEY); } catch {} };

  function safeShort(a){
    try{ const s = a == null ? '' : String(a); if (!s) return ''; return s.slice(0,6) + '…' + s.slice(-4); }catch{ return ''; }
  }

  function render(){
    try{
      const w = read();
      if (w && w.address){
        statusEl.innerHTML = 'Wallet: <span style="color:#2fbf6b">'+safeShort(w.address)+'</span>';
        btn.textContent = 'Disconnect';
      } else {
        statusEl.innerHTML = 'Wallet: <span style="color:#e8a85c">not connected</span>';
        btn.textContent = 'Connect Xaman';
      }
    }catch(e){
      console.warn('[bag] render failed', e);
      statusEl.textContent = 'Wallet: error';
      btn.textContent = 'Connect Xaman';
    }
  }

  let xumm = null, ready = false, tries = 0;
  function initIfSdk(){
    if (ready) return true;
    if (typeof window.Xumm === 'function'){
      xumm = new Xumm(API_KEY);
      ready = true;

      const w = read();
      if (w?.address){
        window.dispatchEvent(new CustomEvent('bag:walletConnected', { detail: { address: String(w.address) }}));
      }

      xumm.on('success', () => {
        try{
          const acct = xumm?.user?.account || null;
          if (acct){
            write({ address: String(acct), ts: Date.now(), kind: 'xaman' });
            window.dispatchEvent(new CustomEvent('bag:walletConnected', { detail: { address: String(acct) }}));
            render();
          }
        }catch(e){ console.warn('[bag] success handler error', e); }
      });

      xumm.on('ready', () => { render(); });
      return true;
    }
    if (tries++ < 60) setTimeout(initIfSdk, 200);
    return false;
  }

  async function connectXaman(){
    if (!ready && !initIfSdk()){
      alert('Loading Xaman… try again in a moment.');
      return;
    }
    btn.disabled = true;
    try {
      const auth = await xumm.authorize();
      const acct = (xumm && xumm.user && xumm.user.account) || auth?.me?.account || null;
      if (!acct) throw new Error('No account returned');
      write({ address: String(acct), ts: Date.now(), kind: 'xaman' });
      window.dispatchEvent(new CustomEvent('bag:walletConnected', { detail: { address: String(acct) }}));
      render();
    } catch (e) {
      console.warn('Xaman connect failed/cancelled', e);
    } finally {
      btn.disabled = false;
    }
  }

  btn.addEventListener('click', async ()=>{
    const w = read();
    if (w && w.address){
      clear();
      window.dispatchEvent(new CustomEvent('bag:walletDisconnected'));
      render();
    } else {
      await connectXaman();
    }
  });

  document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) render(); });

  render();
  initIfSdk();
})();
</script>

<!-- TAB SESSION -->
<script>
(function(){
  const TREASURY = 'rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr';
  const SESSION_KEY = 'bag_session_v1';
  const MIN_DEPOSIT_USD = 1;
  const MAX_DEPOSIT_USD = 500;

  const $ = s => document.querySelector(s);
  const statusEl = $('#sessionStatus');
  const startBtn = $('#startSessionBtn');
  const topUpBtn = $('#topUpBtn');
  const endBtn = $('#endSessionBtn');

  const read = () => { try { return JSON.parse(localStorage.getItem(SESSION_KEY)||'null'); } catch { return null; } };
  const write = (v) => { try { localStorage.setItem(SESSION_KEY, JSON.stringify(v)); } catch {} };
  const clear = () => { try { localStorage.removeItem(SESSION_KEY); } catch {} };

  function fmt(n){
    if (!Number.isFinite(n)) return '—';
    if (Math.abs(n) >= 1) return n.toLocaleString(undefined, {maximumFractionDigits:4});
    if (Math.abs(n) >= 1e-2) return n.toLocaleString(undefined, {maximumFractionDigits:6});
    if (Math.abs(n) >= 1e-4) return n.toLocaleString(undefined, {maximumFractionDigits:8});
    return n.toLocaleString(undefined, {maximumFractionDigits:10});
  }
  function fmtUsd(n){ return '$'+(Number(n)||0).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}); }

  function sessionActive(){ const s = read(); return !!(s && s.addr && s.bag>0); }

  function render(){
    const s = read();
    if (s && s.addr){
      const bag = Number(s.bag)||0;
      const usd = (window.__PRICES__?.bagUsd||0) * bag;
      statusEl.innerHTML = 'Session: <span style="color:#2fbf6b">'+fmt(bag)+' BAG</span>' + (usd?` <span class="micro" style="opacity:.75">(${fmtUsd(usd)})</span>`:'');
      startBtn.style.display = 'none';
      if (topUpBtn) topUpBtn.style.display = 'inline-block';
      endBtn.style.display = 'inline-block';
    } else {
      statusEl.innerHTML = 'Session: <span style="color:#e8a85c">not started</span>';
      startBtn.style.display = 'inline-block';
      if (topUpBtn) topUpBtn.style.display = 'none';
      endBtn.style.display = 'none';
    }
  }

  function suggestDepositUsd(){
    const PRICES = window.__PRICES__ || {bagUsd:0,xrpUsd:0};
    const betEl = document.getElementById('usdBet');
    const u = betEl && parseFloat(betEl.value) > 0 ? parseFloat(betEl.value) : 5;
    let usd = Math.max(MIN_DEPOSIT_USD, Math.min(MAX_DEPOSIT_USD, u * 20));
    if (!Number.isFinite(usd)) usd = MIN_DEPOSIT_USD;
    return usd;
  }

  async function waitForTx(txid, timeoutMs=30000){
    return new Promise(resolve=>{
      const ws = new WebSocket('wss://s1.ripple.com');
      const t = setTimeout(()=>{ try{ws.close();}catch{}; resolve(null); }, timeoutMs);
      ws.onopen = ()=> ws.send(JSON.stringify({id:1, command:'tx', transaction: txid, binary:false}));
      ws.onmessage = (ev)=>{
        try{
          const msg = JSON.parse(ev.data);
          if (msg?.result?.hash === txid && msg?.result?.validated){
            clearTimeout(t); try{ws.close();}catch{}; resolve(msg.result);
          }
        }catch{}
      };
      ws.onerror = ()=>{ clearTimeout(t); try{ws.close();}catch{}; resolve(null); };
    });
  }

  async function startSession(){
    if (!window.Xumm){ alert('Xaman SDK not loaded'); return; }
    const PRICES = window.__PRICES__ || {};
    if (!(PRICES.xrpUsd>0 && PRICES.bagUsd>0)){ alert('Waiting for live prices — try again in a few seconds.'); return; }
    const depositUsd = Math.max(1, suggestDepositUsd());
    const depositXrp = depositUsd / PRICES.xrpUsd;
    const drops = Math.round(depositXrp * 1_000_000);
    const w = JSON.parse(localStorage.getItem('bag_wallet_v1')||'null');
    if (!w || !w.address){ alert('Connect Xaman first'); return; }
    const xumm = new Xumm('48d8a5b2-0f90-4c5a-b5c2-3d7c8fd6113f');
    startBtn.disabled = true; startBtn.textContent = 'Opening…';
    try{
      const { created, resolved } = await xumm.payload.createAndSubscribe({
        txjson: { TransactionType:'Payment', Destination: TREASURY, Amount: String(drops),
          Memos:[{Memo:{MemoType:btoa('BAG'), MemoData:btoa('DICE_SESSION')}}] },
        options: { submit:true, expire:300 }
      }, ev => { if (ev?.data && 'signed' in ev.data) return ev; });
      const res = await resolved;
      if (!res?.signed) throw new Error('User declined in Xaman');
      const txid = res.response?.txid || res?.meta?.txid || res?.created?.reference;
      if (!txid) throw new Error('No txid returned');
      const validated = await waitForTx(txid, 60000);
      if (!validated || validated.engine_result !== 'tesSUCCESS'){ throw new Error('Payment not validated on-ledger yet'); }
      const bag = (depositUsd / PRICES.bagUsd);
      write({ addr: w.address, bag, ts: Date.now(), tx: txid });
      render();
      window.dispatchEvent(new CustomEvent('bag:sessionStarted', { detail: { bag, txid } }));
      alert('Session started — you’re good to play!');
    } catch (err){
      console.error('[bag] startSession error', err);
      alert('Session not started: ' + (err?.message || 'unknown error — see console'));
    } finally {
      startBtn.disabled = false; startBtn.textContent = 'Start Session';
    }
  }

  async function topUpSession(){
    if (!window.Xumm){ alert('Xaman SDK not loaded'); return; }
    const PRICES = window.__PRICES__ || {};
    if (!(PRICES.xrpUsd>0 && PRICES.bagUsd>0)){ alert('Waiting for live prices'); return; }
    const s = read();
    if (!(s && s.addr)){ alert('Start a session first.'); return; }
    const depositUsd = suggestDepositUsd();
    const depositXrp = depositUsd / PRICES.xrpUsd;
    const drops = Math.round(depositXrp * 1_000_000);
    const xumm = new Xumm('48d8a5b2-0f90-4c5a-b5c2-3d7c8fd6113f');
    if (topUpBtn) { topUpBtn.disabled = true; topUpBtn.textContent = 'Topping up…'; }
    try{
      const { created } = await xumm.payload.createAndSubscribe({
        txjson: { TransactionType:'Payment', Destination: TREASURY, Amount: String(drops),
          Memos:[{Memo:{MemoType:btoa('BAG'), MemoData:btoa('DICE_TOPUP')}}] },
        options: { submit:true, expire:300 }
      }, ()=>{});
      const resolved = await xumm.payload.get(created.uuid);
      const txid = resolved?.response?.txid || resolved?.meta?.txid;
      if (!txid) throw new Error('No txid (cancelled?)');
      const tx = await waitForTx(txid, 45000);
      if (!tx || tx.engine_result !== 'tesSUCCESS') throw new Error('Payment not validated');
      const addBag = (depositUsd / PRICES.bagUsd);
      const cur = read() || { addr: s.addr, bag: 0 };
      cur.bag = (Number(cur.bag)||0) + addBag; cur.ts = Date.now(); cur.lastTopUpTx = txid;
      write(cur); render();
      window.dispatchEvent(new CustomEvent('bag:sessionToppedUp', { detail: { addBag, txid } }));
    } catch(e){
      console.warn('Top-up failed', e); alert('Top-up cancelled or failed.');
    } finally {
      if (topUpBtn) { topUpBtn.disabled = false; topUpBtn.textContent = 'Top Up'; }
    }
  }

  function endSession(){ const s = read(); clear(); render(); window.dispatchEvent(new CustomEvent('bag:sessionEnded', { detail: s || {} })); }

  startBtn?.addEventListener('click', startSession);
  topUpBtn?.addEventListener('click', topUpSession);
  endBtn?.addEventListener('click', endSession);

  window.addEventListener('bag:pricesUpdated', render);
  render();

  window.__bagSession = {
    active: sessionActive,
    get: read,
    set: write,
    spend(bag){ const s = read(); if(!s) return false; if (s.bag < bag) return false; s.bag = Math.max(0, s.bag - bag); write(s); render(); return true; },
    credit(bag){ const s = read(); if(!s) return false; s.bag += bag; write(s); render(); return true; }
  };
})();
</script>

<!-- GAME LOGIC + PRICES -->
<script>
(function(){
  const PRICE_REFRESH_MS = 15000;
  const FETCH_TIMEOUT_MS = 8000;
  const LIVE_CACHE_TTL_MS = 24*60*60*1000;
  const VIEW_CACHE_TTL_MS = 6*60*60*1000;

  const XRPL_WSS = 'wss://s1.ripple.com';
  const BAG_ISSUER = 'rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr';
  const BAG_CODE = 'BAG';

  const rollBtn = document.getElementById('rollBtn');
  const rollNumber = document.getElementById('rollNumber');
  const rollText = document.getElementById('rollText');
  const betInput = document.getElementById('demoBet');
  const usdInput = document.getElementById('usdBet');
  const stateText = document.getElementById('stateText');
  const pointBadge = document.getElementById('pointBadge');
  const pointVal = document.getElementById('pointVal');
  const curToggle = document.getElementById('curToggle');
  const unitSpan = document.querySelector('#bagDiceDemo .unit');
  const liveDot = document.getElementById('liveDot');
  const liveBAG = document.getElementById('liveBAG');
  const liveXRP = document.getElementById('liveXRP');
  const liveNote = document.getElementById('liveNote');
  const liveConv = document.getElementById('liveConv');
  const diagSpan = document.getElementById('bagDiag');

  const payoutPoint = document.getElementById('payoutPoint');
  const payoutNormal = document.getElementById('payoutNormal');
  const payoutNormalGain = document.getElementById('payoutNormalGain');
  const payoutJackpot = document.getElementById('payoutJackpot');
  const payoutJackpotGain = document.getElementById('payoutJackpotGain');

  let point = null;
  const PRICES = (window.__PRICES__ = { bagUsd:0, xrpUsd:0, source:'—', ts:0 });
  const VIEW_CACHE_KEY = 'bag_prices_v8';
  const LAST_LIVE_KEY = 'bag_last_live_v1';

  const WALLET_KEY = 'bag_wallet_v1';
  let playLocked = true;
  const DEMO_PLAY = true;

  function isWalletConnected(){ try { const w = JSON.parse(localStorage.getItem(WALLET_KEY) || 'null'); return !!(w && w.address); } catch { return false; } }
  function pricesReadyForCurrentCurrency(){ return currentCurrency()==='BAG' ? PRICES.bagUsd>0 : PRICES.xrpUsd>0; }
function recomputeRollEnabled(){
  rollBtn.disabled = playLocked || (!DEMO_PLAY && !pricesReadyForCurrentCurrency());
}
  function setPlayLock(lock){
    playLocked = !!lock;
    if (playLocked){
      const msg = 'Connect wallet to play';
      if (rollText) { rollText.textContent = msg; rollText.classList.remove('win','lose'); }
    } else if (rollText && rollText.textContent === 'Connect wallet to play'){
      rollText.textContent = 'Tap Roll';
    }
    recomputeRollEnabled();
  }
  window.addEventListener('bag:walletConnected', () => setPlayLock(false));
  window.addEventListener('bag:walletDisconnected', () => DEMO_PLAY ? setPlayLock(false) : setPlayLock(true));
  setPlayLock(DEMO_PLAY ? false : !isWalletConnected());

  function fmt(n){
    if (!Number.isFinite(n)) return '—';
    if (Math.abs(n) >= 1) return n.toLocaleString(undefined, {maximumFractionDigits:4});
    if (Math.abs(n) >= 1e-2) return n.toLocaleString(undefined, {maximumFractionDigits:6});
    if (Math.abs(n) >= 1e-4) return n.toLocaleString(undefined, {maximumFractionDigits:8});
    return n.toLocaleString(undefined, {maximumFractionDigits:10});
  }
  function fmtUsd(n){ if (!Number.isFinite(n)) return '—'; return '$'+n.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}); }
  function cacheSet(k,v){ try{ localStorage.setItem(k, JSON.stringify({t:Date.now(), v})); }catch{} }
  function cacheGet(k, ttlMs){ try{ const o=JSON.parse(localStorage.getItem(k)||'null'); if(!o) return null; const age = Date.now() - (o.t||0); return age<=ttlMs ? o.v : null; }catch{ return null; } }

  function timedFetch(url, opts={}, timeout=FETCH_TIMEOUT_MS){
    const ctrl = new AbortController();
    const id = setTimeout(()=>ctrl.abort(new Error('timeout')), timeout);
    try{
      const u = new URL(url, location.origin);
      u.searchParams.set('_ts', Date.now().toString());
      return fetch(u.toString(), {
        ...opts,
        headers: { Accept:'application/json', ...(opts.headers||{}) },
        mode: 'cors',
        cache: 'no-store',
        credentials: 'omit',
        referrerPolicy: 'no-referrer',
        signal: ctrl.signal
      });
    } finally { setTimeout(()=>clearTimeout(id),0); }
  }

  function currentCurrency(){ const el = curToggle.querySelector('input[name="betCur"]:checked'); return el ? el.value : 'XRP'; }

  function stakeInBAG(){
    const bet = Math.max(0, parseFloat(betInput.value||0));
    if (!bet) return 0;
    if (currentCurrency()==='BAG') return bet;
    if (PRICES.bagUsd>0 && PRICES.xrpUsd>0){
      const bagPerXrp = PRICES.xrpUsd / PRICES.bagUsd;
      return bet * bagPerXrp;
    }
    return 0;
  }
  function stakeUsdEquivalent(){
    const qty = Math.max(0, parseFloat(betInput.value||0));
    if (!qty) return 0;
    if (currentCurrency()==='BAG') return PRICES.bagUsd>0 ? qty * PRICES.bagUsd : 0;
    return PRICES.xrpUsd>0 ? qty * PRICES.xrpUsd : 0;
  }

  let editingUsd = false;

  function clampUsd(u){
    const n = Number(u);
    if (!Number.isFinite(n)) return 0;
    if (n < 1) return 1;
    if (n > 2000) return 2000;
    return Number(n.toFixed(2));
  }

  function updateUsdFromBet(){
    if (editingUsd || !usdInput) return;
    const usd = stakeUsdEquivalent();
    usdInput.value = usd > 0 ? usd.toFixed(2) : '';
  }

  function updateBetFromUsd(){
    if (!usdInput || !betInput) return;

    const raw = parseFloat(usdInput.value);
    if (!(raw > 0)) {
      // Empty/invalid -> clear bet & previews
      betInput.value = '';
      updatePayoutPreview();
      updateLimitUi();
      return;
    }

    const usd = clampUsd(raw);
    if (usd !== raw) usdInput.value = usd.toFixed(2);

    // Only convert when the needed price is available
    if (currentCurrency() === 'XRP') {
      if (PRICES.xrpUsd > 0) {
        betInput.value = (usd / PRICES.xrpUsd).toFixed(6);
      } else {
        return; // prices not ready yet
      }
    } else {
      if (PRICES.bagUsd > 0) {
        betInput.value = (usd / PRICES.bagUsd).toFixed(6);
      } else {
        return; // prices not ready yet
      }
    }

    clampIfNeeded(false);
    updatePayoutPreview();
    updateLimitUi();
  }

  usdInput.addEventListener('focus', ()=>{ editingUsd = true; });
  usdInput.addEventListener('input', ()=>{ editingUsd = true; updateBetFromUsd(); });
  usdInput.addEventListener('blur',  ()=>{ editingUsd = false; updateBetFromUsd(); });

  betInput.addEventListener('input', ()=>{ clampIfNeeded(false); updatePayoutPreview(); updateUsdFromBet(); });
  betInput.addEventListener('blur',  ()=>{ updateUsdFromBet(); });


  function updatePayoutPreview(){
    const s = stakeInBAG();
    const usd = stakeUsdEquivalent();
    if (s>0){
      const ptTotal = s*1.00, ptUsd = usd*1.00;
      const nmTotal = s*1.25, nmGain = s*0.25, nmUsd = usd*1.25;
      const jpTotal = s*2.00, jpGain = s*1.00, jpUsd = usd*2.00;
      payoutPoint.textContent = `${fmt(ptTotal)} BAG (${fmtUsd(ptUsd)})`;
      payoutNormal.textContent = `${fmt(nmTotal)} BAG (${fmtUsd(nmUsd)})`;
      payoutNormalGain.textContent = `(gain +${fmt(nmGain)} BAG)`;
      payoutJackpot.textContent = `${fmt(jpTotal)} BAG (${fmtUsd(jpUsd)})`;
      payoutJackpotGain.textContent = `(gain +${fmt(jpGain)} BAG)`;
    } else {
      payoutPoint.textContent = payoutNormal.textContent = payoutJackpot.textContent = '—';
      payoutNormalGain.textContent = payoutJackpotGain.textContent = '';
    }
  }

  let limitNote, limitToast;
  (function ensureLimitUi(){
    const holder=betInput.closest('div'); const container=holder?.parentElement?.parentElement || holder?.parentElement;
    if(container){
      limitNote=document.createElement('div'); limitNote.className='micro'; limitNote.style.marginTop='6px'; container.appendChild(limitNote);
      limitToast=document.createElement('div'); limitToast.className='micro'; limitToast.style.cssText='margin-top:4px;color:#e25b5b;display:none;'; container.appendChild(limitToast);
    }
  })();
  function maxForCurrency(){ return currentCurrency()==='BAG' ? (PRICES.bagUsd>0 ? 2000/PRICES.bagUsd : 0) : (PRICES.xrpUsd>0 ? 2000/PRICES.xrpUsd : 0); }
  function minForCurrency(){ return currentCurrency()==='BAG' ? (PRICES.bagUsd>0 ? 1/PRICES.bagUsd : 0) : (PRICES.xrpUsd>0 ? 1/PRICES.xrpUsd : 0); }
  function clampIfNeeded(showToast=true){
    const maxQty = maxForCurrency(); if (!maxQty) return;
    let val = Math.max(0, parseFloat(betInput.value||0));
    if (val > maxQty){ betInput.value=String(maxQty); if(showToast){ limitToast.textContent=`Bet reduced to max: ${fmt(maxQty)} ${currentCurrency()}`; limitToast.style.display='block'; setTimeout(()=>{ limitToast.style.display='none'; },1600); } }
  }
  function updateLimitUi(){
    let note = `Min $1 · Max $2,000`;
    const maxXrp = PRICES.xrpUsd>0 ? 2000/PRICES.xrpUsd : 0;
    const maxBag = PRICES.bagUsd>0 ? 2000/PRICES.bagUsd : 0;
    const minXrp = PRICES.xrpUsd>0 ? 1/PRICES.xrpUsd : 0;
    const minBag = PRICES.bagUsd>0 ? 1/PRICES.bagUsd : 0;
    const partsMax=[]; if(maxXrp) partsMax.push(`${fmt(maxXrp)} XRP`); if(maxBag) partsMax.push(`${fmt(maxBag)} BAG`);
    const partsMin=[]; if(minXrp) partsMin.push(`${fmt(minXrp)} XRP`); if(minBag) partsMin.push(`${fmt(minBag)} BAG`);
    if (partsMin.length || partsMax.length){
      const minTxt = partsMin.length ? `Min ≈ ${partsMin.join(' or ')}` : '';
      const maxTxt = partsMax.length ? `Max ≈ ${partsMax.join(' or ')}` : '';
      note += ` · ${[minTxt,maxTxt].filter(Boolean).join(' · ')}`;
    }
    limitNote.textContent = note;
    clampIfNeeded(false); recomputeRollEnabled(); updateUsdFromBet();
  }

  function updateConversions(){
    if(PRICES.bagUsd>0 && PRICES.xrpUsd>0){
      const xrpPerBag = PRICES.bagUsd/PRICES.xrpUsd;
      const bagPerXrp = PRICES.xrpUsd/PRICES.bagUsd;
      liveConv.textContent = `1 BAG ≈ ${fmt(xrpPerBag)} XRP · 1 XRP ≈ ${fmt(bagPerXrp)} BAG`;
    } else {
      liveConv.textContent = '1 BAG ≈ — XRP · 1 XRP ≈ — BAG';
    }
  }
  function updateLiveLine(){
    liveBAG.textContent = fmt(PRICES.bagUsd);
    liveXRP.textContent = fmt(PRICES.xrpUsd);
    const dotClass = PRICES.source==='live-amm' ? 'ok' : PRICES.source==='last-live' ? 'warn' : 'err';
    liveDot.className = dotClass;
    liveNote.textContent = PRICES.source==='live-amm' ? ' (AMM live)' : PRICES.source==='last-live' ? ' (last live)' : ' (unavailable)';
    updateConversions(); updateLimitUi(); updatePayoutPreview();
    window.dispatchEvent(new CustomEvent('bag:pricesUpdated'));
  }

  async function fetchXrpUsd(){
    try{
      const r=await timedFetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
      if(!r.ok) throw new Error('cg http '+r.status);
      const v=(await r.json())?.ripple?.usd;
      if(Number(v)>0){ PRICES.xrpUsd=Number(v); cacheSet('xrp_usd',PRICES.xrpUsd); return true; }
      throw new Error('cg payload');
    }catch(_){}
    try{
      const r=await timedFetch('https://min-api.cryptocompare.com/data/price?fsym=XRP&tsyms=USD');
      if(!r.ok) throw new Error('cc http '+r.status);
      const v=(await r.json())?.USD;
      if(Number(v)>0){ PRICES.xrpUsd=Number(v); cacheSet('xrp_usd',PRICES.xrpUsd); return true; }
      throw new Error('cc payload');
    }catch(_){}
    try{
      const r=await timedFetch('https://api.kraken.com/0/public/Ticker?pair=XXRPZUSD');
      if(!r.ok) throw new Error('kr http '+r.status);
      const j=await r.json(); const k=Object.keys(j?.result||{})[0]; const last=j?.result?.[k]?.c?.[0];
      if(Number(last)>0){ PRICES.xrpUsd=Number(last); cacheSet('xrp_usd',PRICES.xrpUsd); return true; }
      throw new Error('kr payload');
    }catch(_){}
    const cached = cacheGet('xrp_usd', 24*60*60*1000);
    if(Number(cached)>0){ PRICES.xrpUsd=Number(cached); return true; }
    return false;
  }
  function parseXrpAmount(a){ if (a==null) return null; if (typeof a==='string') return Number(a)/1_000_000; if (typeof a==='object'){ if (a.currency === 'XRP' && a.value!=null) return Number(a.value); } return null; }
  function parseIouAmount(a){ if (!a || typeof a!=='object') return null; return Number(a.value); }

  async function fetchBagUsdFromAMM(){
    const req = { id:1, command:'amm_info', asset:{currency:BAG_CODE,issuer:BAG_ISSUER}, asset2:{currency:'XRP'} };
    const xrpPerBag = await new Promise((resolve)=>{
      const ws = new WebSocket('wss://s1.ripple.com');
      const t = setTimeout(()=>{ try{ws.close();}catch{}; resolve(null); }, FETCH_TIMEOUT_MS);
      ws.onopen = ()=> ws.send(JSON.stringify(req));
      ws.onerror = ()=>{ clearTimeout(t); try{ws.close();}catch{}; resolve(null); };
      ws.onmessage = (ev)=>{
        try{
          const msg = JSON.parse(ev.data);
          if (msg.id!==1 || !msg.result || !msg.result.amm) return;
          clearTimeout(t); try{ws.close();}catch{};
          const amm = msg.result.amm;
          const bagBal = parseIouAmount(amm.amount);
          const xrpBal = parseXrpAmount(amm.amount2);
          if (!(bagBal>0) || !(xrpBal>0)) return resolve(null);
          const price = xrpBal / bagBal;
          if (!(price>0) || !isFinite(price)) return resolve(null);
          if (diagSpan) diagSpan.textContent = `AMM pool · BAG=${bagBal.toLocaleString()} · XRP=${xrpBal.toLocaleString(undefined,{maximumFractionDigits:6})} · spot ${price.toLocaleString(undefined,{maximumFractionDigits:10})} XRP/BAG`;
          resolve(price);
        }catch{ resolve(null); }
      };
    });
    if (!xrpPerBag || !Number.isFinite(xrpPerBag) || xrpPerBag<=0) return false;
    if (PRICES.xrpUsd>0){
      PRICES.bagUsd = PRICES.xrpUsd * xrpPerBag;
      PRICES.source = 'live-amm'; cacheSet(LAST_LIVE_KEY, { bagUsd: PRICES.bagUsd, xrpUsd: PRICES.xrpUsd });
      return true;
    }
    return false;
  }

  function loadViewCache(){ const v = cacheGet(VIEW_CACHE_KEY, VIEW_CACHE_TTL_MS); const x = cacheGet('xrp_usd', VIEW_CACHE_TTL_MS);
    let used=false; if (v && Number(v.bagUsd)>0){ PRICES.bagUsd=v.bagUsd; if(Number(v.xrpUsd)>0) PRICES.xrpUsd=v.xrpUsd; used=true; } if (!PRICES.xrpUsd && Number(x)>0){ PRICES.xrpUsd=x; used=true; } return used; }
  function loadLastLive(){ const v = cacheGet(LAST_LIVE_KEY, LIVE_CACHE_TTL_MS);
    if (v && Number(v.bagUsd)>0){ PRICES.bagUsd = v.bagUsd; if (Number(v.xrpUsd)>0) PRICES.xrpUsd = v.xrpUsd; PRICES.source = 'last-live'; return true; } return false; }

  async function refreshPrices(){
    const hadX = PRICES.xrpUsd>0;
    const gotX = hadX || await fetchXrpUsd();
    let gotLive = false;
    try { gotLive = await fetchBagUsdFromAMM(); } catch {}
    if (gotLive && gotX){ PRICES.source = 'live-amm'; cacheSet(VIEW_CACHE_KEY,{bagUsd:PRICES.bagUsd||0,xrpUsd:PRICES.xrpUsd||0}); }
    else if (loadLastLive()) {/* keep */} else if (loadViewCache()){ PRICES.source = 'last-live'; } else { PRICES.source = '—'; }
    updateLiveLine();

    if (PRICES.xrpUsd>0 && PRICES.bagUsd>0 && !window.__defaultsSet){
      window.__defaultsSet = true;
      if (currentCurrency()==='XRP'){ betInput.value = '1'; }
      curToggle.addEventListener('change', ()=>{
        if (currentCurrency()==='BAG'){
          const bagPerXrp = PRICES.xrpUsd / PRICES.bagUsd;
          if (bagPerXrp>0) betInput.value = String(bagPerXrp);
        } else { betInput.value = '1'; }
        updatePayoutPreview(); updateLimitUi();
      }, { once:true });
      updatePayoutPreview(); updateLimitUi();
    }
  }

  function emitResult(detail){
    window.dispatchEvent(new CustomEvent('bag:rollResult', { detail }));
    const s = Number(detail.stakeBag)||0;
    const usd = stakeUsdEquivalent();
    if (typeof window.showWin === 'function'){
      if (detail.jackpot){ const gain=s*1.00; showWin({ message:'WIN', subtext:`+${fmt(gain)} BAG · ${fmtUsd(usd)} → ${fmtUsd(usd*2)}`, duration:8000 }); }
      else if (detail.kind==='normal'){ const gain=s*0.25; showWin({ message:'WIN', subtext:`+${fmt(gain)} BAG · ${fmtUsd(usd)} → ${fmtUsd(usd*1.25)}`, duration:6000 }); }
      else if (detail.kind==='point'){ const total=s*1.00; showWin({ message:'POINT WIN', subtext:`PAYOUT ${fmt(total)} BAG · ${fmtUsd(usd)}`, duration:4000 }); }
    }
    try{
      fetch('/api/payout', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ game:'bag-dice', phase: detail.phase, kind: detail.kind, jackpot: !!detail.jackpot,
          stake_bag: Number(detail.stakeBag)||0, bag_usd: PRICES.bagUsd||0, xrp_usd: PRICES.xrpUsd||0 })
      }).catch(()=>{});
    }catch(e){}
  }

rollBtn.addEventListener('click', async ()=>{
    // ✅ Demo override — allow rolling without wallet or session
    const demoMode = true;
    if (!demoMode && !(window.__bagSession && __bagSession.active())) {
      const t=document.querySelector('#startSessionBtn'); if(t) t.focus();
      alert('Start a session first (one-time sign).');
      return;
    }


    try{ window.__bagAudio && __bagAudio.dice(); }catch(e){}
if (!demoMode && !pricesReadyForCurrentCurrency()) return;

    const usdEq = (function(){ const q=parseFloat(betInput.value||0)||0; if(!q) return 0;
      return currentCurrency()==='BAG' ? (PRICES.bagUsd>0 ? q*PRICES.bagUsd : 0) : (PRICES.xrpUsd>0 ? q*PRICES.xrpUsd : 0); })();
if (!demoMode && usdEq < 1){ return; }
    const stakeBag = (function(){ const bet = Math.max(0, parseFloat(betInput.value||0)); if (!bet) return 0;
      if (currentCurrency()==='BAG') return bet; if (PRICES.bagUsd>0 && PRICES.xrpUsd>0){ const bagPerXrp = PRICES.xrpUsd / PRICES.bagUsd; return bet * bagPerXrp; } return 0; })();
let spent = true;
if (!demoMode) {
  const sess = __bagSession.get();
  if (!(sess && sess.bag >= stakeBag && stakeBag > 0)) return;
  spent = __bagSession.spend(stakeBag);
  if (!spent) return;
}

    rollBtn.disabled=true;
    const dieA=document.getElementById('dieA'); const dieB=document.getElementById('dieB');
    const resetCube=el=>{ el.className='cube'; }; const pose=(el,v)=>{ el.classList.add('show-'+v); };
resetCube(dieA); resetCube(dieB);
dieA.classList.add('rolling');
setTimeout(()=>dieB.classList.add('rolling'), 120); // slight delay for realism
    const a=(Math.random()*6|0)+1, b=(Math.random()*6|0)+1;
    await new Promise(r=>setTimeout(r,1900));
    [dieA,dieB].forEach(c=>c.classList.remove('rolling')); pose(dieA,a); pose(dieB,b);
    const total=a+b; document.getElementById('rollNumber').textContent=total; const rt=document.getElementById('rollText'); rt.classList.remove('win','lose');

    const detail = { phase: point==null?'comeout':'point', total, kind:null, jackpot:false, stakeBag };

    if (point==null){
      if (total===7 || total===11){
        detail.kind='normal'; if ((Math.random()*100|0)===0){ detail.jackpot=true; }
        rt.textContent=`Come-out WIN — ${total}`; rt.classList.add('win');
        const payout = detail.jackpot ? (stakeBag*2.00) : (stakeBag*1.25); __bagSession.credit(payout); emitResult(detail);
      } else if (total===2 || total===3 || total===12){
        rt.textContent=`Come-out LOSE — ${total}`; rt.classList.add('lose');
         try{ window.__bagAudio && __bagAudio.nudge(); }catch(e){}
      } else { point=total; document.getElementById('pointVal').textContent=String(point);
        document.getElementById('pointBadge').style.display='none'; document.getElementById('stateText').textContent='Point phase — hit the Point before 7';
        rt.textContent=`Point set to ${point}. Roll again.`; }
    } else {
      if (total===point){
        detail.kind='point'; rt.textContent=`POINT WIN — ${point}`; rt.classList.add('win');
        const payout = stakeBag*1.00; __bagSession.credit(payout); emitResult(detail);
        point=null; document.getElementById('pointBadge').style.display='none'; document.getElementById('stateText').textContent='Come-out roll — 7/11 win · 2/3/12 lose';
      } else if (total===7){
        rt.textContent=`LOSE — seven out`; rt.classList.add('lose');
         try{ window.__bagAudio && __bagAudio.nudge(); }catch(e){}
        point=null; document.getElementById('pointBadge').style.display='none'; document.getElementById('stateText').textContent='Come-out roll — 7/11 win · 2/3/12 lose';
      } else { rt.textContent=`Roll again — need ${point} (rolled ${total})`; }
    }
    rollBtn.disabled=false;
  });

  document.getElementById('stateText').textContent='Come-out roll — 7/11 win · 2/3/12 lose';
document.getElementById('pointBadge').style.display = 'inline-block';
  document.querySelector('#bagDiceDemo .unit').textContent='XRP';
  betInput.value = '1';
  if (usdInput) usdInput.value = '';
  curToggle.addEventListener('change', ()=>{ document.querySelector('#bagDiceDemo .unit').textContent=currentCurrency(); });

  try { ['bag_prices','bag_prices_v2','bag_prices_v3','bag_prices_v4','bag_prices_v5','bag_prices_v6','bag_prices_v7'].forEach(k=>localStorage.removeItem(k)); } catch {}

  function loadViewCache(){ const v = (function(k,ttl){ try{ const o=JSON.parse(localStorage.getItem(k)||'null'); if(!o) return null; const age=Date.now()-(o.t||0); return age<=ttl ? o.v : null; }catch{ return null; } })( 'bag_prices_v8', 6*60*60*1000 );
    const x = (function(k,ttl){ try{ const o=JSON.parse(localStorage.getItem(k)||'null'); if(!o) return null; const age=Date.now()-(o.t||0); return age<=ttl ? o.v : null; }catch{ return null; } })('xrp_usd', 6*60*60*1000);
    let used=false; if (v && Number(v.bagUsd)>0){ PRICES.bagUsd=v.bagUsd; if(Number(v.xrpUsd)>0) PRICES.xrpUsd=v.xrpUsd; used=true; }
    if (!PRICES.xrpUsd && Number(x)>0){ PRICES.xrpUsd=x; used=true; } return used; }

  if (loadViewCache()){ PRICES.source='last-live'; updateLiveLine(); }
  (async ()=>{ await refreshPrices(); setInterval(refreshPrices, PRICE_REFRESH_MS); })();
  updatePayoutPreview();
})();
</script>

<!-- Service worker (optional) -->
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js').catch(()=>{});
}
</script>

<!-- Practice Mode Wrapper -->
<script>
(function(){
  const qs = new URLSearchParams(location.search);
  const pathDemo = location.pathname.toLowerCase().includes('/demo');
  const demoMode = pathDemo || qs.get('demo') === '1' || window.__BAG_FORCE_DEMO === true;
  if (!demoMode) return;

  const badge = document.getElementById('demo-badge');
  if (badge) badge.style.display = 'block';

  const $ = (s)=>document.querySelector(s);
  const statusEl  = $('#sessionStatus');
  const startBtn  = $('#startSessionBtn');
  const topUpBtn  = $('#topUpBtn');
  const endBtn    = $('#endSessionBtn');
  const connectEl = $('#connectBtn');

  const DEMO_KEY = '__bag_demo_bag_v1';
  const START_BAG = 1000;
  function getBal(){ try{ const n = Number(localStorage.getItem(DEMO_KEY)); return Number.isFinite(n) && n>0 ? n : START_BAG; }catch{ return START_BAG; } }
  function setBal(v){ try{ localStorage.setItem(DEMO_KEY, String(Math.max(0, Math.floor(v)))) }catch{} }
  if (localStorage.getItem(DEMO_KEY) == null) setBal(START_BAG);

  function fmt(n){
    if (!Number.isFinite(n)) return '—';
    if (Math.abs(n) >= 1) return n.toLocaleString(undefined, {maximumFractionDigits:4});
    if (Math.abs(n) >= 1e-2) return n.toLocaleString(undefined, {maximumFractionDigits:6});
    if (Math.abs(n) >= 1e-4) return n.toLocaleString(undefined, {maximumFractionDigits:8});
    return n.toLocaleString(undefined, {maximumFractionDigits:10});
  }
  function fmtUsd(n){ return '$'+(Number(n)||0).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}); }

  function renderDemoSession(){
    const bag = getBal();
    const bagUsd = (window.__PRICES__?.bagUsd||0) * bag;
    if (statusEl){
      statusEl.innerHTML = 'Practice: <span style="color:#2fbf6b">'+fmt(bag)+' BAG</span>' +
        (bagUsd ? ` <span class="micro" style="opacity:.75">(${fmtUsd(bagUsd)})</span>` : '');
    }
    if (startBtn) startBtn.style.display = 'none';
    if (topUpBtn)  topUpBtn.style.display  = 'none';
    if (endBtn)    endBtn.style.display     = 'none';
  }
  renderDemoSession();
  window.addEventListener('bag:pricesUpdated', renderDemoSession);

  if (connectEl) connectEl.style.opacity = '0.9';

  window.__bagSession = {
    active: () => true,
    get: () => ({ addr:'demo', bag: getBal(), ts: Date.now() }),
    set: () => {},
    spend(bag){
      const b = getBal();
      if (!(bag>0) || b < bag) return false;
      setBal(b - bag); renderDemoSession(); return true;
    },
    credit(bag){
      if (!(bag>0)) return false;
      setBal(getBal() + bag); renderDemoSession(); return true;
    }
  };

  function toast(msg){
    try{ if (window.__bagAudio) __bagAudio.nudge(); }catch(e){}
    try{
      let t = document.getElementById('bag-demo-toast');
      if (!t){
        t = document.createElement('div');
        t.id = 'bag-demo-toast';
        t.style.cssText = 'position:fixed;left:50%;bottom:18px;transform:translateX(-50%);padding:10px 14px;border-radius:10px;background:#0b2217;color:#eaf3ed;border:1px solid #1b4a2f;box-shadow:0 6px 24px rgba(0,0,0,.35);font:600 13px system-ui;z-index:2147483647';
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.display = 'block';
      clearTimeout(window.__bagDemoToastTimer);
      window.__bagDemoToastTimer = setTimeout(()=>{ t.style.display='none'; }, 2200);
    }catch{}
  }

  window.addEventListener('bag:rollResult', (ev)=>{
    const d = ev?.detail || {};
    if (d.kind === 'normal' || d.kind === 'point' || d.jackpot){
      const mult = d.jackpot ? '2×' : (d.kind==='normal' ? '1.25×' : '1.00×');
      toast(`That roll pays ${mult} on-ledger. Connect when ready to play live`);
    }
  });

  const st = document.getElementById('stateText');
  if (st) st.textContent = 'Practice Mode — off-ledger rolls. Connect when ready to play live';
})();
</script>

<footer class="footer" style="text-align:center; padding:12px 0; line-height:1.6;">
  © 2025 $BAG Protocol | getthebag.io | Powered by $XRP
  <br>
  <a href="https://x.com/getthebag_io" target="_blank" rel="noopener" style="color:#e0c66f;text-decoration:none;font-weight:700;">𝕏 @getthebag_io</a> |
  <a href="https://t.me/getthebag_io" target="_blank" rel="noopener" style="color:#e0c66f;text-decoration:none;font-weight:700;">Telegram @getthebag_io</a>
</footer>
 
</body>
</html>
