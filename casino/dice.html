<script>
(function(){
  /* ---------- Dice engine (Three.js or CSS fallback) ---------- */
  const container = document.getElementById('dice3d');
  const cssWrap   = document.getElementById('cssDice');
  const rollBtn   = document.getElementById('rollBtn');
  const rollText  = document.getElementById('rollText');

  const ROUND = (window.ROUND = { active:false, point:null });

  function isComeOut(){ return !ROUND.active || ROUND.point==null; }
  function needText(){
    if (isComeOut()) return 'Need 7 or 11 to WIN · 2/3/12 is CRAPS · otherwise sets the Point';
    return `Point is ${ROUND.point} — Need ${ROUND.point} before 7`;
  }
  function setStatusRolled(a,b,sum,extra=''){
    rollText.className='t';
    rollText.textContent = `Rolled ${a}+${b}=${sum} — ${needText()}${extra ? ' · ' + extra : ''}`;
  }

  /* ---------------- THREE.JS: solid pearl dice with true 3D pips ---------------- */
  function initThree(){
    const THREE = window.THREE;
    const scene = new THREE.Scene();
    const w = container.clientWidth, h = container.clientHeight;
    const camera = new THREE.PerspectiveCamera(35, w/h, 0.1, 100);
    camera.position.set(0.75, 1.9, 6.2);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio||1, 2));
    renderer.setSize(w, h);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.05;
    container.innerHTML = ''; container.appendChild(renderer.domElement);

    addEventListener('resize', ()=>{
      const w = container.clientWidth, h = container.clientHeight;
      camera.aspect = w/h; camera.updateProjectionMatrix();
      renderer.setSize(w,h);
    });

    // Felt
    const floorY = -1.06;
    const felt = new THREE.Mesh(
      new THREE.CylinderGeometry(3.5,3.5,0.02,64),
      new THREE.MeshStandardMaterial({ color:0x0e2419, roughness:0.92, metalness:0 })
    );
    felt.rotation.x = -Math.PI/2; felt.position.y = floorY+0.01; felt.receiveShadow = true;
    scene.add(felt);

    // Lights: key/fill/rim/amb
    const key =  new THREE.DirectionalLight(0xffffff,1.05); key.position.set( 3.5,5.8,4.2); key.castShadow=true;
    key.shadow.mapSize.set(1024,1024); key.shadow.radius=3;
    key.shadow.camera.near=1; key.shadow.camera.far=20;
    key.shadow.camera.left=-7; key.shadow.camera.right=7; key.shadow.camera.top=7; key.shadow.camera.bottom=-7;
    const fill = new THREE.DirectionalLight(0xffffff,0.45); fill.position.set(-4.2,3,2);
    const rim  = new THREE.DirectionalLight(0xffffff,0.28); rim.position.set(0,6.5,-6);
    const amb  = new THREE.AmbientLight(0xb7c3d1,0.34);
    scene.add(key,fill,rim,amb);

    // Rounded cube geometry
    function RoundedBox(w,h,d,r=0.19, seg=4){
      const g=new THREE.BoxGeometry(w,h,d,seg,seg,seg);
      const pos=g.attributes.position, hx=w/2,hy=h/2,hz=d/2, rx=Math.min(r,hx),ry=Math.min(r,hy),rz=Math.min(r,hz);
      for(let i=0;i<pos.count;i++){
        const x=pos.getX(i), y=pos.getY(i), z=pos.getZ(i);
        const ix=Math.max(-hx+rx,Math.min(hx-rx,x));
        const iy=Math.max(-hy+ry,Math.min(hy-ry,y));
        const iz=Math.max(-hz+rz,Math.min(hz-rz,z));
        const dx=x-ix, dy=y-iy, dz=z-iz, len=Math.hypot(dx,dy,dz);
        if(len>1e-6) pos.setXYZ(i, ix+dx/len*rx, iy+dy/len*ry, iz+dz/len*rz);
      }
      pos.needsUpdate=true; g.computeVertexNormals(); return g;
    }

    // Materials
    const pearl = new THREE.MeshPhysicalMaterial({
      color: 0xf6f3ec, roughness: 0.42, metalness: 0.0,
      sheen: 1.0, sheenColor: new THREE.Color(0xffffff), sheenRoughness: 0.8,
      clearcoat: 0.65, clearcoatRoughness: 0.25, envMapIntensity: 1.0
    });
    const pipMat = new THREE.MeshStandardMaterial({ color:0x0e1215, roughness:0.35, metalness:0.0 });

    // Build a die with real 3D pips (spheres)
    function makeDie(size=1.08){
      const g = new THREE.Group();
      const body = new THREE.Mesh(RoundedBox(size,size,size,0.19,4), pearl);
      body.castShadow = true; body.receiveShadow = false;
      g.add(body);

      // pip layout (face value -> [positions]) on unit grid
      const s = size/2 - 0.16;
      const p = 0.38; // pip spacing
      const sets = {
        1:[[0,0]],
        2:[[-p,-p],[p,p]],
        3:[[-p,-p],[0,0],[p,p]],
        4:[[-p,-p],[-p,p],[p,-p],[p,p]],
        5:[[-p,-p],[-p,p],[0,0],[p,-p],[p,p]],
        6:[[-p,-p],[-p,0],[-p,p],[p,-p],[p,0],[p,p]]
      };
      const pipRadius = 0.09;
      function addPips(face, axis, sign){
        const list = sets[face];
        list.forEach(([u,v])=>{
          const geo = new THREE.SphereGeometry(pipRadius, 22, 18);
          const m   = new THREE.Mesh(geo, pipMat);
          m.castShadow = true; m.receiveShadow = false;
          if(axis==='x') m.position.set(sign*s, u, v);
          if(axis==='y') m.position.set(u, sign*s, v);
          if(axis==='z') m.position.set(u, v, sign*s);
          g.add(m);
        });
      }
      // Standard opposite sides sum to 7
      addPips(3,'x',+1); // right
      addPips(4,'x',-1); // left
      addPips(1,'y',+1); // top
      addPips(6,'y',-1); // bottom
      addPips(2,'z',+1); // front
      addPips(5,'z',-1); // back

      // Orientation helper
      g.__setTop = function(value, yaw=0){
        const map={
          1:[0,yaw,0], 2:[-Math.PI/2,yaw,0], 3:[0,yaw+Math.PI/2,0],
          4:[0,yaw-Math.PI/2,0], 5:[Math.PI/2,yaw,0], 6:[Math.PI,yaw,0],
        }[value]||[0,yaw,0];
        g.rotation.set(map[0],map[1],map[2]);
      };
      return g;
    }

    // Stage and dice
    const stage = new THREE.Group(); scene.add(stage);
    const diceA = makeDie(1.08);
    const diceB = makeDie(1.08);
    stage.add(diceA, diceB);

    function centerPose(){
      diceA.position.set(-0.95, 0.28, 0.0);
      diceB.position.set( 0.95, 0.28,  0.0);
    }
    centerPose();

    // Render loop
    (function loop(){ renderer.render(scene, camera); requestAnimationFrame(loop); })();

    // Camera micro-shake on impact
    async function impactShake(ms=140, px=0.06){
      const t0=performance.now(); const ox=stage.position.x, oy=stage.position.y;
      await new Promise(res=>{
        function f(t){
          const p=Math.min(1,(t-t0)/ms), k=(1-p);
          stage.position.x = ox + (Math.random()*2-1)*px*k;
          stage.position.y = oy + (Math.random()*2-1)*px*k*0.6;
          if(p<1) requestAnimationFrame(f); else{ stage.position.set(ox,oy,0); res(); }
        }
        requestAnimationFrame(f);
      });
    }

    // Tumble animation: big arc + random spin, then slerp to exact face
    async function throwDiceTo(a,b, totalMs=1350){
      const endY=0.28, startXA=-2.6, startXB= 2.6, startY=0.75;
      diceA.position.set(startXA,startY,0); diceB.position.set(startXB,startY,0);

      // random initial rotations
      diceA.rotation.set(Math.random()*6,Math.random()*6,Math.random()*6);
      diceB.rotation.set(Math.random()*6,Math.random()*6,Math.random()*6);

      const yawA=(Math.random()*Math.PI*2-Math.PI);
      const yawB=(Math.random()*Math.PI*2-Math.PI);

      // target orientations
      const tgtA=new THREE.Euler(...({1:[0,yawA,0],2:[-Math.PI/2,yawA,0],3:[0,yawA+Math.PI/2,0],4:[0,yawA-Math.PI/2,0],5:[Math.PI/2,yawA,0],6:[Math.PI,yawA,0]}[a]));
      const tgtB=new THREE.Euler(...({1:[0,yawB,0],2:[-Math.PI/2,yawB,0],3:[0,yawB+Math.PI/2,0],4:[0,yawB-Math.PI/2,0],5:[Math.PI/2,yawB,0],6:[Math.PI,yawB,0]}[b]));
      const qStartA=diceA.quaternion.clone(), qStartB=diceB.quaternion.clone();
      const qEndA=new THREE.Quaternion().setFromEuler(tgtA);
      const qEndB=new THREE.Quaternion().setFromEuler(tgtB);

      const t0=performance.now();
      await new Promise(res=>{
        function step(t){
          const raw=Math.min(1,(t-t0)/totalMs);
          // ease: accelerate then decelerate, with overspin portion
          const ease = raw<0.8
            ? 1 - Math.pow(1-(raw/0.8), 2.2)
            : 1; // final slerp in last 20%

          // ballistic arc for position
          const pAir = Math.min(1, raw/0.78);
          const xA = startXA+(-0.95-startXA)*(1-Math.pow(1-pAir,3));
          const xB = startXB+( 0.95-startXB)*(1-Math.pow(1-pAir,3));
          const arc = 0.64*(1 - (2*pAir-1)**2);
          const y=endY+arc+0.08;
          diceA.position.set(xA,y,0); diceB.position.set(xB,y,0);

          if(raw<0.8){
            // free spin phase
            const s=48*(1-pAir*0.85), dt=0.016;
            diceA.rotation.x+=1.10*s*dt; diceA.rotation.y+=1.35*s*dt; diceA.rotation.z+=0.74*s*dt;
            diceB.rotation.x+=1.02*s*dt; diceB.rotation.y+=1.22*s*dt; diceB.rotation.z+=0.66*s*dt;
          } else {
            // settle slerp
            const k = (raw-0.8)/0.2;
            diceA.quaternion.slerpQuaternions(qStartA, qEndA, k);
            diceB.quaternion.slerpQuaternions(qStartB, qEndB, k);
          }

          if(raw<1) requestAnimationFrame(step); else res();
        }
        requestAnimationFrame(step);
      });

      diceA.quaternion.copy(qEndA);
      diceB.quaternion.copy(qEndB);
      diceA.position.y=diceB.position.y=endY;
      await impactShake(140,0.06);
    }

    window.__bagDiceRollImpl = async function(a,b){
      const sP = window.__bagSfx?.playShake?.(); await sP;
      window.__bagSfx?.playRoll?.();
      await throwDiceTo(a,b,1350);
      await new Promise(r=>setTimeout(r,120));
    };
  }

  /* ---------------- CSS Fallback (no WebGL): simple DOM dice with pips ---------------- */
  function initCssFallback(){
    cssWrap.innerHTML = '';
    cssWrap.classList.add('active');
    const mk = ()=> {
      const d = document.createElement('div'); d.className='css-die';
      // 6 face planes
      const faces = ['f1','f2','f3','f4','f5','f6'];
      faces.forEach((cls,idx)=>{
        const f=document.createElement('div'); f.className='css-face '+cls;
        // generate pips as children
        const layout={
          1:[[0,0]],
          2:[[-1,-1],[1,1]],
          3:[[-1,-1],[0,0],[1,1]],
          4:[[-1,-1],[-1,1],[1,-1],[1,1]],
          5:[[-1,-1],[-1,1],[0,0],[1,-1],[1,1]],
          6:[[-1,-1],[-1,0],[-1,1],[1,-1],[1,0],[1,1]]
        }[idx+1];
        layout.forEach(([u,v])=>{
          const dot=document.createElement('span');
          dot.style.cssText='position:absolute;width:14px;height:14px;border-radius:50%;background:#0e1215;left:50%;top:50%;transform:translate(-50%,-50%)';
          dot.style.left = `calc(50% + ${u*22}px)`;
          dot.style.top  = `calc(50% + ${v*22}px)`;
          f.appendChild(dot);
        });
        d.appendChild(f);
      });
      cssWrap.appendChild(d);
      return d;
    };
    const A = mk(), B = mk();
    function setTop(el, val, yaw=0){
      const map={
        1:`rotateX(0rad) rotateY(${yaw}rad)`,
        2:`rotateX(-1.5708rad) rotateY(${yaw}rad)`,
        3:`rotateY(${yaw+1.5708}rad)`,
        4:`rotateY(${yaw-1.5708}rad)`,
        5:`rotateX(1.5708rad) rotateY(${yaw}rad)`,
        6:`rotateX(3.1416rad) rotateY(${yaw}rad)`,
      }[val]||`rotateX(0rad) rotateY(${yaw}rad)`;
      el.style.transform = map;
    }
    window.__bagDiceRollImpl = async function(a,b){
      A.classList.remove('settle'); B.classList.remove('settle');
      const yawA=(Math.random()*Math.PI*2-Math.PI), yawB=(Math.random()*Math.PI*2-Math.PI);
      A.style.transition=B.style.transition='transform .85s cubic-bezier(.2,.9,.2,1)';
      A.style.transform=`rotateX(${Math.random()*8}rad) rotateY(${Math.random()*8}rad)`;
      B.style.transform=`rotateX(${Math.random()*8}rad) rotateY(${Math.random()*8}rad)`;
      const sP = window.__bagSfx?.playShake?.(); await sP; window.__bagSfx?.playRoll?.();
      await new Promise(r=>setTimeout(r, 680));
      setTop(A,a,yawA); setTop(B,b,yawB);
      A.classList.add('settle'); B.classList.add('settle');
      await new Promise(r=>setTimeout(r, 240));
    };
  }

  // Boot after Three.js or fallback, then wire the roll button
  (function boot(){
    let tries = 0;
    function tick(){
      if (window.__THREE_READY__ && window.THREE){ initThree(); wireRoll(); }
      else if (window.__THREE_FAILED__ || tries>30){ initCssFallback(); wireRoll(); }
      else { tries++; setTimeout(tick, 100); }
    }
    tick();
  })();

  /* ---------------- Roll button + Pass-Line rules ---------------- */
  function wireRoll(){
    rollBtn?.addEventListener('click', async ()=>{
      if (!window.__bagDiceRollImpl) return;
      rollBtn.disabled = true;

      const a = 1 + (Math.random()*6|0);
      const b = 1 + (Math.random()*6|0);
      const sum = a + b;

      await window.__bagDiceRollImpl(a,b);

      if (isComeOut()){
        if (sum===7 || sum===11){
          rollText.className='t win';
          setStatusRolled(a,b,sum,'COME-OUT WIN (1.25×)');
          window.showWin?.({message:'WIN', subtext:'Come-out 7/11!'});
          window.dispatchEvent(new CustomEvent('bag:diceResult',{detail:{a,b,sum,outcome:'win',phase:'comeout'}}));
          ROUND.active=false; ROUND.point=null;
        } else if (sum===2 || sum===3 || sum===12){
          rollText.className='t lose';
          setStatusRolled(a,b,sum,'CRAPS — you lose');
          window.dispatchEvent(new CustomEvent('bag:diceResult',{detail:{a,b,sum,outcome:'lose',phase:'comeout'}}));
          ROUND.active=false; ROUND.point=null;
        } else {
          ROUND.active=true; ROUND.point=sum;
          rollText.className='t scratch';
          setStatusRolled(a,b,sum,`Point established: ${sum}`);
          window.dispatchEvent(new CustomEvent('bag:diceResult',{detail:{a,b,sum,outcome:'hold',point:sum}}));
        }
      } else {
        if (sum===ROUND.point){
          rollText.className='t win';
          setStatusRolled(a,b,sum,'POINT MADE! (1.00×)');
          window.showWin?.({message:'WIN', subtext:`Point ${ROUND.point}`});
          window.dispatchEvent(new CustomEvent('bag:diceResult',{detail:{a,b,sum,outcome:'win',phase:'point',point:ROUND.point}}));
          ROUND.active=false; ROUND.point=null;
        } else if (sum===7){
          rollText.className='t lose';
          setStatusRolled(a,b,sum,'SEVEN OUT — you lose');
          window.dispatchEvent(new CustomEvent('bag:diceResult',{detail:{a,b,sum,outcome:'lose',phase:'point',point:ROUND.point}}));
          ROUND.active=false; ROUND.point=null;
        } else {
          rollText.className='t scratch';
          setStatusRolled(a,b,sum,'No effect — roll again');
        }
      }
      rollBtn.disabled = false;
    });
  }
})();
</script>
