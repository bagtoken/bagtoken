<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"
/>
<title>$BAG PLINKO â€” $BAG Casino</title>

<style>
  *{box-sizing:border-box}
  :root{
    --bg:#020703; --fg:#f5f7f4; --muted:#aeb7af;
    --panel:#0b1b13; --panel2:#0d2217; --line:#173c27;
    --green:#2fbf6b; --gold:#ffd700; --shadow:rgba(0,0,0,.4);
  }
  html,body{
    margin:0;background:var(--bg);color:var(--fg);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    -webkit-text-size-adjust:100%;
    touch-action: manipulation;
  }
  a{color:inherit;text-decoration:none}

  /* ðŸ”™ Back to Casino button (unchanged â€“ do not touch) */
  .back-casino {
    position: fixed;
    top: 18px;
    left: 18px;
    z-index: 1000;
    background: linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);
    color: #08130d;
    text-decoration: none;
    font-weight: 800;
    padding: 8px 14px;
    border-radius: 10px;
    box-shadow: 0 4px 0 #b08a19;
    transition: all .15s ease;
  }
  .back-casino:hover { filter: brightness(1.05); box-shadow: 0 4px 0 #b08a19, 0 14px 28px rgba(255,225,117,.22); }
  .back-casino:active { transform: translateY(1px); box-shadow: 0 3px 0 #9a7315; }
  @media (max-width: 640px){
    .back-casino{ font-size:.9rem; padding:7px 12px; }
  }

  /* ========= SCOPE EVERYTHING TO PLINKO ONLY ========= */
  .plinko { max-width:1100px;margin:0 auto;padding:0 16px 16px }

  /* ðŸª™ $BAG PLINKO banner */
  .plinko .top-banner{
    display:flex;justify-content:center;align-items:center;
    margin:70px auto 14px;padding:0 10px;max-width:100%;
  }
  .plinko .top-banner img{
    width:100%;max-width:420px;height:auto;
    filter:drop-shadow(0 6px 12px rgba(0,0,0,.45));
    border-radius:12px;
  }
  @media(max-width:640px){ .plinko .top-banner img{max-width:300px;} }

  /* header row: center demo, right connect/session */
  .plinko header{
    display:grid;
    grid-template-columns:1fr auto 1fr;
    align-items:center;
    gap:10px;
    margin:6px 0 14px;
  }
  .plinko .h-center{justify-self:center}
  .plinko .h-right{justify-self:end;display:flex;align-items:center;gap:8px}

  /* Panels & stage */
  .plinko .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
  @media(max-width:980px){.plinko .grid{grid-template-columns:1fr}}

  .plinko .panel{
    background:radial-gradient(140% 100% at 0% 0%,rgba(27,64,45,.55),transparent 60%), var(--panel);
    border:1px solid var(--line); border-radius:14px; padding:14px; box-shadow:0 10px 30px var(--shadow)
  }

  .plinko .stage{position:relative;display:flex;align-items:center;justify-content:center;overflow:hidden}
  .plinko .canvas-wrap{position:relative;width:100%;max-width:640px;aspect-ratio:8/11}
  .plinko canvas{position:absolute;inset:0;width:100%;height:100%}

  .plinko .hud{position:absolute;top:10px;left:10px;right:10px;display:flex;justify-content:space-between;flex-wrap:wrap;gap:6px;pointer-events:none}
  .plinko .pill{background:#0a1e15;border:1px solid #244330;border-radius:999px;padding:6px 10px;font-size:12px;color:#cfe6d8}

  .plinko .cele{position:absolute;inset:0;display:none;align-items:center;justify-content:center;font-size:42px;font-weight:900;color:#ffe28c;text-shadow:0 4px 14px rgba(0,0,0,.6)}
  .plinko .cele.show{display:flex;animation:pop .9s ease}
  @keyframes pop{0%{transform:scale(.7);opacity:0}50%{transform:scale(1.06);opacity:1}100%{transform:scale(1)}}

  .plinko label{font-size:12px;color:var(--muted)}
  /* Inputs */
  .plinko input,.plinko select{width:100%;padding:12px;border-radius:10px;border:1px solid #244330;background:#0a1e15;color:#f5f7f4}
  .plinko input::placeholder{color:#8ea496}
  .plinko input::-webkit-outer-spin-button,
  .plinko input::-webkit-inner-spin-button{ -webkit-appearance: none; margin: 0; }
  .plinko .row{display:flex;gap:10px;margin-bottom:10px;flex-wrap:wrap}
  .plinko .slots{display:flex;gap:6px;margin-top:6px}
  .plinko .slot{flex:1;text-align:center;border:1px dashed #2a4d38;border-radius:8px;padding:8px}
  .plinko .slot.jack{border-color:#8a6a1a;background:rgba(138,106,26,.08)}
  .plinko .note{color:#9fb4a7;font-size:12px}

  /* ðŸŽ° Buttons (scoped) */
  .plinko .btn {
    font-family: inherit;
    font-weight: 800;
    font-size: 1.05rem;
    padding: 14px 22px;
    border-radius: 12px;
    border: none;
    cursor: pointer;
    transition: all .15s ease;
    box-shadow: 0 6px 0 var(--shadow);
    letter-spacing: .2px;
  }
  /* ðŸ’š Green Button */
  .plinko .btn.green {
    background: linear-gradient(180deg,#1b653a 0%,#124c2c 100%);
    border: 1px solid #2fbf6b;
    color: #baf2cd;
    box-shadow: 0 4px 0 #0e331f;
  }
  .plinko .btn.green:hover { filter: brightness(1.12); }
  .plinko .btn.green:active { transform: translateY(1px); box-shadow: 0 3px 0 #0e331f; }

  /* ðŸŸ¡ Gold Button (Dice-matched) */
  .plinko .btn.gold {
    background: linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);
    color:#08130d;
    border:0;
    box-shadow:0 4px 0 #b08a19;
  }
  .plinko .btn.gold:hover{ filter:brightness(1.05); box-shadow:0 4px 0 #b08a19, 0 14px 28px rgba(255,225,117,.22); }
  .plinko .btn.gold:active{ transform:translateY(1px); box-shadow:0 3px 0 #9a7315; }

  /* Exact Dice sizes for these buttons */
  .plinko #btnConnect{ padding:10px 14px; font-weight:800; border-radius:12px; }
  .plinko #btnSession{ padding:8px 12px; font-weight:800; border-radius:10px; box-shadow:0 3px 0 #b08a19; }

  .plinko header button.btn{ min-width:150px }

  /* ðŸ”„ Smaller Auto-Demo button */
  .plinko #btnAuto {
    font-size: 0.85rem;
    font-weight: 700;
    padding: 6px 12px;
    border-radius: 8px;
    min-width: unset;
    box-shadow: 0 3px 0 #0e331f;
  }
  .plinko #btnAuto:hover { filter: brightness(1.12); }
  .plinko #btnAuto:active { transform: translateY(1px); box-shadow: 0 2px 0 #0e331f; }
</style>
</head>
<body>

<!-- ðŸ”™ Back to Casino -->
<a href="/casino/" class="back-casino">â¬… Back to Casino</a>

<main class="plinko">
  <!-- Centered art banner -->
  <div class="top-banner"><img src="/assets/bag-plinko.png" alt="$BAG PLINKO"></div>

  <header>
    <div></div>
    <div class="h-center">
      <button id="btnAuto" class="btn green" title="Auto drops every 2s">Auto-Demo: Off</button>
    </div>
    <div class="h-right">
      <button id="btnConnect" class="btn gold">Connect Xaman</button>
      <button id="btnSession" class="btn gold">Start Session</button>
    </div>
  </header>

  <div class="grid">
    <section class="panel stage">
      <div class="canvas-wrap">
        <canvas id="game"></canvas>
        <div class="hud">
          <span class="pill">Mode: <b id="modeLbl">Demo</b></span>
          <span class="pill">Balance: <b id="balLbl">100.00</b> <span id="ccyLbl">XRP</span></span>
          <span class="pill">Bet: <b id="betLbl">1</b></span>
          <span class="pill">Last: <b id="lastLbl">â€”</b></span>
        </div>
        <div id="cele" class="cele"></div>
      </div>
    </section>

    <aside class="panel">
      <div class="row">
        <div style="flex:1">
          <label for="stake">Stake</label>
          <!-- âœ… phone keypad -->
          <input id="stake" type="tel" inputmode="numeric" pattern="[0-9]*" autocomplete="off" placeholder="1" value="1">
        </div>
        <div style="width:140px">
          <label for="currency">Currency</label>
          <select id="currency"><option value="XRP">XRP</option><option value="BAG">$BAG</option></select>
        </div>
      </div>
      <div class="row">
        <button id="btnDrop" class="btn green" style="flex:1">Drop Coin</button>
        <button id="btnCashout" class="btn gold" style="width:150px">Cash Out</button>
      </div>

      <h3>Payouts</h3>
      <div class="slots">
        <div class="slot"><b>Scratch</b><br><span style="color:#aeb7af">Lose</span></div>
        <div class="slot"><b>1.2Ã—</b><br><span style="color:#aeb7af">Instant Win</span></div>
        <div class="slot jack"><b>2Ã—</b><br><span style="color:#aeb7af">Jackpot</span></div>
      </div>
      <p class="note">Minimum bet $1. Demo always works. Connected mode uses your server RNG and settles on-ledger.</p>
    </aside>
  </div>
</main>

<script>
(() => {
  // ====== CONFIG (Option 3) ======
  const PAY_MAP = ['L', 1.2, 'L', 2, 'L', 1.2, 'L']; // left -> right
  const SLOTS = PAY_MAP.length;      // 7
  const PEG_ROWS = 12, PEG_COLS = 11;

  // Physics tuned + anti-stick
  const GRAVITY = 0.36, RESTITUTION = 0.78, FRICTION = 0.997;
  const PEG_R = 6, BALL_R = 9, WALL_PAD = 16;

  // ====== STATE ======
  let mode='Demo', balance=100, stake=1, currency='XRP', lastTxt='â€”';
  let dropping=false, ball=null, dropStartedAt=0, dropKillTimer=null;

  // ====== AUDIO ======
  const SND = {
    peg:   '/assets/audio/peg.mp3',   // optional; we'll fall back to synth
    drop:  '/assets/audio/drop.mp3',
    win:   '/assets/audio/win.mp3',
    jack:  '/assets/audio/jackpot.mp3',
    lose:  '/assets/audio/lose.mp3'
  };
  let audio=null, audioUnlocked=false, lastPegTs=0;
  function unlockAudio(){ if(audioUnlocked) return; try{ audio = new (window.AudioContext||window.webkitAudioContext)(); audioUnlocked=true; }catch{} }
  document.addEventListener('pointerdown', unlockAudio, {once:true});

  async function play(kind){
    try{
      if(audio && SND[kind]){
        const r = await fetch(SND[kind], {cache:'no-store'}); if(r.ok){
          const b = await r.arrayBuffer(); const buf = await audio.decodeAudioData(b);
          const src = audio.createBufferSource(); src.buffer = buf;
          const g = audio.createGain();
          g.gain.value = (kind==='peg'?0.06:(kind==='drop'?0.12:0.16));
          src.connect(g).connect(audio.destination); src.start(); return;
        }
      }
    }catch{}
    if(!audio) return;
    const now = audio.currentTime;
    const o = audio.createOscillator();
    const g = audio.createGain();
    o.type='sine';
    let freq = 420;
    if(kind==='drop') freq = 240;
    else if(kind==='win') freq = 760;
    else if(kind==='jack') freq = 950;
    else if(kind==='lose') freq = 180;
    o.frequency.value = freq + (Math.random()*14-7);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(kind==='peg'?0.045:0.09, now + 0.012);
    g.gain.exponentialRampToValueAtTime(0.0001, now + (kind==='peg'?0.08:0.18));
    o.connect(g).connect(audio.destination);
    o.start(now); o.stop(now + (kind==='peg'?0.09:0.2));
  }

  // ====== CANVAS & BOARD GEO ======
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const W=640, H=880; canvas.width=W; canvas.height=H;

  const leftWall=WALL_PAD, rightWall=W-WALL_PAD;
  const topBoard=110, bottomBoard=H-120;

  const pegSpacingX=(rightWall-leftWall-40)/(PEG_COLS-1);
  const pegSpacingY=(bottomBoard-topBoard-100)/(PEG_ROWS-1);

  const pegs=[];
  for(let r=0;r<PEG_ROWS;r++){
    const off=(r%2===0)?0:pegSpacingX/2;
    for(let c=0;c<PEG_COLS;c++){
      let x=leftWall+20+c*pegSpacingX+off;
      if(x<=leftWall+PEG_R || x>=rightWall-PEG_R) continue;
      let y=topBoard+r*pegSpacingY;
      pegs.push({x,y,r:PEG_R});
    }
  }

  const slotTop=bottomBoard+10;
  const slotWidth=(rightWall-leftWall)/SLOTS;
  const slotX=i=>leftWall+i*slotWidth;
  const slotCenters=Array.from({length:SLOTS},(_,i)=>slotX(i)+slotWidth/2);

  // ====== UI ======
  const $=id=>document.getElementById(id);
  const modeLbl=$('modeLbl'), balLbl=$('balLbl'), ccyLbl=$('ccyLbl'), betLbl=$('betLbl'), lastLbl=$('lastLbl');

  function sanitizeStakeInput(el){
    const digits = (el.value||'').replace(/[^\d]/g,'');
    el.value = digits;
    const v = Math.max(1, Number(digits||'1'));
    stake = v; betLbl.textContent = String(stake);
  }

  $('currency').onchange=e=>{currency=e.target.value; ccyLbl.textContent=currency;};
  const stakeEl = $('stake');
  stakeEl.addEventListener('input',()=>sanitizeStakeInput(stakeEl));
  stakeEl.addEventListener('blur',()=>sanitizeStakeInput(stakeEl));

  $('btnDrop').onclick=()=>{ unlockAudio(); startDrop(); };
  $('btnCashout').onclick=()=>toast('Cash out wired later');
  $('btnConnect').onclick=()=>toast('Xaman wired later');
  $('btnSession').onclick=()=>{mode='Connected'; modeLbl.textContent=mode; toast('Session started (demo mirror)');};

  $('btnAuto').onclick=(()=>{
    let timer=null;
    return ()=>{ unlockAudio();
      if(timer){clearInterval(timer); timer=null; $('btnAuto').textContent='Auto-Demo: Off'; return;}
      $('btnAuto').textContent='Auto-Demo: On'; if(!dropping) startDrop(); timer=setInterval(()=>{if(!dropping) startDrop();},2000);
    };
  })();

  function hud(){ balLbl.textContent=balance.toFixed(2); ccyLbl.textContent=currency; betLbl.textContent=String(stake); lastLbl.textContent=lastTxt; }

  function startDrop(){
    if(dropping) return;
    if(balance<stake){ toast('Insufficient demo funds'); return; }
    balance -= stake; lastTxt='â€”'; hud();
    ball = {x:W/2, y:60, vx:(Math.random()-.5)*0.25, vy:0, r:BALL_R, alive:true, frames:0};
    dropStartedAt = performance.now();
    dropping=true;
    clearTimeout(dropKillTimer);
    // more generous timeout so the ball reaches the slots naturally
    dropKillTimer = setTimeout(()=>{ if (dropping) forceResolve('timeout'); }, 9000);
    play('drop');
  }

  // ====== LOOP (never stops) + gentle watchdog ======
  let lastTs=performance.now();
  (function loop(ts){
    drawBoard();
    if(ball && ball.alive){
      stepBall(ts);
      drawBall(ball.x, ball.y);
      // only force if completely off-screen or ridiculously long
      if(ball.y > H + 140 || ts - dropStartedAt > 12000){ forceResolve('watchdog'); }
    }
    lastTs=ts; requestAnimationFrame(loop);
  })(lastTs);

  // healer: if a drop ended but state didn't unlock, fix it
  setInterval(()=>{
    if (dropping && (!ball || !ball.alive)) dropping=false;
  }, 600);

  function stepBall(ts){
    ball.frames++;

    // integrate
    ball.vy += GRAVITY;
    ball.x += ball.vx; ball.y += ball.vy;
    ball.vx *= FRICTION; ball.vy *= FRICTION;

    // walls
    if(ball.x - BALL_R < leftWall){ ball.x = leftWall + BALL_R; ball.vx = Math.abs(ball.vx)*RESTITUTION; }
    if(ball.x + BALL_R > rightWall){ ball.x = rightWall - BALL_R; ball.vx = -Math.abs(ball.vx)*RESTITUTION; }
    if(ball.y - BALL_R < 0){ ball.y = BALL_R; ball.vy = 0; }

    // pegs (with throttled soft knocks)
    for(const p of pegs){
      const dx=ball.x-p.x, dy=ball.y-p.y;
      const dist=Math.hypot(dx,dy) || 0.0001;
      const minD=BALL_R + p.r;
      if(dist < minD){
        const nx = dx / dist, ny = dy / dist;
        const overlap = (minD - dist) + 0.25;
        ball.x += nx * overlap; ball.y += ny * overlap;
        const vDotN = ball.vx*nx + ball.vy*ny;
        ball.vx = (ball.vx - 2*vDotN*nx) * RESTITUTION;
        ball.vy = (ball.vy - 2*vDotN*ny) * RESTITUTION;

        // anti-stick jitter
        const speed = Math.hypot(ball.vx, ball.vy);
        if(speed < 0.22){ ball.vx += (Math.random()-.5)*0.65; ball.vy += 0.45; }

        // subtle knock, max ~20 Hz
        const nowMs = performance.now();
        if (nowMs - lastPegTs > 50){ lastPegTs = nowMs; play('peg'); }
      }
    }

    // finish zone: let it actually enter the slots
    if(ball.y + BALL_R >= bottomBoard){
      // friction near floor
      ball.vy = Math.max(ball.vy*0.96, 0.10);
      // resolve when it crosses well into the slot area and is low enough
      const fullyInSlots = ball.y >= (bottomBoard + 64);
      if(fullyInSlots){ forceResolve('reached-slots'); }
    }
  }

  function forceResolve(reason){
    if (!ball) { dropping=false; clearTimeout(dropKillTimer); return; }
    const idx = Math.min(SLOTS-1, Math.max(0, Math.floor((ball.x-leftWall)/slotWidth)));
    resolveDrop(idx);
    // full reset & unlock
    ball.alive=false;
    ball=null; dropping=false;
    clearTimeout(dropKillTimer);
  }

  // ====== RENDER ======
  function drawBoard(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle='#0b1b13'; ctx.fillRect(0,0,W,H);

    // frame box
    ctx.strokeStyle='#1c3b27'; ctx.lineWidth=4;
    ctx.strokeRect(leftWall-8, topBoard-40, rightWall-leftWall+16, bottomBoard-topBoard+60);

    // pegs
    ctx.fillStyle='#704d1d';
    for(const p of pegs){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); }

    // floor & dividers
    ctx.strokeStyle='#2a4d38'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(leftWall, bottomBoard); ctx.lineTo(rightWall, bottomBoard); ctx.stroke();
    for(let i=1;i<SLOTS;i++){
      const x = slotX(i);
      ctx.beginPath(); ctx.moveTo(x, bottomBoard); ctx.lineTo(x, bottomBoard+50); ctx.stroke();
    }

    // labels
    ctx.font='14px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.textAlign='center';
    for(let i=0;i<SLOTS;i++){
      const rule = PAY_MAP[i];
      const txt = rule==='L' ? 'Scratch' : (rule===2 ? '2Ã—' : '1.2Ã—');
      ctx.fillStyle = rule==='L' ? '#e25b5b' : (rule===2 ? '#ffd700' : '#baf2cd');
      ctx.fillText(txt, slotCenters[i], bottomBoard+72);
    }
  }

  function drawBall(x,y){
    const r=BALL_R;
    const g=ctx.createRadialGradient(x-4,y-4,2,x,y,r);
    g.addColorStop(0,'#ffd36d'); g.addColorStop(.6,'#c8911e'); g.addColorStop(1,'#8b5e13');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  // ====== RESOLVE / CELEBRATE ======
  const cele=document.getElementById('cele');
  function resolveDrop(slot){
    const rule = PAY_MAP[slot] ?? 'L';
    if(rule==='L'){ lastTxt='Scratch'; showCele('SCRATCH'); play('lose'); hud(); return; }
    const mult = Number(rule);
    const payout = Math.floor(stake * mult * 100)/100;
    balance += payout; hud();
    if(mult===2){ lastTxt='Jackpot 2Ã—'; showCele('JACKPOT 2Ã—'); play('jack'); }
    else { lastTxt='Win 1.2Ã—'; showCele('WIN 1.2Ã—'); play('win'); }
  }
  function showCele(text){
    cele.textContent=text; cele.classList.remove('show'); void cele.offsetWidth; cele.classList.add('show');
    setTimeout(()=>cele.classList.remove('show'),1100);
  }

  // ====== HELPERS ======
  function toast(msg){
    const t=document.createElement('div'); t.textContent=msg;
    Object.assign(t.style,{position:'fixed',bottom:'20px',left:'50%',transform:'translateX(-50%)',
      background:'#0a1e15',color:'#fff',border:'1px solid #244330',padding:'10px 14px',borderRadius:'10px',zIndex:9999});
    document.body.appendChild(t); setTimeout(()=>t.remove(),1500);
  }

  // Prevent pinch-zoom / gesture zoom (extra guard)
  window.addEventListener('gesturestart', (e)=>{ e.preventDefault(); }, {passive:false});

  // HUD once
  hud();
})();
</script>
</body>
</html>
