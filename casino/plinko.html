<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>$BAG Plinko</title>

<link rel="preconnect" href="https://api.coingecko.com" crossorigin>
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>

<style>
  *{box-sizing:border-box}
  :root{
    --gold:#ffd700;--bg:#020703;--panel:#0b1b13;--panel2:#0d2217;--muted:#aeb7af;--fg:#f5f7f4;
    --green:#2fbf6b;--green2:#34c759;--line:#173524;--shadow:rgba(0,0,0,.35);
    --red:#e25b5b;
  }
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.55}
  img{display:block;max-width:100%;height:auto}
  button,input{font-size:16px}

  /* üîô Back to Casino button (unchanged) */
  .back-casino {
    position: fixed;
    top: 18px;
    left: 18px;
    z-index: 1000;
    background: linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);
    color: #08130d;
    text-decoration: none;
    font-weight: 800;
    padding: 8px 14px;
    border-radius: 10px;
    box-shadow: 0 4px 0 #b08a19;
    transition: all .15s ease;
  }
  .back-casino:hover {
    filter: brightness(1.05);
    box-shadow: 0 4px 0 #b08a19, 0 14px 28px rgba(255,225,117,.22);
  }
  .back-casino:active {
    transform: translateY(1px);
    box-shadow: 0 3px 0 #9a7315;
  }
  @media (max-width: 640px){
    .back-casino{ font-size:.9rem; padding:7px 12px; }
  }

  /* Game header */
  .game-header{text-align:center;padding:36px 10px 14px}
  .game-header img.hero-img{margin-bottom:10px;filter:drop-shadow(0 10px 24px rgba(46,191,107,.18))}
  .game-header h2{font-size:clamp(1.6rem,5vw,2.2rem);margin:6px 0 0}

  /* Desktop-only: hero size */
  @media (min-width: 900px){
    .game-header img.hero-img{
      width: 34vw;
      max-width: 420px;
      margin-left: auto;
      margin-right: auto;
    }
  }

  /* Game area (mirrors Dice scaffolding) */
  .game-teaser{padding:10px 16px 60px;background:
    radial-gradient(1200px 600px at 10% -10%, #0e2c1d 0%, transparent 60%),
    radial-gradient(900px 500px at 110% 20%, #0b2318 0%, transparent 55%),#060806;
    border-top:1px solid #131313;border-bottom:1px solid #131313}
  .game-wrap{max-width:1080px;margin:0 auto;display:grid;grid-template-columns:1.12fr .88fr;gap:22px}
  @media (max-width:900px){.game-wrap{grid-template-columns:1fr}}

  .panel{background:linear-gradient(180deg,var(--panel) 0%,var(--panel2) 100%);border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 24px var(--shadow)}
  .mock{padding:16px}

  .section-title{font-weight:800;font-size:1.2rem;margin:0 0 12px}

  .stake-box{padding:14px}
  .stack{display:grid;gap:10px}
  .choice{display:flex;gap:10px;flex-wrap:wrap}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;border:1px solid #2b6a48;background:#0e2a1c;color:#e9efe9;font-weight:800}
  .chip input{accent-color:#2fbf6b}
  .mono{font-variant-numeric:tabular-nums}
  .micro{font-size:.85rem;color:#a8b5ab}
  .muted{color:#cfd6cf}
  .divider{height:1px;background:#123221;margin:10px 0}

  .callout{margin-top:12px;padding:12px;border:1px dashed #29543d;border-radius:12px;background:#0c2418;color:#e4efe7}
  .payout-grid{display:grid;gap:4px}
  .payout-grid .row{display:flex;justify-content:space-between}
  .payout-grid .lab{color:#cfd6cf}
  .payout-grid .val{font-variant-numeric:tabular-nums}

  /* Primary CTA (same as Dice ‚ÄúRoll‚Äù) */
  .btn-primary{
    width:100%;margin-top:12px;padding:16px 22px;font-size:1.15rem;font-weight:900;text-transform:uppercase;
    letter-spacing:.5px;border:0;border-radius:14px;color:#08130d;background:linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);
    box-shadow:0 6px 0 #b08a19, 0 16px 32px rgba(255,225,117,.18), inset 0 1px 0 rgba(255,255,255,.35);
    transition:transform .06s ease, box-shadow .2s ease, filter .2s ease; cursor:pointer;
  }
  .btn-primary:hover{filter:brightness(1.05);box-shadow:0 6px 0 #b08a19, 0 22px 40px rgba(255,225,117,.26), inset 0 1px 0 rgba(255,255,255,.4)}
  .btn-primary:active{transform:translateY(2px);box-shadow:0 4px 0 #9a7315, 0 12px 24px rgba(255,225,117,.2), inset 0 1px 0 rgba(255,255,255,.3)}
  .btn-primary:disabled{opacity:.65;cursor:not-allowed;transform:none;box-shadow:0 6px 0 #6e6e6e, 0 10px 20px rgba(0,0,0,.2)!important}

  /* Plinko canvas area */
  .plinko-area{margin-top:12px;display:flex;justify-content:center;align-items:center}
  .canvas-wrap{position:relative;width:100%;max-width:640px;aspect-ratio:8/11}
  canvas{position:absolute;inset:0;width:100%;height:100%}

  .result{margin-top:12px;padding:12px;border:1px solid #1b4a2f;border-radius:12px;background:#0b2217;display:flex;align-items:center;gap:10px}
  .result .n{font-weight:900;font-size:1.25rem}
  .ok{color:#2fbf6b}.warn{color:#e8a85c}.err{color:#e25b5b}
  .t.win{color:#2fbf6b}.t.lose{color:#e25b5b}

  /* WIN overlay (same as Dice) */
  :root{ --win-fg:#fff; --win-glow:#00ffb2; --win-accent:#18a0fb; --win-bg: rgba(10,12,16,.70); }
  #win-overlay{ position:fixed; inset:0; display:none; place-items:center; background:radial-gradient(60% 60% at 50% 50%, rgba(24,160,251,.28), transparent 70%), var(--win-bg); z-index:2147483647; backdrop-filter:saturate(120%) blur(2px); }
  #win-card{ position:relative; text-align:center; padding:24px 32px; border-radius:16px; background:rgba(0,0,0,.35); box-shadow:0 10px 40px rgba(0,0,0,.45), inset 0 0 80px rgba(0,255,200,.06); transform:scale(.9); opacity:0; animation:win-pop .35s cubic-bezier(.2,.9,.2,1) forwards, win-float 1.8s ease-in-out .35s infinite; }
  #win-text{ font: 900 64px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; letter-spacing:.06em; background:linear-gradient(90deg, #fff, var(--win-glow), #fff); -webkit-background-clip:text; background-clip:text; color:transparent; text-shadow: 0 0 18px rgba(0,255,178,.35), 0 0 48px rgba(0,255,178,.25); filter:drop-shadow(0 4px 10px rgba(0,0,0,.35)); animation:shine 1.6s linear infinite; white-space:nowrap; }
  #win-sub{ margin-top:8px; color:#e7f6ff; opacity:.9; font: 600 16px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
  #win-close{ position:absolute; top:8px; right:10px; border:0; background:transparent; color:#cfeaff; font:700 20px/1 system-ui; cursor:pointer; padding:6px 8px; opacity:.7; }
  #win-canvas{ position:fixed; inset:0; pointer-events:none; z-index:2147483646; display:none; }
  @keyframes win-pop{ to{ transform:scale(1); opacity:1; } }
  @keyframes win-float{ 0%,100%{ transform:translateY(0) } 50%{ transform:translateY(-6px) } }
  @keyframes shine{ 0%{ background-position:0% 50% } 100%{ background-position:200% 50% } }
  @media (prefers-reduced-motion: reduce){ #win-card{ animation:none; transform:none; opacity:1; } #win-text{ animation:none; } }
</style>
</head>
<body>

<!-- üîô Back to Casino -->
<a href="/casino/" class="back-casino">‚¨Ö Back to Casino</a>

<!-- Game header -->
<section class="game-header">
  <img src="/assets/bag-plinko.png" alt="$BAG Plinko" class="hero-img">
  <h2>ü™ô $BAG Plinko</h2>
  <p class="micro" style="margin-top:4px;opacity:.9;">
    üí∞ <strong>All payouts are in $BAG.</strong> XRP bets convert automatically at the live rate.
  </p>
</section>

<section class="game-teaser" aria-labelledby="game-teaser-title">
  <div class="game-wrap">

    <!-- LEFT: Demo & stake (mirrors Dice left panel) -->
    <div class="panel mock" id="bagPlinkoDemo">
      <div id="demo-badge" style="display:none;position:relative;margin:6px 0 10px 0;font:600 12px/1 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;letter-spacing:.3px;">
        <span style="padding:6px 10px;border:1px solid #aaa;border-radius:6px;opacity:.9;">PRACTICE MODE ‚Äî No real bets or payouts</span>
      </div>

      <!-- CONNECT -->
      <div id="connectRow" style="display:flex;justify-content:space-between;align-items:center;margin:-2px 0 10px 0;">
        <div id="connectStatus" class="micro" style="opacity:.9">Wallet: <span style="color:#e8a85c">not connected</span></div>
        <button id="connectBtn"
          style="padding:10px 14px;font-weight:800;border:0;border-radius:12px;color:#08130d;background:linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);box-shadow:0 4px 0 #b08a19;cursor:pointer;">
          Connect Xaman
        </button>
      </div>

      <!-- SESSION -->
      <div id="sessionRow" style="display:flex;justify-content:space-between;align-items:center;margin:6px 0 10px 0;">
        <div id="sessionStatus" class="micro" style="opacity:.9">Session: <span style="color:#e8a85c">not started</span></div>
        <div style="display:flex;gap:8px;align-items:center">
          <button id="startSessionBtn" style="padding:8px 12px;font-weight:800;border:0;border-radius:10px;color:#08130d;background:linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);box-shadow:0 3px 0 #b08a19;cursor:pointer;">Start Session</button>
          <button id="topUpBtn" style="padding:8px 12px;font-weight:800;border:0;border-radius:10px;color:#08130d;background:linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);box-shadow:0 3px 0 #b08a19;cursor:pointer;display:none;">Top Up</button>
          <button id="endSessionBtn" style="padding:8px 12px;font-weight:800;border:0;border-radius:10px;background:#15261c;color:#dfe9e2;border:1px solid #2b6a48;cursor:pointer;display:none;">End</button>
        </div>
      </div>

      <div class="section-title">Stake & Prices</div>

      <div class="stake-box">
        <div class="stack">
          <div>
            <div class="micro">Bet currency</div>
            <div class="choice" id="curToggle">
              <label class="chip"><input type="radio" name="betCur" value="XRP" checked> XRP</label>
              <label class="chip"><input type="radio" name="betCur" value="BAG"> BAG</label>
            </div>
          </div>

          <div>
            <div class="micro">Bet amount</div>
            <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
              <div>
                <!-- phone keypad & min/max handled in JS -->
                <input id="demoBet" class="mono" type="number" min="0" step="any" value="1"
                  style="width:140px;background:#0b2217;border:1px solid #1b4a2f;border-radius:10px;color:#f3f5f0;padding:10px">
                <span class="unit">XRP</span>
              </div>
              <div style="display:flex;align-items:center;gap:6px">
                <span class="micro" aria-hidden="true">USD</span>
                <input id="usdBet" class="mono" type="number" inputmode="decimal" pattern="[0-9]*"
                  min="0" max="2000" step="0.01" placeholder="0.00"
                  style="width:140px;background:#0b2217;border:1px solid #1b4a2f;border-radius:10px;color:#f3f5f0;padding:10px">
              </div>
            </div>
          </div>

          <div class="divider"></div>

          <div class="micro">Game state</div>
          <div class="muted" id="stateText">Drop a coin ‚Äî 1.2√ó or 2√ó pays ¬∑ Scratch loses</div>

          <div class="divider"></div>

          <div class="micro">Live prices</div>
          <div class="muted mono" id="liveLine">
            <span id="liveDot" class="warn">‚óè</span>
            <span> BAG $<span id="liveBAG">‚Äî</span> ¬∑ XRP $<span id="liveXRP">‚Äî</span> <span id="liveNote"></span></span>
            <div class="micro" id="liveConv" style="margin-top:4px;opacity:.9;">1 BAG ‚âà ‚Äî XRP ¬∑ 1 XRP ‚âà ‚Äî BAG</div>
            <div id="bagDiag" class="micro" style="opacity:.55;margin-top:4px;"></div>
          </div>

          <div class="callout mono" id="payoutBox">
            <div class="payout-grid">
              <div class="row"><div class="lab"><strong>Win (1.20√ó):</strong></div><div class="val" id="payoutWin">‚Äî <span class="micro" id="payoutWinGain" style="opacity:.9"></span></div></div>
              <div class="row"><div class="lab"><strong>Jackpot (2.00√ó):</strong></div><div class="val" id="payoutJackpot">‚Äî <span class="micro" id="payoutJackpotGain" style="opacity:.9"></span></div></div>
            </div>
            <div class="micro" style="margin-top:6px;opacity:.85;">Plinko board: 7 slots (L‚ÜíR). Center is 2√ó.</div>
          </div>

          <button id="dropBtn" class="btn-primary">Drop</button>

          <div class="micro" style="text-align:center;opacity:.7;margin-top:6px">
            If you don‚Äôt hear sound: tap Drop once, turn off Silent mode, and raise volume.
          </div>

          <div class="plinko-area">
            <div class="canvas-wrap">
              <canvas id="plinko"></canvas>
            </div>
          </div>

          <div class="result">
            <div class="n" id="lastOutcome">‚Äî</div>
            <div class="t" id="statusText">Tap Drop</div>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT: Rules -->
    <div class="panel" style="padding:16px">
      <h3 style="margin:0 0 8px;font-size:1.2rem;">How it plays</h3>
      <ul style="margin:0;padding-left:18px;color:#cfd6cf">
        <li><b>Drop:</b> your coin bounces through pegs into 1 of 7 slots.</li>
        <li><b>Slots:</b> ‚ÄúScratch‚Äù loses ¬∑ ‚Äú1.2√ó‚Äù pays 1.20√ó ¬∑ middle ‚Äú2√ó‚Äù pays 2.00√ó.</li>
      </ul>

      <h4 style="margin:12px 0 6px;">Payouts:</h4>
      <ul style="margin:0;padding-left:18px;color:#cfd6cf">
        <li><b>Win 1.2√ó:</b> +0.20√ó gain.</li>
        <li><b>Jackpot 2√ó:</b> +1.00√ó gain.</li>
      </ul>

      <p class="micro" style="margin-top:10px">No wallet connection yet. Visual demo only while development continues.</p>
    </div>

  </div>
</section>

<!-- WIN overlay -->
<canvas id="win-canvas"></canvas>
<div id="win-overlay" role="dialog" aria-live="polite" aria-label="Win notification">
  <div id="win-card">
    <button id="win-close" aria-label="Close">√ó</button>
    <div id="win-text">WIN</div>
    <div id="win-sub">Nice drop</div>
  </div>
</div>

<!-- AUDIO ENGINE (same as Dice; we‚Äôll reuse chime/nudge balance) -->
<script>
(function(){
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let AC = null, MASTER = null, lastInteractTs = 0, watchdogTimer = null;
  function makeAC(){ if(!AudioCtx) return null; const ac=new AudioCtx(); const master=ac.createGain(); master.gain.value=0.22; master.connect(ac.destination); AC=ac; MASTER=master; ac.onstatechange=function(){ if(ac.state==='suspended') tryResume(); }; return ac; }
  function getAC(){ if(AC && AC.state!=='closed') return AC; return makeAC(); }
  function silentTick(ac){ const o=ac.createOscillator(); const g=ac.createGain(); g.gain.value=0.00001; o.connect(g).connect(MASTER); o.start(); o.stop(ac.currentTime+0.01); }
  async function tryResume(){ const ac=getAC(); if(!ac) return; if(ac.state==='suspended'){ try{await ac.resume();}catch(e){} } if(ac.state==='running'){ silentTick(ac); } }
  function markInteract(){ lastInteractTs=Date.now(); tryResume(); }
  async function ensureInteractive(){ const ac=getAC(); if(!ac) return null; if(ac.state!=='running'){ await tryResume(); } return ac; }
  function makeNoise(ac,dur=0.08){ const len=Math.max(1,Math.floor(dur*ac.sampleRate)); const buf=ac.createBuffer(1,len,ac.sampleRate); const data=buf.getChannelData(0); for(let i=0;i<len;i++) data[i]=(Math.random()*2-1)*0.9; const src=ac.createBufferSource(); src.buffer=buf; const bp=ac.createBiquadFilter(); bp.type='bandpass'; bp.frequency.value=1200; bp.Q.value=2.0; const g=ac.createGain(); g.gain.value=0; src.connect(bp).connect(g); return {src,g}; }
  function chime(){ const ac=getAC(); if(!ac) return; if(ac.state!=='running'){ tryResume(); return; } const now=ac.currentTime; const notes=[880,1175,1760]; notes.forEach((f,i)=>{ const o=ac.createOscillator(); const g=ac.createGain(); o.type='triangle'; o.frequency.value=f; g.gain.setValueAtTime(0.0001,now+i*0.02); g.gain.linearRampToValueAtTime(0.18,now+i*0.02+0.03); g.gain.exponentialRampToValueAtTime(0.0001,now+i*0.02+0.28); o.connect(g).connect(MASTER); o.start(now+i*0.02); o.stop(now+i*0.02+0.3); }); }
  function nudge(){ const ac=getAC(); if(!ac) return; if(ac.state!=='running'){ tryResume(); return; } const now=ac.currentTime; const comp=ac.createDynamicsCompressor(); comp.threshold.value=-26; comp.knee.value=16; comp.ratio.value=3.5; comp.attack.value=0.003; comp.release.value=0.08; comp.connect(MASTER); const {src:nSrc,g:nGain}=makeNoise(ac,0.06); nGain.connect(comp); nGain.gain.setValueAtTime(0.0001,now); nGain.gain.linearRampToValueAtTime(0.12,now+0.008); nGain.gain.exponentialRampToValueAtTime(0.0001,now+0.08); nSrc.start(now); nSrc.stop(now+0.09); const o=ac.createOscillator(); const g=ac.createGain(); o.type='sine'; o.frequency.setValueAtTime(420,now); o.frequency.exponentialRampToValueAtTime(200,now+0.18); g.gain.setValueAtTime(0.0001,now); g.gain.linearRampToValueAtTime(0.10,now+0.02); g.gain.exponentialRampToValueAtTime(0.0001,now+0.22); o.connect(g).connect(comp); o.start(now); o.stop(now+0.24); }
  const INTERACT_EVENTS=['pointerdown','mousedown','touchstart','keydown','click']; INTERACT_EVENTS.forEach(ev=>addEventListener(ev,markInteract,{passive:true,capture:true})); addEventListener('visibilitychange',()=>{ if(!document.hidden) tryResume(); }); addEventListener('pageshow',()=>{ tryResume(); }); addEventListener('focus',()=>{ tryResume(); });
  function startWatchdog(){ if(watchdogTimer) return; watchdogTimer=setInterval(()=>{ const ac=AC; if(!ac) return; const active=Date.now()-lastInteractTs<30_000; if(active && ac.state==='suspended') tryResume(); },1500); } startWatchdog();
  window.__bagAudio={ensureInteractive,chime,nudge};
})();
</script>

<!-- WIN overlay logic (same as Dice) -->
<script>
(function(){
  const overlay=document.getElementById('win-overlay');
  const canvas=document.getElementById('win-canvas');
  const ctx=canvas.getContext('2d');
  const closeBtn=document.getElementById('win-close');
  const sub=document.getElementById('win-sub');
  const title=document.getElementById('win-text');
  let rafId=null, particles=[], start=0, dur=2000;
  function sizeCanvas(){ const dpr=Math.min(window.devicePixelRatio||1,2); canvas.width=Math.floor(innerWidth*dpr); canvas.height=Math.floor(innerHeight*dpr); canvas.style.width=innerWidth+'px'; canvas.style.height=innerHeight+'px'; ctx.setTransform(dpr,0,0,dpr,0,0); }
  sizeCanvas(); addEventListener('resize', sizeCanvas);
  function spawnConfetti(n){ particles.length=0; const colors=['#ffffff','#00ffb2','#18a0fb','#ffd166','#f72585']; for(let i=0;i<n;i++){ const x=innerWidth*0.25+Math.random()*innerWidth*0.5; const y=innerHeight*0.35+Math.random()*innerHeight*0.1; const speed=2+Math.random()*4; particles.push({ x,y, vx:(Math.random()-.5)*speed*1.2, vy:-(3+Math.random()*5), g:0.12+Math.random()*0.2, rot:Math.random()*6.28, vr:(Math.random()-.5)*0.2, sz:6+Math.random()*10, col:colors[(Math.random()*colors.length)|0], shape:Math.random()<.4?'circle':(Math.random()<.5?'square':'tri') }); } }
  function draw(){ ctx.clearRect(0,0,innerWidth,innerHeight); particles.forEach(p=>{ p.x+=p.vx; p.y+=p.vy; p.vy+=p.g; p.rot+=p.vr; ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot); ctx.fillStyle=p.col; const s=p.sz; if(p.shape==='circle'){ ctx.beginPath(); ctx.arc(0,0,s*0.6,0,Math.PI*2); ctx.fill(); } else if(p.shape==='square'){ ctx.fillRect(-s/2,-s/2,s,s); } else { ctx.beginPath(); ctx.moveTo(0,-s/1.2); ctx.lineTo(s/1.2,s/1.2); ctx.lineTo(-s/1.2,s/1.2); ctx.closePath(); ctx.fill(); } ctx.restore(); }); }
  function animate(ts){ if(!start) start=ts; draw(); if(ts-start<dur){ rafId=requestAnimationFrame(animate); } else { stop(); } }
  function startFx(){ if(matchMedia('(prefers-reduced-motion: reduce)').matches) return; start=0; dur=2200; canvas.style.display='block'; spawnConfetti(180); rafId=requestAnimationFrame(animate); }
  function stop(){ cancelAnimationFrame(rafId); ctx.clearRect(0,0,innerWidth,innerHeight); canvas.style.display='none'; }
  function show(){ overlay.style.display='grid'; addEventListener('keydown', e=>{ if(e.key==='Escape') hide(); }, {once:true}); }
  function hide(){ overlay.style.display='none'; stop(); }
  closeBtn.addEventListener('click', hide);
  overlay.addEventListener('click', e=>{ if(e.target===overlay) hide(); });
  window.showWin=function(opts={}){ const { message='WIN', subtext='Nice drop', duration=4000, sound=true }=opts; title.textContent=message; sub.textContent=subtext; show(); startFx(); if(sound){ try{ window.__bagAudio && __bagAudio.chime(); }catch(e){} } clearTimeout(window.__winTimer); window.__winTimer=setTimeout(hide, Math.max(1000,duration)); };
})();
</script>

<!-- Xaman wallet connect (same as Dice) -->
<script>
(function(){
  const WALLET_KEY = 'bag_wallet_v1';
  const API_KEY = '48d8a5b2-0f90-4c5a-b5c2-3d7c8fd6113f';

  const btn = document.getElementById('connectBtn');
  const statusEl = document.getElementById('connectStatus');
  if (!btn || !statusEl) return;

  const read  = () => { try { return JSON.parse(localStorage.getItem(WALLET_KEY)||'null'); } catch { return null; } };
  const write = (w) => { try { localStorage.setItem(WALLET_KEY, JSON.stringify(w)); } catch {} };
  const clear = () => { try { localStorage.removeItem(WALLET_KEY); } catch {} };

  function safeShort(a){
    try{ const s = a == null ? '' : String(a); if (!s) return ''; return s.slice(0,6) + '‚Ä¶' + s.slice(-4); }catch{ return ''; }
  }

  function render(){
    try{
      const w = read();
      if (w && w.address){
        statusEl.innerHTML = 'Wallet: <span style="color:#2fbf6b">'+safeShort(w.address)+'</span>';
        btn.textContent = 'Disconnect';
      } else {
        statusEl.innerHTML = 'Wallet: <span style="color:#e8a85c">not connected</span>';
        btn.textContent = 'Connect Xaman';
      }
    }catch(e){
      console.warn('[bag] render failed', e);
      statusEl.textContent = 'Wallet: error';
      btn.textContent = 'Connect Xaman';
    }
  }

  let xumm = null, ready = false, tries = 0;
  function initIfSdk(){
    if (ready) return true;
    if (typeof window.Xumm === 'function'){
      xumm = new Xumm(API_KEY);
      ready = true;

      const w = read();
      if (w?.address){
        window.dispatchEvent(new CustomEvent('bag:walletConnected', { detail: { address: String(w.address) }}));
      }

      xumm.on('success', () => {
        try{
          const acct = xumm?.user?.account || null;
          if (acct){
            write({ address: String(acct), ts: Date.now(), kind: 'xaman' });
            window.dispatchEvent(new CustomEvent('bag:walletConnected', { detail: { address: String(acct) }}));
            render();
          }
        }catch(e){ console.warn('[bag] success handler error', e); }
      });

      xumm.on('ready', () => { render(); });
      return true;
    }
    if (tries++ < 60) setTimeout(initIfSdk, 200);
    return false;
  }

  async function connectXaman(){
    if (!ready && !initIfSdk()){
      alert('Loading Xaman‚Ä¶ try again in a moment.');
      return;
    }
    btn.disabled = true;
    try {
      const auth = await xumm.authorize();
      const acct = (xumm && xumm.user && xumm.user.account) || auth?.me?.account || null;
      if (!acct) throw new Error('No account returned');
      write({ address: String(acct), ts: Date.now(), kind: 'xaman' });
      window.dispatchEvent(new CustomEvent('bag:walletConnected', { detail: { address: String(acct) }}));
      render();
    } catch (e) {
      console.warn('Xaman connect failed/cancelled', e);
    } finally {
      btn.disabled = false;
    }
  }

  btn.addEventListener('click', async ()=>{
    const w = read();
    if (w && w.address){
      clear();
      window.dispatchEvent(new CustomEvent('bag:walletDisconnected'));
      render();
    } else {
      await connectXaman();
    }
  });

  document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) render(); });

  render();
  initIfSdk();
})();
</script>

<!-- TAB SESSION (same as Dice) -->
<script>
(function(){
  const TREASURY = 'rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr';
  const SESSION_KEY = 'bag_session_v1';
  const MIN_DEPOSIT_USD = 1;
  const MAX_DEPOSIT_USD = 500;

  const $ = s => document.querySelector(s);
  const statusEl = $('#sessionStatus');
  const startBtn = $('#startSessionBtn');
  const topUpBtn = $('#topUpBtn');
  const endBtn = $('#endSessionBtn');

  const read = () => { try { return JSON.parse(localStorage.getItem(SESSION_KEY)||'null'); } catch { return null; } };
  const write = (v) => { try { localStorage.setItem(SESSION_KEY, JSON.stringify(v)); } catch {} };
  const clear = () => { try { localStorage.removeItem(SESSION_KEY); } catch {} };

  function fmt(n){
    if (!Number.isFinite(n)) return '‚Äî';
    if (Math.abs(n) >= 1) return n.toLocaleString(undefined, {maximumFractionDigits:4});
    if (Math.abs(n) >= 1e-2) return n.toLocaleString(undefined, {maximumFractionDigits:6});
    if (Math.abs(n) >= 1e-4) return n.toLocaleString(undefined, {maximumFractionDigits:8});
    return n.toLocaleString(undefined, {maximumFractionDigits:10});
  }
  function fmtUsd(n){ return '$'+(Number(n)||0).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}); }

  function sessionActive(){ const s = read(); return !!(s && s.addr && s.bag>0); }

  function render(){
    const s = read();
    if (s && s.addr){
      const bag = Number(s.bag)||0;
      const usd = (window.__PRICES__?.bagUsd||0) * bag;
      statusEl.innerHTML = 'Session: <span style="color:#2fbf6b">'+fmt(bag)+' BAG</span>' + (usd?` <span class="micro" style="opacity:.75">(${fmtUsd(usd)})</span>`:'');
      startBtn.style.display = 'none';
      if (topUpBtn) topUpBtn.style.display = 'inline-block';
      endBtn.style.display = 'inline-block';
    } else {
      statusEl.innerHTML = 'Session: <span style="color:#e8a85c">not started</span>';
      startBtn.style.display = 'inline-block';
      if (topUpBtn) topUpBtn.style.display = 'none';
      endBtn.style.display = 'none';
    }
  }

  function suggestDepositUsd(){
    const PRICES = window.__PRICES__ || {bagUsd:0,xrpUsd:0};
    const betEl = document.getElementById('usdBet');
    const u = betEl && parseFloat(betEl.value) > 0 ? parseFloat(betEl.value) : 5;
    let usd = Math.max(MIN_DEPOSIT_USD, Math.min(MAX_DEPOSIT_USD, u * 20));
    if (!Number.isFinite(usd)) usd = MIN_DEPOSIT_USD;
    return usd;
  }

  async function waitForTx(txid, timeoutMs=30000){
    return new Promise(resolve=>{
      const ws = new WebSocket('wss://s1.ripple.com');
      const t = setTimeout(()=>{ try{ws.close();}catch{}; resolve(null); }, timeoutMs);
      ws.onopen = ()=> ws.send(JSON.stringify({id:1, command:'tx', transaction: txid, binary:false}));
      ws.onmessage = (ev)=>{
        try{
          const msg = JSON.parse(ev.data);
          if (msg?.result?.hash === txid && msg?.result?.validated){
            clearTimeout(t); try{ws.close();}catch{}; resolve(msg.result);
          }
        }catch{}
      };
      ws.onerror = ()=>{ clearTimeout(t); try{ws.close();}catch{}; resolve(null); };
    });
  }

  async function startSession(){
    if (!window.Xumm){ alert('Xaman SDK not loaded'); return; }
    const PRICES = window.__PRICES__ || {};
    if (!(PRICES.xrpUsd>0 && PRICES.bagUsd>0)){ alert('Waiting for live prices ‚Äî try again in a few seconds.'); return; }
    const depositUsd = Math.max(1, suggestDepositUsd());
    const depositXrp = depositUsd / PRICES.xrpUsd;
    const drops = Math.round(depositXrp * 1_000_000);
    const w = JSON.parse(localStorage.getItem('bag_wallet_v1')||'null');
    if (!w || !w.address){ alert('Connect Xaman first'); return; }
    const xumm = new Xumm('48d8a5b2-0f90-4c5a-b5c2-3d7c8fd6113f');
    startBtn.disabled = true; startBtn.textContent = 'Opening‚Ä¶';
    try{
      const { created, resolved } = await xumm.payload.createAndSubscribe({
        txjson: { TransactionType:'Payment', Destination: TREASURY, Amount: String(drops),
          Memos:[{Memo:{MemoType:btoa('BAG'), MemoData:btoa('PLINKO_SESSION')}}] },
        options: { submit:true, expire:300 }
      }, ev => { if (ev?.data && 'signed' in ev.data) return ev; });
      const res = await resolved;
      if (!res?.signed) throw new Error('User declined in Xaman');
      const txid = res.response?.txid || res?.meta?.txid || res?.created?.reference;
      if (!txid) throw new Error('No txid returned');
      const validated = await waitForTx(txid, 60000);
      if (!validated || validated.engine_result !== 'tesSUCCESS'){ throw new Error('Payment not validated on-ledger yet'); }
      const bag = (depositUsd / PRICES.bagUsd);
      write({ addr: w.address, bag, ts: Date.now(), tx: txid });
      render();
      window.dispatchEvent(new CustomEvent('bag:sessionStarted', { detail: { bag, txid } }));
      alert('Session started ‚Äî you‚Äôre good to play!');
    } catch (err){
      console.error('[bag] startSession error', err);
      alert('Session not started: ' + (err?.message || 'unknown error ‚Äî see console'));
    } finally {
      startBtn.disabled = false; startBtn.textContent = 'Start Session';
    }
  }

  async function topUpSession(){
    if (!window.Xumm){ alert('Xaman SDK not loaded'); return; }
    const PRICES = window.__PRICES__ || {};
    if (!(PRICES.xrpUsd>0 && PRICES.bagUsd>0)){ alert('Waiting for live prices'); return; }
    const s = read();
    if (!(s && s.addr)){ alert('Start a session first.'); return; }
    const depositUsd = suggestDepositUsd();
    const depositXrp = depositUsd / PRICES.xrpUsd;
    const drops = Math.round(depositXrp * 1_000_000);
    const xumm = new Xumm('48d8a5b2-0f90-4c5a-b5c2-3d7c8fd6113f');
    if (topUpBtn) { topUpBtn.disabled = true; topUpBtn.textContent = 'Topping up‚Ä¶'; }
    try{
      const { created } = await xumm.payload.createAndSubscribe({
        txjson: { TransactionType:'Payment', Destination: TREASURY, Amount: String(drops),
          Memos:[{Memo:{MemoType:btoa('BAG'), MemoData:btoa('PLINKO_TOPUP')}}] },
        options: { submit:true, expire:300 }
      }, ()=>{});
      const resolved = await xumm.payload.get(created.uuid);
      const txid = resolved?.response?.txid || resolved?.meta?.txid;
      if (!txid) throw new Error('No txid (cancelled?)');
      const tx = await waitForTx(txid, 45000);
      if (!tx || tx.engine_result !== 'tesSUCCESS') throw new Error('Payment not validated');
      const addBag = (depositUsd / PRICES.bagUsd);
      const cur = read() || { addr: s.addr, bag: 0 };
      cur.bag = (Number(cur.bag)||0) + addBag; cur.ts = Date.now(); cur.lastTopUpTx = txid;
      write(cur); render();
      window.dispatchEvent(new CustomEvent('bag:sessionToppedUp', { detail: { addBag, txid } }));
    } catch(e){
      console.warn('Top-up failed', e); alert('Top-up cancelled or failed.');
    } finally {
      if (topUpBtn) { topUpBtn.disabled = false; topUpBtn.textContent = 'Top Up'; }
    }
  }

  function endSession(){ const s = read(); clear(); render(); window.dispatchEvent(new CustomEvent('bag:sessionEnded', { detail: s || {} })); }

  startBtn?.addEventListener('click', startSession);
  topUpBtn?.addEventListener('click', topUpSession);
  endBtn?.addEventListener('click', endSession);

  window.addEventListener('bag:pricesUpdated', render);
  render();

  window.__bagSession = {
    active: sessionActive,
    get: read,
    set: write,
    spend(bag){ const s = read(); if(!s) return false; if (s.bag < bag) return false; s.bag = Math.max(0, s.bag - bag); write(s); render(); return true; },
    credit(bag){ const s = read(); if(!s) return false; s.bag += bag; write(s); render(); return true; }
  };
})();
</script>

<!-- GAME LOGIC + PRICES (mirrors Dice; adapted to Plinko slots) -->
<script>
(function(){
  const PRICE_REFRESH_MS = 15000;
  const FETCH_TIMEOUT_MS = 8000;
  const LIVE_CACHE_TTL_MS = 24*60*60*1000;
  const VIEW_CACHE_TTL_MS = 6*60*60*1000;

  const XRPL_WSS = 'wss://s1.ripple.com';
  const BAG_ISSUER = 'rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr';
  const BAG_CODE = 'BAG';

  const dropBtn = document.getElementById('dropBtn');
  const statusText = document.getElementById('statusText');
  const lastOutcome = document.getElementById('lastOutcome');
  const betInput = document.getElementById('demoBet');
  const usdInput = document.getElementById('usdBet');
  const stateText = document.getElementById('stateText');
  const curToggle = document.getElementById('curToggle');
  const unitSpan = document.querySelector('#bagPlinkoDemo .unit');
  const liveDot = document.getElementById('liveDot');
  const liveBAG = document.getElementById('liveBAG');
  const liveXRP = document.getElementById('liveXRP');
  const liveNote = document.getElementById('liveNote');
  const liveConv = document.getElementById('liveConv');
  const diagSpan = document.getElementById('bagDiag');

  const payoutWin = document.getElementById('payoutWin');
  const payoutWinGain = document.getElementById('payoutWinGain');
  const payoutJackpot = document.getElementById('payoutJackpot');
  const payoutJackpotGain = document.getElementById('payoutJackpotGain');

  const PRICES = (window.__PRICES__ = { bagUsd:0, xrpUsd:0, source:'‚Äî', ts:0 });
  const VIEW_CACHE_KEY = 'bag_prices_v8';
  const LAST_LIVE_KEY = 'bag_last_live_v1';

  const WALLET_KEY = 'bag_wallet_v1';
  let playLocked = true;
  const DEMO_PLAY = true;

  function isWalletConnected(){ try { const w = JSON.parse(localStorage.getItem(WALLET_KEY) || 'null'); return !!(w && w.address); } catch { return false; } }
  function pricesReadyForCurrentCurrency(){ return currentCurrency()==='BAG' ? PRICES.bagUsd>0 : PRICES.xrpUsd>0; }
  function recomputeDropEnabled(){ dropBtn.disabled = playLocked || (!DEMO_PLAY && !pricesReadyForCurrentCurrency()); }
  function setPlayLock(lock){
    playLocked = !!lock;
    if (playLocked){
      const msg = 'Connect wallet to play';
      if (statusText) { statusText.textContent = msg; statusText.classList.remove('win','lose'); }
    } else if (statusText && statusText.textContent === 'Connect wallet to play'){
      statusText.textContent = 'Tap Drop';
    }
    recomputeDropEnabled();
  }
  window.addEventListener('bag:walletConnected', () => setPlayLock(false));
  window.addEventListener('bag:walletDisconnected', () => DEMO_PLAY ? setPlayLock(false) : setPlayLock(true));
  setPlayLock(DEMO_PLAY ? false : !isWalletConnected());

  function fmt(n){
    if (!Number.isFinite(n)) return '‚Äî';
    if (Math.abs(n) >= 1) return n.toLocaleString(undefined, {maximumFractionDigits:4});
    if (Math.abs(n) >= 1e-2) return n.toLocaleString(undefined, {maximumFractionDigits:6});
    if (Math.abs(n) >= 1e-4) return n.toLocaleString(undefined, {maximumFractionDigits:8});
    return n.toLocaleString(undefined, {maximumFractionDigits:10});
  }
  function fmtUsd(n){ if (!Number.isFinite(n)) return '‚Äî'; return '$'+n.toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}); }
  function cacheSet(k,v){ try{ localStorage.setItem(k, JSON.stringify({t:Date.now(), v})); }catch{} }
  function cacheGet(k, ttlMs){ try{ const o=JSON.parse(localStorage.getItem(k)||'null'); if(!o) return null; const age = Date.now() - (o.t||0); return age<=ttlMs ? o.v : null; }catch{ return null; } }

  function timedFetch(url, opts={}, timeout=FETCH_TIMEOUT_MS){
    const ctrl = new AbortController();
    const id = setTimeout(()=>ctrl.abort(new Error('timeout')), timeout);
    try{
      const u = new URL(url, location.origin);
      u.searchParams.set('_ts', Date.now().toString());
      return fetch(u.toString(), {
        ...opts,
        headers: { Accept:'application/json', ...(opts.headers||{}) },
        mode: 'cors',
        cache: 'no-store',
        credentials: 'omit',
        referrerPolicy: 'no-referrer',
        signal: ctrl.signal
      });
    } finally { setTimeout(()=>clearTimeout(id),0); }
  }

  function currentCurrency(){ const el = curToggle.querySelector('input[name="betCur"]:checked'); return el ? el.value : 'XRP'; }

  function stakeInBAG(){
    const bet = Math.max(0, parseFloat(betInput.value||0));
    if (!bet) return 0;
    if (currentCurrency()==='BAG') return bet;
    if (PRICES.bagUsd>0 && PRICES.xrpUsd>0){
      const bagPerXrp = PRICES.xrpUsd / PRICES.bagUsd;
      return bet * bagPerXrp;
    }
    return 0;
  }
  function stakeUsdEquivalent(){
    const qty = Math.max(0, parseFloat(betInput.value||0));
    if (!qty) return 0;
    if (currentCurrency()==='BAG') return PRICES.bagUsd>0 ? qty * PRICES.bagUsd : 0;
    return PRICES.xrpUsd>0 ? qty * PRICES.xrpUsd : 0;
  }

  let editingUsd = false;
  function clampUsd(u){ if (!Number.isFinite(u)) return 0; if (u < 1) return 1; if (u > 2000) return 2000; return u; }

  function updateUsdFromBet(){
    if (editingUsd) return;
    const usd = stakeUsdEquivalent();
    if (usdInput){ if (usd>0) usdInput.value = usd.toFixed(2); else usdInput.value = ''; }
  }
  function updateBetFromUsd(){
    const raw = parseFloat(usdInput.value);
    if (!(raw>0)) return;
    const usd = clampUsd(raw);
    if (usd !== raw){ usdInput.value = usd.toFixed(2); }
    if (currentCurrency()==='XRP' && PRICES.xrpUsd>0){ betInput.value = (usd / PRICES.xrpUsd).toString(); }
    else if (currentCurrency()==='BAG' && PRICES.bagUsd>0){ betInput.value = (usd / PRICES.bagUsd).toString(); }
    updatePayoutPreview(); updateLimitUi();
  }
  usdInput.addEventListener('focus', ()=>{ editingUsd = true; });
  usdInput.addEventListener('blur', ()=>{ editingUsd = false; updateBetFromUsd(); updateUsdFromBet(); });
  usdInput.addEventListener('input', ()=>{ editingUsd = true; updateBetFromUsd(); });
  betInput.addEventListener('blur', ()=>{ updateUsdFromBet(); });
  betInput.addEventListener('input', ()=>{ clampIfNeeded(false); updatePayoutPreview(); updateUsdFromBet(); });

  function updatePayoutPreview(){
    const s = stakeInBAG();
    const usd = stakeUsdEquivalent();
    if (s>0){
      const wTotal = s*1.20, wGain = s*0.20, wUsd = usd*1.20;
      const jpTotal = s*2.00, jpGain = s*1.00, jpUsd = usd*2.00;
      payoutWin.textContent = `${fmt(wTotal)} BAG (${fmtUsd(wUsd)})`;
      payoutWinGain.textContent = `(gain +${fmt(wGain)} BAG)`;
      payoutJackpot.textContent = `${fmt(jpTotal)} BAG (${fmtUsd(jpUsd)})`;
      payoutJackpotGain.textContent = `(gain +${fmt(jpGain)} BAG)`;
    } else {
      payoutWin.textContent = payoutJackpot.textContent = '‚Äî';
      payoutWinGain.textContent = payoutJackpotGain.textContent = '';
    }
  }

  let limitNote, limitToast;
  (function ensureLimitUi(){
    const holder=betInput.closest('div'); const container=holder?.parentElement?.parentElement || holder?.parentElement;
    if(container){
      limitNote=document.createElement('div'); limitNote.className='micro'; limitNote.style.marginTop='6px'; container.appendChild(limitNote);
      limitToast=document.createElement('div'); limitToast.className='micro'; limitToast.style.cssText='margin-top:4px;color:#e25b5b;display:none;'; container.appendChild(limitToast);
    }
  })();
  function maxForCurrency(){ return currentCurrency()==='BAG' ? (PRICES.bagUsd>0 ? 2000/PRICES.bagUsd : 0) : (PRICES.xrpUsd>0 ? 2000/PRICES.xrpUsd : 0); }
  function minForCurrency(){ return currentCurrency()==='BAG' ? (PRICES.bagUsd>0 ? 1/PRICES.bagUsd : 0) : (PRICES.xrpUsd>0 ? 1/PRICES.xrpUsd : 0); }
  function clampIfNeeded(showToast=true){
    const maxQty = maxForCurrency(); if (!maxQty) return;
    let val = Math.max(0, parseFloat(betInput.value||0));
    if (val > maxQty){ betInput.value=String(maxQty); if(showToast){ limitToast.textContent=`Bet reduced to max: ${fmt(maxQty)} ${currentCurrency()}`; limitToast.style.display='block'; setTimeout(()=>{ limitToast.style.display='none'; },1600); } }
  }
  function updateLimitUi(){
    let note = `Min $1 ¬∑ Max $2,000`;
    const maxXrp = PRICES.xrpUsd>0 ? 2000/PRICES.xrpUsd : 0;
    const maxBag = PRICES.bagUsd>0 ? 2000/PRICES.bagUsd : 0;
    const minXrp = PRICES.xrpUsd>0 ? 1/PRICES.xrpUsd : 0;
    const minBag = PRICES.bagUsd>0 ? 1/PRICES.bagUsd : 0;
    const partsMax=[]; if(maxXrp) partsMax.push(`${fmt(maxXrp)} XRP`); if(maxBag) partsMax.push(`${fmt(maxBag)} BAG`);
    const partsMin=[]; if(minXrp) partsMin.push(`${fmt(minXrp)} XRP`); if(minBag) partsMin.push(`${fmt(minBag)} BAG`);
    if (partsMin.length || partsMax.length){
      const minTxt = partsMin.length ? `Min ‚âà ${partsMin.join(' or ')}` : '';
      const maxTxt = partsMax.length ? `Max ‚âà ${partsMax.join(' or ')}` : '';
      note += ` ¬∑ ${[minTxt,maxTxt].filter(Boolean).join(' ¬∑ ')}`;
    }
    limitNote.textContent = note;
    clampIfNeeded(false); recomputeDropEnabled(); updateUsdFromBet();
  }

  function updateConversions(){
    if(PRICES.bagUsd>0 && PRICES.xrpUsd>0){
      const xrpPerBag = PRICES.bagUsd/PRICES.xrpUsd;
      const bagPerXrp = PRICES.xrpUsd/PRICES.bagUsd;
      liveConv.textContent = `1 BAG ‚âà ${fmt(xrpPerBag)} XRP ¬∑ 1 XRP ‚âà ${fmt(bagPerXrp)} BAG`;
    } else {
      liveConv.textContent = '1 BAG ‚âà ‚Äî XRP ¬∑ 1 XRP ‚âà ‚Äî BAG';
    }
  }
  function updateLiveLine(){
    liveBAG.textContent = fmt(PRICES.bagUsd);
    liveXRP.textContent = fmt(PRICES.xrpUsd);
    const dotClass = PRICES.source==='live-amm' ? 'ok' : PRICES.source==='last-live' ? 'warn' : 'err';
    liveDot.className = dotClass;
    liveNote.textContent = PRICES.source==='live-amm' ? ' (AMM live)' : PRICES.source==='last-live' ? ' (last live)' : ' (unavailable)';
    updateConversions(); updateLimitUi(); updatePayoutPreview();
    window.dispatchEvent(new CustomEvent('bag:pricesUpdated'));
  }

  async function fetchXrpUsd(){
    try{
      const r=await timedFetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
      if(!r.ok) throw new Error('cg http '+r.status);
      const v=(await r.json())?.ripple?.usd;
      if(Number(v)>0){ PRICES.xrpUsd=Number(v); cacheSet('xrp_usd',PRICES.xrpUsd); return true; }
      throw new Error('cg payload');
    }catch(_){}
    try{
      const r=await timedFetch('https://min-api.cryptocompare.com/data/price?fsym=XRP&tsyms=USD');
      if(!r.ok) throw new Error('cc http '+r.status);
      const v=(await r.json())?.USD;
      if(Number(v)>0){ PRICES.xrpUsd=Number(v); cacheSet('xrp_usd',PRICES.xrpUsd); return true; }
      throw new Error('cc payload');
    }catch(_){}
    try{
      const r=await timedFetch('https://api.kraken.com/0/public/Ticker?pair=XXRPZUSD');
      if(!r.ok) throw new Error('kr http '+r.status);
      const j=await r.json(); const k=Object.keys(j?.result||{})[0]; const last=j?.result?.[k]?.c?.[0];
      if(Number(last)>0){ PRICES.xrpUsd=Number(last); cacheSet('xrp_usd',PRICES.xrpUsd); return true; }
      throw new Error('kr payload');
    }catch(_){}
    const cached = cacheGet('xrp_usd', 24*60*60*1000);
    if(Number(cached)>0){ PRICES.xrpUsd=Number(cached); return true; }
    return false;
  }
  function parseXrpAmount(a){ if (a==null) return null; if (typeof a==='string') return Number(a)/1_000_000; if (typeof a==='object'){ if (a.currency === 'XRP' && a.value!=null) return Number(a.value); } return null; }
  function parseIouAmount(a){ if (!a || typeof a!=='object') return null; return Number(a.value); }

  async function fetchBagUsdFromAMM(){
    const req = { id:1, command:'amm_info', asset:{currency:BAG_CODE,issuer:BAG_ISSUER}, asset2:{currency:'XRP'} };
    const xrpPerBag = await new Promise((resolve)=>{
      const ws = new WebSocket(XRPL_WSS);
      const t = setTimeout(()=>{ try{ws.close();}catch{}; resolve(null); }, FETCH_TIMEOUT_MS);
      ws.onopen = ()=> ws.send(JSON.stringify(req));
      ws.onerror = ()=>{ clearTimeout(t); try{ws.close();}catch{}; resolve(null); };
      ws.onmessage = (ev)=>{
        try{
          const msg = JSON.parse(ev.data);
          if (msg.id!==1 || !msg.result || !msg.result.amm) return;
          clearTimeout(t); try{ws.close();}catch{};
          const amm = msg.result.amm;
          const bagBal = parseIouAmount(amm.amount);
          const xrpBal = parseXrpAmount(amm.amount2);
          if (!(bagBal>0) || !(xrpBal>0)) return resolve(null);
          const price = xrpBal / bagBal;
          if (!(price>0) || !isFinite(price)) return resolve(null);
          if (diagSpan) diagSpan.textContent = `AMM pool ¬∑ BAG=${bagBal.toLocaleString()} ¬∑ XRP=${xrpBal.toLocaleString(undefined,{maximumFractionDigits:6})} ¬∑ spot ${price.toLocaleString(undefined,{maximumFractionDigits:10})} XRP/BAG`;
          resolve(price);
        }catch{ resolve(null); }
      };
    });
    if (!xrpPerBag || !Number.isFinite(xrpPerBag) || xrpPerBag<=0) return false;
    if (PRICES.xrpUsd>0){
      PRICES.bagUsd = PRICES.xrpUsd * xrpPerBag;
      PRICES.source = 'live-amm'; cacheSet(LAST_LIVE_KEY, { bagUsd: PRICES.bagUsd, xrpUsd: PRICES.xrpUsd });
      return true;
    }
    return false;
  }

  function loadViewCache(){ const v = cacheGet(VIEW_CACHE_KEY, VIEW_CACHE_TTL_MS); const x = cacheGet('xrp_usd', VIEW_CACHE_TTL_MS);
    let used=false; if (v && Number(v.bagUsd)>0){ PRICES.bagUsd=v.bagUsd; if(Number(v.xrpUsd)>0) PRICES.xrpUsd=v.xrpUsd; used=true; } if (!PRICES.xrpUsd && Number(x)>0){ PRICES.xrpUsd=x; used=true; } return used; }
  function loadLastLive(){ const v = cacheGet(LAST_LIVE_KEY, LIVE_CACHE_TTL_MS);
    if (v && Number(v.bagUsd)>0){ PRICES.bagUsd = v.bagUsd; if (Number(v.xrpUsd)>0) PRICES.xrpUsd = v.xrpUsd; PRICES.source = 'last-live'; return true; } return false; }

  async function refreshPrices(){
    const hadX = PRICES.xrpUsd>0;
    const gotX = hadX || await fetchXrpUsd();
    let gotLive = false;
    try { gotLive = await fetchBagUsdFromAMM(); } catch {}
    if (gotLive && gotX){ PRICES.source = 'live-amm'; cacheSet(VIEW_CACHE_KEY,{bagUsd:PRICES.bagUsd||0,xrpUsd:PRICES.xrpUsd||0}); }
    else if (loadLastLive()) {/* keep */} else if (loadViewCache()){ PRICES.source = 'last-live'; } else { PRICES.source = '‚Äî'; }
    updateLiveLine();

    if (PRICES.xrpUsd>0 && PRICES.bagUsd>0 && !window.__defaultsSet){
      window.__defaultsSet = true;
      if (currentCurrency()==='XRP'){ betInput.value = '1'; }
      curToggle.addEventListener('change', ()=>{
        if (currentCurrency()==='BAG'){
          const bagPerXrp = PRICES.xrpUsd / PRICES.bagUsd;
          if (bagPerXrp>0) betInput.value = String(bagPerXrp);
        } else { betInput.value = '1'; }
        updatePayoutPreview(); updateLimitUi(); unitSpan.textContent = currentCurrency();
      }, { once:true });
      updatePayoutPreview(); updateLimitUi();
    }
  }

  /* ===== Plinko gameplay (canvas + physics) ===== */
  const canvas = document.getElementById('plinko');
  const ctx = canvas.getContext('2d');
  const W=640, H=880; canvas.width=W; canvas.height=H;

  // Board geometry (7 slots like Dice text)
  const SLOTS = 7;
  const PEG_ROWS = 12, PEG_COLS = 11;
  const GRAVITY = 0.36, RESTITUTION = 0.78, FRICTION = 0.997;
  const PEG_R = 6, BALL_R = 9, WALL_PAD = 16;
  const leftWall=WALL_PAD, rightWall=W-WALL_PAD, topBoard=110, bottomBoard=H-120;
  const slotTop=bottomBoard+10;
  const slotWidth=(rightWall-leftWall)/SLOTS;
  const slotX=i=>leftWall+i*slotWidth;
  const slotCenters=Array.from({length:SLOTS},(_,i)=>slotX(i)+slotWidth/2);

  const pegSpacingX=(rightWall-leftWall-40)/(PEG_COLS-1);
  const pegSpacingY=(bottomBoard-topBoard-100)/(PEG_ROWS-1);
  const pegs=[];
  for(let r=0;r<PEG_ROWS;r++){
    const off=(r%2===0)?0:pegSpacingX/2;
    for(let c=0;c<PEG_COLS;c++){
      let x=leftWall+20+c*pegSpacingX+off;
      if(x<=leftWall+PEG_R || x>=rightWall-PEG_R) continue;
      let y=topBoard+r*pegSpacingY;
      pegs.push({x,y,r:PEG_R});
    }
  }

  // PAY MAP aligned to slots L‚ÜíR
  const PAY_MAP = ['L', 1.2, 'L', 2, 'L', 1.2, 'L'];

  // Peg knock (subtle), using Dice audio AC as base
  let lastPegTs = 0;
  async function playPeg(){
    try{
      const ac = await (window.__bagAudio && __bagAudio.ensureInteractive && __bagAudio.ensureInteractive());
      if(!ac) return;
      const now = ac.currentTime;
      const o = ac.createOscillator(), g = ac.createGain();
      o.type='sine';
      o.frequency.value = 420 + (Math.random()*14-7);
      g.gain.setValueAtTime(0.0001, now);
      g.gain.linearRampToValueAtTime(0.045, now + 0.012);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.08);
      o.connect(g).connect(ac.destination);
      o.start(now); o.stop(now + 0.09);
    }catch{}
  }

  // Draw board and labels
  function drawBoard(){
    ctx.clearRect(0,0,W,H);
    ctx.fillStyle='#0b1b13'; ctx.fillRect(0,0,W,H);

    // frame
    ctx.strokeStyle='#1c3b27'; ctx.lineWidth=4;
    ctx.strokeRect(leftWall-8, topBoard-40, rightWall-leftWall+16, bottomBoard-topBoard+60);

    // pegs
    ctx.fillStyle='#704d1d';
    for(const p of pegs){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); }

    // floor & dividers
    ctx.strokeStyle='#2a4d38'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(leftWall, bottomBoard); ctx.lineTo(rightWall, bottomBoard); ctx.stroke();
    for(let i=1;i<SLOTS;i++){
      const x = slotX(i);
      ctx.beginPath(); ctx.moveTo(x, bottomBoard); ctx.lineTo(x, bottomBoard+50); ctx.stroke();
    }

    // labels
    ctx.font='14px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.textAlign='center';
    for(let i=0;i<SLOTS;i++){
      const rule = PAY_MAP[i];
      const txt = rule==='L' ? 'Scratch' : (rule===2 ? '2√ó' : '1.2√ó');
      ctx.fillStyle = rule==='L' ? '#e25b5b' : (rule===2 ? '#ffd700' : '#baf2cd');
      ctx.fillText(txt, slotCenters[i], bottomBoard+72);
    }
  }
  function drawBall(x,y){
    const r=BALL_R;
    const g=ctx.createRadialGradient(x-4,y-4,2,x,y,r);
    g.addColorStop(0,'#ffd36d'); g.addColorStop(.6,'#c8911e'); g.addColorStop(1,'#8b5e13');
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
  }

  let ball=null, dropping=false, dropStartedAt=0;
  function startDrop(){
    if(dropping) return;
    // demoMode allows always; live would check session + $1 min
    statusText.textContent = 'Dropping‚Ä¶';
    lastOutcome.textContent = '‚Äî';
    ball = {x:W/2, y:60, vx:(Math.random()-.5)*0.25, vy:0, r:BALL_R, alive:true, frames:0};
    dropStartedAt = performance.now();
    dropping=true;
  }

  function resolveDrop(slot, stakeBag){
    const rule = PAY_MAP[slot] ?? 'L';
    if(rule==='L'){
      statusText.textContent='SCRATCH'; statusText.classList.remove('win'); statusText.classList.add('lose');
      lastOutcome.textContent='Lose'; try{ window.__bagAudio && __bagAudio.nudge(); }catch(e){}
      emitResult({ kind:'lose', jackpot:false, stakeBag });
      return 0;
    }
    const mult = Number(rule);
    if(mult===2){
      statusText.textContent='JACKPOT 2√ó'; statusText.classList.remove('lose'); statusText.classList.add('win');
      lastOutcome.textContent='2√ó JACKPOT';
      emitResult({ kind:'jackpot', jackpot:true, stakeBag });
      return stakeBag*2.0;
    } else {
      statusText.textContent='WIN 1.2√ó'; statusText.classList.remove('lose'); statusText.classList.add('win');
      lastOutcome.textContent='1.2√ó WIN';
      emitResult({ kind:'win', jackpot:false, stakeBag });
      return stakeBag*1.2;
    }
  }

  function emitResult(detail){
    const s = Number(detail.stakeBag)||0;
    const usd = stakeUsdEquivalent();
    if (typeof window.showWin === 'function'){
      if (detail.jackpot){ const gain=s*1.00; showWin({ message:'WIN', subtext:`+${fmt(gain)} BAG ¬∑ ${fmtUsd(usd)} ‚Üí ${fmtUsd(usd*2)}`, duration:8000 }); }
      else if (detail.kind==='win'){ const gain=s*0.20; showWin({ message:'WIN', subtext:`+${fmt(gain)} BAG ¬∑ ${fmtUsd(usd)} ‚Üí ${fmtUsd(usd*1.2)}`, duration:6000 }); }
    }
    try{
      fetch('/api/payout', {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({ game:'bag-plinko', kind: detail.kind, jackpot: !!detail.jackpot,
          stake_bag: Number(detail.stakeBag)||0, bag_usd: PRICES.bagUsd||0, xrp_usd: PRICES.xrpUsd||0 })
      }).catch(()=>{});
    }catch(e){}
  }

  // loop + watchdog (prevents freeze)
  (function loop(ts){
    drawBoard();
    if(ball && ball.alive){
      stepBall(ts);
      drawBall(ball.x, ball.y);
      if(ts - dropStartedAt > 6000 || ball.y > H + 40){ forceResolve(); }
    }
    requestAnimationFrame(loop);
  })(performance.now());

  function stepBall(ts){
    ball.frames++;
    // integrate
    ball.vy += GRAVITY;
    ball.x += ball.vx; ball.y += ball.vy;
    ball.vx *= FRICTION; ball.vy *= FRICTION;

    // walls
    if(ball.x - BALL_R < leftWall){ ball.x = leftWall + BALL_R; ball.vx = Math.abs(ball.vx)*RESTITUTION; }
    if(ball.x + BALL_R > rightWall){ ball.x = rightWall - BALL_R; ball.vx = -Math.abs(ball.vx)*RESTITUTION; }
    if(ball.y - BALL_R < 0){ ball.y = BALL_R; ball.vy = 0; }

    // pegs
    for(const p of pegs){
      const dx=ball.x-p.x, dy=ball.y-p.y;
      const dist=Math.hypot(dx,dy) || 0.0001;
      const minD=BALL_R + p.r;
      if(dist < minD){
        const nx = dx / dist, ny = dy / dist;
        const overlap = (minD - dist) + 0.25;
        ball.x += nx * overlap; ball.y += ny * overlap;
        const vDotN = ball.vx*nx + ball.vy*ny;
        ball.vx = (ball.vx - 2*vDotN*nx) * RESTITUTION;
        ball.vy = (ball.vy - 2*vDotN*ny) * RESTITUTION;

        // anti-stick
        const speed = Math.hypot(ball.vx, ball.vy);
        if(speed < 0.22){ ball.vx += (Math.random()-.5)*0.65; ball.vy += 0.45; }
        // subtle knock, throttle ~20Hz
        const now = performance.now(); if(now - lastPegTs > 50){ lastPegTs = now; playPeg(); }
      }
    }

    // finish corridor
    if(ball.y + BALL_R >= bottomBoard){
      ball.vy = Math.max(ball.vy*0.96, 0.12);
      if(ball.y >= slotTop + 46){ forceResolve(); }
    }
  }

  function forceResolve(){
    const stakeBag = calcStakeBag();
    const idx = Math.min(SLOTS-1, Math.max(0, Math.floor((ball.x-leftWall)/slotWidth)));
    // live mode: spend/credit session
    let demoMode = true;
    try{ demoMode = (window.__bagSession && window.__bagSession.get && window.__bagSession.get().addr==='demo'); }catch{}
    if (!demoMode){
      const sess = __bagSession.get();
      if (sess && stakeBag>0){
        // we already spent before drop if live; here we credit on win
      }
    }
    const payoutBag = resolveDrop(idx, stakeBag);
    if (!demoMode && payoutBag>0){ try{ __bagSession.credit(payoutBag); }catch{} }

    ball && (ball.alive=false);
    ball=null; dropping=false;
  }

  function calcStakeBag(){
    const bet = Math.max(0, parseFloat(betInput.value||0));
    if (!bet) return 0;
    if (currentCurrency()==='BAG') return bet;
    if (PRICES.bagUsd>0 && PRICES.xrpUsd>0){ const bagPerXrp = PRICES.xrpUsd / PRICES.bagUsd; return bet * bagPerXrp; }
    return 0;
  }

  // UI events
  dropBtn.addEventListener('click', async ()=>{
    // demo allows; live would enforce session + $1 min
    try{ window.__bagAudio && __bagAudio.nudge(); }catch(e){}
    if (!DEMO_PLAY && !pricesReadyForCurrentCurrency()) return;

    const usdEq = (function(){ const q=parseFloat(betInput.value||0)||0; if(!q) return 0;
      return currentCurrency()==='BAG' ? (PRICES.bagUsd>0 ? q*PRICES.bagUsd : 0) : (PRICES.xrpUsd>0 ? q*PRICES.xrpUsd : 0); })();
    if (!DEMO_PLAY && usdEq < 1){ return; }

    const stakeBag = calcStakeBag();
    if (!DEMO_PLAY){
      const sess = __bagSession.get();
      if (!(sess && sess.bag >= stakeBag && stakeBag > 0)) return;
      const spent = __bagSession.spend(stakeBag);
      if (!spent) return;
    }

    dropBtn.disabled = true;
    startDrop();
    // re-enable CTA after physics resolves (watchdog ensures it does)
    const start = performance.now();
    const reenable = ()=>{ dropBtn.disabled=false; };
    setTimeout(reenable, 1400); // typical settle time; watchdog covers longer
  });

  stateText.textContent='Drop a coin ‚Äî 1.2√ó or 2√ó pays ¬∑ Scratch loses';
  document.querySelector('#bagPlinkoDemo .unit').textContent='XRP';
  betInput.value = '1';
  if (usdInput) usdInput.value = '';
  curToggle.addEventListener('change', ()=>{ document.querySelector('#bagPlinkoDemo .unit').textContent=currentCurrency(); });

  try { ['bag_prices','bag_prices_v2','bag_prices_v3','bag_prices_v4','bag_prices_v5','bag_prices_v6','bag_prices_v7'].forEach(k=>localStorage.removeItem(k)); } catch {}

  function loadViewCache2(){ const v = (function(k,ttl){ try{ const o=JSON.parse(localStorage.getItem(k)||'null'); if(!o) return null; const age=Date.now()-(o.t||0); return age<=ttl ? o.v : null; }catch{ return null; } })( 'bag_prices_v8', 6*60*60*1000 );
    const x = (function(k,ttl){ try{ const o=JSON.parse(localStorage.getItem(k)||'null'); if(!o) return null; const age=Date.now()-(o.t||0); return age<=ttl ? o.v : null; }catch{ return null; } })('xrp_usd', 6*60*60*1000);
    let used=false; if (v && Number(v.bagUsd)>0){ PRICES.bagUsd=v.bagUsd; if(Number(v.xrpUsd)>0) PRICES.xrpUsd=v.xrpUsd; used=true; }
    if (!PRICES.xrpUsd && Number(x)>0){ PRICES.xrpUsd=x; used=true; } return used; }

  if (loadViewCache2()){ PRICES.source='last-live'; updateLiveLine(); }
  (async ()=>{ await refreshPrices(); setInterval(refreshPrices, PRICE_REFRESH_MS); })();
  updatePayoutPreview();
})();
</script>

<!-- Service worker (optional) -->
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js').catch(()=>{});
}
</script>

<!-- Practice Mode Wrapper (mirrors Dice; Plinko text) -->
<script>
(function(){
  const qs = new URLSearchParams(location.search);
  const pathDemo = location.pathname.toLowerCase().includes('/demo');
  const demoMode = pathDemo || qs.get('demo') === '1' || window.__BAG_FORCE_DEMO === true;
  if (!demoMode) return;

  const badge = document.getElementById('demo-badge');
  if (badge) badge.style.display = 'block';

  const $ = (s)=>document.querySelector(s);
  const statusEl  = $('#sessionStatus');
  const startBtn  = $('#startSessionBtn');
  const topUpBtn  = $('#topUpBtn');
  const endBtn    = $('#endSessionBtn');
  const connectEl = $('#connectBtn');

  const DEMO_KEY = '__bag_demo_bag_v1';
  const START_BAG = 1000;
  function getBal(){ try{ const n = Number(localStorage.getItem(DEMO_KEY)); return Number.isFinite(n) && n>0 ? n : START_BAG; }catch{ return START_BAG; } }
  function setBal(v){ try{ localStorage.setItem(DEMO_KEY, String(Math.max(0, Math.floor(v)))) }catch{} }
  if (localStorage.getItem(DEMO_KEY) == null) setBal(START_BAG);

  function fmt(n){
    if (!Number.isFinite(n)) return '‚Äî';
    if (Math.abs(n) >= 1) return n.toLocaleString(undefined, {maximumFractionDigits:4});
    if (Math.abs(n) >= 1e-2) return n.toLocaleString(undefined, {maximumFractionDigits:6});
    if (Math.abs(n) >= 1e-4) return n.toLocaleString(undefined, {maximumFractionDigits:8});
    return n.toLocaleString(undefined, {maximumFractionDigits:10});
  }
  function fmtUsd(n){ return '$'+(Number(n)||0).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2}); }

  function renderDemoSession(){
    const bag = getBal();
    const bagUsd = (window.__PRICES__?.bagUsd||0) * bag;
    if (statusEl){
      statusEl.innerHTML = 'Practice: <span style="color:#2fbf6b">'+fmt(bag)+' BAG</span>' +
        (bagUsd ? ` <span class="micro" style="opacity:.75">(${fmtUsd(bagUsd)})</span>` : '');
    }
    if (startBtn) startBtn.style.display = 'none';
    if (topUpBtn)  topUpBtn.style.display  = 'none';
    if (endBtn)    endBtn.style.display     = 'none';
  }
  renderDemoSession();
  window.addEventListener('bag:pricesUpdated', renderDemoSession);

  if (connectEl) connectEl.style.opacity = '0.9';

  window.__bagSession = {
    active: () => true,
    get: () => ({ addr:'demo', bag: getBal(), ts: Date.now() }),
    set: () => {},
    spend(bag){
      const b = getBal();
      if (!(bag>0) || b < bag) return false;
      setBal(b - bag); renderDemoSession(); return true;
    },
    credit(bag){
      if (!(bag>0)) return false;
      setBal(getBal() + bag); renderDemoSession(); return true;
    }
  };

  function toast(msg){
    try{ if (window.__bagAudio) __bagAudio.nudge(); }catch(e){}
    try{
      let t = document.getElementById('bag-demo-toast');
      if (!t){
        t = document.createElement('div');
        t.id = 'bag-demo-toast';
        t.style.cssText = 'position:fixed;left:50%;bottom:18px;transform:translateX(-50%);padding:10px 14px;border-radius:10px;background:#0b2217;color:#eaf3ed;border:1px solid #1b4a2f;box-shadow:0 6px 24px rgba(0,0,0,.35);font:600 13px system-ui;z-index:2147483647';
        document.body.appendChild(t);
      }
      t.textContent = msg;
      t.style.display = 'block';
      clearTimeout(window.__bagDemoToastTimer);
      window.__bagDemoToastTimer = setTimeout(()=>{ t.style.display='none'; }, 2200);
    }catch{}
  }

  window.addEventListener('bag:rollResult', (ev)=>{}); // not used here

  const st = document.getElementById('stateText');
  if (st) st.textContent = 'Practice Mode ‚Äî off-ledger drops. Connect when ready to play live';
})();
</script>

</body>
</html>
