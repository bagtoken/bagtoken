<!-- PLINKO GAME LOGIC -->
<script>
(function(){
  // ===== Payouts (house edge comes from slot weights below) =====
  const PAY_MAP = ['L', 1.2, 'L', 2, 'L', 1.2, 'L'];
  const SLOTS = PAY_MAP.length;

  // ===== Physics / sizing (smaller ball, tighter pegs) =====
  const GRAVITY = 0.34, RESTITUTION = 0.78, FRICTION = 0.996;
  const PEG_R = 5, BALL_R = 6;          // ‚Üê coin smaller
  const WALL_PAD_PCT = 0.08;            // 8% side padding keeps board centered

  // Canvas
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: true });

  // Logical size; sync to CSS size each frame (DPR-aware)
  let W = 640, H = 880;

  function fitCanvas(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    W = Math.max(1, Math.round(rect.width));
    H = Math.max(1, Math.round(rect.height));
    const bw = Math.round(W * dpr), bh = Math.round(H * dpr);
    if (canvas.width !== bw || canvas.height !== bh){
      canvas.width = bw; canvas.height = bh;
    }
    ctx.setTransform(dpr,0,0,dpr,0,0);
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.imageSmoothingEnabled = true;
  }

  // ===== Board geometry (derived from W/H) =====
  function leftWall()   { return Math.round(W * WALL_PAD_PCT); }
  function rightWall()  { return Math.round(W * (1 - WALL_PAD_PCT)); }
  function topBoard()   { return Math.round(120); }
  function bottomBoard(){ return Math.round(H - 140); }   // more room so pegs span down

  const PEG_ROWS = 14;  // more rows so grid reaches further down
  const PEG_COLS = 13;  // slightly wider grid for nicer fill

  function buildPegs(){
    const pegs=[];
    const innerW = rightWall()-leftWall();
    const innerH = bottomBoard()-topBoard();
    const px = innerW / (PEG_COLS-1);
    const py = innerH / (PEG_ROWS+1);   // +1 so last row isn‚Äôt sitting on the floor

    for(let r=0;r<PEG_ROWS;r++){
      const off = (r%2===0) ? 0 : px/2;
      for(let c=0;c<PEG_COLS;c++){
        const x = leftWall() + c*px + off;
        if (x<=leftWall()+PEG_R || x>=rightWall()-PEG_R) continue;
        const y = topBoard() + (r+1)*py; // start one step below the top frame
        pegs.push({x,y,r:PEG_R});
      }
    }
    return {pegs, px, py};
  }
  let pegGeo = buildPegs();

  // Slots
  function slotWidth(){ return (rightWall()-leftWall())/SLOTS; }
  const slotX=i=>leftWall()+i*slotWidth();

  // UI elements
  const $=id=>document.getElementById(id);
  const modeLbl=$('modeLbl'), balLbl=$('balLbl'), ccyLbl=$('ccyLbl'), betLbl=$('betLbl'), lastLbl=$('lastLbl');
  const resText=$('resText');
  const dropBtn=$('dropBtn');
  const curToggle=document.getElementById('curToggle');
  const unitSpan=document.querySelector('#bagPlinko .unit');
  const betInput=document.getElementById('demoBet');
  const usdInput=document.getElementById('usdBet');
  const celeEl=document.getElementById('cele');

  let mode='Demo', balance=100, stake=1, currency='XRP', lastTxt='‚Äî';
  let dropping=false, ball=null, dropStartedAt=0;
  let lastPegTs=0, safetyTimer=null;

  function hud(){ balLbl.textContent=Number(balance).toFixed(2); ccyLbl.textContent=currency; betLbl.textContent=String(stake); lastLbl.textContent=lastTxt; }

  // keypad-only: sanitize numeric
  function sanitizeBet(){
    const raw = (betInput.value||'').replace(/[^\d]/g,'');
    betInput.value = raw || '1';
    stake = Math.max(1, parseInt(betInput.value,10)||1);
    betLbl.textContent = String(stake);
  }
  betInput.addEventListener('input', sanitizeBet);
  betInput.addEventListener('blur', sanitizeBet);

  function currentCurrency(){ const el = curToggle.querySelector('input[name="betCur"]:checked'); return el ? el.value : 'XRP'; }
  function stakeUsdEquivalent(){
    const qty = Math.max(0, parseFloat(betInput.value||0));
    const P=window.__PRICES__||{};
    if (currentCurrency()==='BAG') return P.bagUsd>0 ? qty * P.bagUsd : 0;
    return P.xrpUsd>0 ? qty * P.xrpUsd : 0;
  }
  usdInput.addEventListener('blur', ()=>{
    const u = parseFloat(usdInput.value||'0'); const P=window.__PRICES__||{};
    if (!(u>0)) return;
    if (currentCurrency()==='XRP' && P.xrpUsd>0){ betInput.value = Math.max(1, Math.floor(u / P.xrpUsd)).toString(); }
    else if (currentCurrency()==='BAG' && P.bagUsd>0){ betInput.value = Math.max(1, Math.floor(u / P.bagUsd)).toString(); }
    sanitizeBet();
  });
  window.addEventListener('bag:pricesUpdated', ()=>{
    const usd = stakeUsdEquivalent();
    usdInput.value = usd>0 ? usd.toFixed(2) : '';
  });
  curToggle.addEventListener('change', ()=>{
    currency = currentCurrency(); ccyLbl.textContent = currency; unitSpan.textContent = currency;
    const usd = stakeUsdEquivalent(); usdInput.value = usd>0 ? usd.toFixed(2) : '';
  });

  // ===== Sound (fires on peg hits and result) =====
  async function pegKnock(){ try{ if (window.__bagAudio) { await __bagAudio.ensureInteractive(); __bagAudio.nudge(); } }catch{} }
  function blip(){ try{ window.__bagAudio?.nudge?.(); }catch{} }

  // House-edge weight for emergency resolves (tab-throttle cases)
  // Favor losses, then 1.2x, then rare 2x.
  function weightedSlotIndex(){
    const weights = [28, 10, 28, 3, 28, 10, 28]; // totals 135; ~4‚Äì5% hit rate for 2x
    const total = 135;
    let r = Math.random() * total;
    for(let i=0;i<weights.length;i++){ r -= weights[i]; if(r<=0) return i; }
    return 3;
  }

  /* Drop handler */
  dropBtn.addEventListener('click', async ()=>{
    if (dropping) return;
    try { await window.__bagAudio?.ensureInteractive?.(); window.__bagAudio?.nudge?.(); } catch {}

    const usd = stakeUsdEquivalent();
    const passesMin = usd > 0 ? usd >= 1 : (Number(stake) >= 1);
    if (!passesMin){ resText.textContent = 'Min $1'; return; }

    dropBtn.disabled = true;
    balance = Math.max(0, balance - stake);
    lastTxt = '‚Äî';
    resText.textContent = '‚Äî';
    celeEl?.classList.remove('show');
    hud();
    startDrop();
  });

  function startDrop(){
    dropping=true;
    // vary entry so it doesn‚Äôt always start dead-center
    const entrySpread = (rightWall()-leftWall()) * 0.28;
    const startOffset = (Math.random() - 0.5) * entrySpread;
    const initVx = (Math.random() - 0.5) * 1.1;
    ball = {x:(leftWall()+rightWall())/2 + startOffset, y:topBoard()-30, vx:initVx, vy:0.2, r:BALL_R, alive:true, frames:0};
    lastPegTs = 0; dropStartedAt = performance.now();

    clearTimeout(safetyTimer);
    safetyTimer = setTimeout(()=>{ if(dropping){ resolveByIndex(weightedSlotIndex()); } }, 9000);
  }

  (function loop(ts){
    drawBoard();
    if(ball && ball.alive){
      stepBall(ts);
      drawBall(ball.x, ball.y);
      if(ball.y > H + 200){ resolveByIndex(boundarySlotIndex(ball.x)); }
    }
    // never let the button get stuck
    if (!ball && dropping) { dropping = false; dropBtn.disabled = false; }
    requestAnimationFrame(loop);
  })(performance.now());

  setInterval(()=>{ if (dropping && (!ball || !ball.alive)) { dropping=false; dropBtn.disabled=false; } }, 700);
  addEventListener('resize', ()=>{ pegGeo = buildPegs(); });

  function stepBall(ts){
    ball.frames++;
    ball.vy += GRAVITY;
    ball.x += ball.vx; ball.y += ball.vy;
    ball.vx *= FRICTION; ball.vy *= FRICTION;
    ball.vx += (Math.random() - 0.5) * 0.02;

    // walls
    if(ball.x - BALL_R < leftWall()){ ball.x = leftWall() + BALL_R; ball.vx = Math.abs(ball.vx)*RESTITUTION; blip(); }
    if(ball.x + BALL_R > rightWall()){ ball.x = rightWall() - BALL_R; ball.vx = -Math.abs(ball.vx)*RESTITUTION; blip(); }
    if(ball.y - BALL_R < 0){ ball.y = BALL_R; ball.vy = 0; }

    // pegs
    for(const p of pegGeo.pegs){
      const dx=ball.x-p.x, dy=ball.y-p.y;
      const dist=Math.hypot(dx,dy) || 0.0001;
      const minD=BALL_R + p.r;
      if(dist < minD){
        const nx = dx / dist, ny = dy / dist;
        const overlap = (minD - dist) + 0.2;
        ball.x += nx * overlap; ball.y += ny * overlap;
        const vDotN = ball.vx*nx + ball.vy*ny;
        ball.vx = (ball.vx - 2*vDotN*nx) * RESTITUTION;
        ball.vy = (ball.vy - 2*vDotN*ny) * RESTITUTION;

        const nowMs = performance.now();
        if (nowMs - lastPegTs > 45){ lastPegTs = nowMs; pegKnock(); } // frequent but not spammy

        const speed = Math.hypot(ball.vx, ball.vy);
        if(speed < 0.22){ ball.vx += (Math.random()-.5)*0.55; ball.vy += 0.38; }
      }
    }

    // Landing
    const slowEnough = Math.abs(ball.vy) < 0.22;
    if (ball.y >= bottomBoard() + 56 && (slowEnough || ball.y >= bottomBoard() + 86)){
      resolveByIndex(boundarySlotIndex(ball.x));
    }
  }

  function boundarySlotIndex(x){
    const clamped = Math.min(rightWall()-1, Math.max(leftWall()+1, x));
    const idx = Math.floor((clamped - leftWall()) / slotWidth());
    return Math.max(0, Math.min(SLOTS-1, idx));
  }

  function resolveByIndex(idx){
    if (!ball){ dropping=false; dropBtn.disabled=false; return; }
    ball.alive = false; ball = null;
    clearTimeout(safetyTimer);

    const rule = PAY_MAP[idx] ?? 'L';
    dropping = false; dropBtn.disabled = false;

    celeEl?.classList.remove('show');

    if (rule === 'L'){
      lastTxt = 'Scratch';
      resText.textContent = 'Scratch (lose)';
      blip();
    } else {
      const mult = Number(rule);
      const payout = Math.floor(stake * mult * 100)/100;
      balance += payout; hud();
      if (mult === 2){ lastTxt = 'Jackpot 2√ó'; resText.textContent = 'üéâ Jackpot 2√ó'; celeEl.style.color='#ffd700'; }
      else { lastTxt = 'Win 1.2√ó'; resText.textContent = 'Win 1.2√ó'; celeEl.style.color='#baf2cd'; }
      try{ window.__bagSession?.credit?.(payout); }catch{}
      celeEl.textContent = resText.textContent;
      celeEl.classList.add('show');
      setTimeout(()=> celeEl.classList.remove('show'), 1200);
      blip();
    }
    hud();
  }

  // ===== Render =====
  function drawBoard(){
    fitCanvas();
    pegGeo = buildPegs();  // keep pegs aligned to current size

    // frame/backdrop
    ctx.fillStyle='#0b1b13'; ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='#1c3b27'; ctx.lineWidth=4;
    ctx.strokeRect(leftWall()-8, topBoard()-46, rightWall()-leftWall()+16, bottomBoard()-topBoard()+66);

    // pegs
    ctx.fillStyle='#704d1d';
    for(const p of pegGeo.pegs){ ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill(); }

    // floor & dividers
    ctx.strokeStyle='#2a4d38'; ctx.lineWidth=3;
    ctx.beginPath(); ctx.moveTo(leftWall(), bottomBoard()); ctx.lineTo(rightWall(), bottomBoard()); ctx.stroke();
    for(let i=1;i<SLOTS;i++){
      const x = slotX(i);
      ctx.beginPath(); ctx.moveTo(x, bottomBoard()); ctx.lineTo(x, bottomBoard()+50); ctx.stroke();
    }

    // labels
    const slotCenters=Array.from({length:SLOTS},(_,i)=>slotX(i)+slotWidth()/2);
    ctx.font='14px system-ui, -apple-system, Segoe UI, Roboto, Arial'; ctx.textAlign='center';
    for(let i=0;i<SLOTS;i++){
      const rule = PAY_MAP[i];
      const txt = rule==='L' ? 'Scratch' : (rule===2 ? '2√ó' : '1.2√ó');
      ctx.fillStyle = rule==='L' ? '#e25b5b' : (rule===2 ? '#ffd700' : '#baf2cd');
      ctx.fillText(txt, slotCenters[i], bottomBoard()+72);
    }
  }

  function drawBall(x,y){
    const r=BALL_R;
    ctx.beginPath();
    ctx.arc(x,y,r,0,Math.PI*2);
    const g=ctx.createRadialGradient(x-3,y-3,1,x,y,r);
    g.addColorStop(0,'#ffd36d'); g.addColorStop(.6,'#c8911e'); g.addColorStop(1,'#8b5e13');
    ctx.fillStyle=g; ctx.fill();
    ctx.lineWidth=1; ctx.strokeStyle='rgba(0,0,0,.35)'; ctx.stroke();
  }

  // initial UI
  ccyLbl.textContent = currency; unitSpan.textContent = currency;
  hud();
})();
</script>
