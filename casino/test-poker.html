<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>$BAG Live Pricing â€” AMM Feed</title>
<meta name="format-detection" content="telephone=no" />

<style>
  :root{
    --bg:#06120d;--panel:#0d2217;--line:#1c3b2a;--fg:#eaf3ee;--muted:#aeb7af;
    --ok:#2fbf6b;--warn:#f0b429;--err:#ef4444;--gold:#ffe175;
  }
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1120px;margin:0 auto;padding:16px}
  .ticker{
    display:flex;align-items:center;gap:12px;
    background:linear-gradient(180deg,#0c2218,#091a13);
    border:1px solid var(--line);border-radius:14px;padding:14px 16px;
    box-shadow:0 8px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
  }
  .dot{width:10px;height:10px;border-radius:50%;background:var(--muted);box-shadow:0 0 0 2px rgba(255,255,255,.06) inset}
  .dot.ok{background:var(--ok)}
  .dot.warn{background:var(--warn)}
  .dot.err{background:var(--err)}
  .label{font-weight:600;letter-spacing:.2px}
  .value{font-variant-numeric:tabular-nums;white-space:nowrap}
  .sep{opacity:.4}
  .muted{color:var(--muted)}
  .grid{display:grid;grid-template-columns:1fr;gap:12px;margin-top:14px}
  .card{
    background:linear-gradient(180deg,#0b1b13,#0a1812);
    border:1px solid var(--line);border-radius:14px;padding:16px;
    box-shadow:0 8px 24px rgba(0,0,0,.35), inset 0 1px 0 rgba(255,255,255,.03);
  }
  h1{margin:0 0 10px;font-size:clamp(18px,3.5vw,24px)}
  .row{display:flex;flex-wrap:wrap;align-items:center;gap:10px}
  .pill{
    display:inline-flex;align-items:center;gap:8px;
    padding:6px 10px;border:1px solid var(--line);border-radius:999px;background:rgba(255,255,255,.02)
  }
  code.kv{background:rgba(255,255,255,.04);padding:2px 6px;border-radius:6px;border:1px solid var(--line)}
  .gold{color:var(--gold)}
  @media (min-width:720px){ .grid{grid-template-columns:1fr 1fr} }
</style>
</head>
<body>
  <div class="wrap">

    <!-- TOP LIVE TICKER -->
    <div class="ticker">
      <div id="liveDot" class="dot err" aria-hidden="true"></div>
      <div class="label">$BAG</div>
      <div class="value" id="liveBAG">â€”</div>
      <div class="sep">Â·</div>
      <div class="label">XRP</div>
      <div class="value" id="liveXRP">â€”</div>
      <div class="muted" id="liveNote"> (unavailable)</div>
    </div>

    <div class="grid">
      <section class="card">
        <h1>$BAG â†” XRP conversion</h1>
        <div class="row">
          <div class="pill"><strong>Spot</strong> <span id="liveConv" class="muted">1 BAG â‰ˆ â€” XRP Â· 1 XRP â‰ˆ â€” BAG</span></div>
          <div class="pill">Source <code class="kv" id="srcKv">AMM (BAG/XRP), XRP-USD via CoinGecko</code></div>
        </div>
      </section>

      <section class="card">
        <h1>Notes</h1>
        <ul class="muted" style="margin:0 0 0 18px;line-height:1.4">
          <li>Green light = AMM pool live. Amber = last live. Red = unavailable.</li>
          <li>No order book or OTC fallback. AMM only, per config.</li>
          <li>UI never blanks; uses last good values while retrying.</li>
        </ul>
      </section>
    </div>

    <p class="muted" style="margin-top:14px">XRPLâ€™s Heaviest Memeâ€¦ <span class="gold">getthebag.io</span></p>
  </div>

  <!-- PRICES (v12: multi-node AMM + resilient caching) -->
  <script>
  (function(){
    const PRICE_REFRESH_MS = 15000;
    const FETCH_TIMEOUT_MS = 7000;
    const LIVE_CACHE_TTL_MS = 24*60*60*1000;
    const VIEW_CACHE_TTL_MS = 6*60*60*1000;

    // ðŸ” $BAG AMM pair (BAG/XRP)
    const BAG_ISSUER = 'rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr';
    const BAG_CODE   = 'BAG';

    const VIEW_CACHE_KEY = 'bag_prices_v8';
    const LAST_LIVE_KEY  = 'bag_last_live_v1';
    const XRP_KEY        = 'xrp_usd';

    // UI refs
    const liveDot = document.getElementById('liveDot');
    const liveBAG = document.getElementById('liveBAG');
    const liveXRP = document.getElementById('liveXRP');
    const liveNote = document.getElementById('liveNote');
    const liveConv = document.getElementById('liveConv');

    // Shared state (kept global for other modules)
    const PRICES = (window.__PRICES__ = window.__PRICES__ || { bagUsd:0, xrpUsd:0, source:'â€”', ts:0 });

    // Keep last good in-memory values so the UI never blanks during a bad poll
    let lastGood = { bagUsd: PRICES.bagUsd||0, xrpUsd: PRICES.xrpUsd||0, source: PRICES.source||'â€”' };

    // utils
    const fmt = n => Number.isFinite(n) ? n.toLocaleString(undefined,{maximumFractionDigits:6}) : 'â€”';
    const cacheSet = (k,v) => { try{ localStorage.setItem(k, JSON.stringify({t:Date.now(), v})); }catch{} };
    const cacheGet = (k, ttlMs) => {
      try{
        const o = JSON.parse(localStorage.getItem(k)||'null'); if(!o) return null;
        return (Date.now()-(o.t||0) <= ttlMs) ? o.v : null;
      }catch{ return null; }
    };
    function timedFetch(url, opts={}, timeout=FETCH_TIMEOUT_MS){
      const ctrl = new AbortController();
      const id = setTimeout(()=>ctrl.abort(new Error('timeout')), timeout);
      try{
        const u = new URL(url, location.origin);
        u.searchParams.set('_ts', Date.now().toString());
        return fetch(u.toString(), {
          ...opts,
          headers: { Accept:'application/json', ...(opts.headers||{}) },
          mode:'cors', cache:'no-store', credentials:'omit', referrerPolicy:'no-referrer',
          signal: ctrl.signal
        });
      } finally { setTimeout(()=>clearTimeout(id),0); }
    }

    function updateLiveLine(){
      if (liveBAG)  liveBAG.textContent  = fmt(PRICES.bagUsd);
      if (liveXRP)  liveXRP.textContent  = Number.isFinite(PRICES.xrpUsd)
        ? PRICES.xrpUsd.toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2})
        : 'â€”';

      if (liveDot)  liveDot.className    = (PRICES.source==='live-amm' ? 'dot ok' : PRICES.source==='last-live' ? 'dot warn' : 'dot err');
      if (liveNote) liveNote.textContent = (PRICES.source==='live-amm' ? ' (AMM live)' : PRICES.source==='last-live' ? ' (last live)' : ' (unavailable)');

      if (liveConv){
        if(PRICES.bagUsd>0 && PRICES.xrpUsd>0){
          const xrpPerBag = PRICES.bagUsd/PRICES.xrpUsd;
          const bagPerXrp = PRICES.xrpUsd/PRICES.bagUsd;
          liveConv.textContent = `1 BAG â‰ˆ ${xrpPerBag.toLocaleString(undefined,{maximumFractionDigits:6})} XRP Â· 1 XRP â‰ˆ ${bagPerXrp.toLocaleString(undefined,{maximumFractionDigits:6})} BAG`;
        } else {
          liveConv.textContent = '1 BAG â‰ˆ â€” XRP Â· 1 XRP â‰ˆ â€” BAG';
        }
      }

      // remember last good
      if (PRICES.bagUsd>0 && PRICES.xrpUsd>0){
        lastGood = { bagUsd: PRICES.bagUsd, xrpUsd: PRICES.xrpUsd, source: PRICES.source };
      }
      window.dispatchEvent(new CustomEvent('bag:pricesUpdated'));
    }

    async function fetchXrpUsdLive(){
      // Live first; if it fails, keep cache; donâ€™t blank UI
      try{
        const r = await timedFetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
        if(!r.ok) throw 0;
        const v = (await r.json())?.ripple?.usd;
        if(Number(v)>0){
          PRICES.xrpUsd = Number(v);
          cacheSet(XRP_KEY, PRICES.xrpUsd);
          return true;
        }
      }catch(_){}
      // fallback to cached XRP USD if exists
      const cachedX = cacheGet(XRP_KEY, VIEW_CACHE_TTL_MS);
      if (Number(cachedX)>0){ PRICES.xrpUsd = Number(cachedX); return false; }
      return false;
    }

    function parseXrpAmount(a){ if (a==null) return null; if (typeof a==='string') return Number(a)/1_000_000; if (typeof a==='object' && a.currency==='XRP') return Number(a.value); return null; }
    function parseIouAmount(a){ if (!a || typeof a!=='object') return null; return Number(a.value); }

    async function fetchBagViaAMMLive(){
      // Try multiple XRPL nodes; first to succeed wins
      const NODES = [
        'wss://xrplcluster.com',
        'wss://s1.ripple.com',
        'wss://s2.ripple.com'
      ];
      const req = { id:1, command:'amm_info', asset:{currency:BAG_CODE,issuer:BAG_ISSUER}, asset2:{currency:'XRP'} };

      for (const url of NODES){
        const price = await new Promise((resolve)=>{
          let done=false;
          const ws = new WebSocket(url);
          const killer = setTimeout(()=>{ if(done) return; done=true; try{ws.close();}catch{}; resolve(null); }, FETCH_TIMEOUT_MS);

          ws.onopen = ()=> { try{ ws.send(JSON.stringify(req)); }catch{ clearTimeout(killer); resolve(null); } };
          ws.onerror = ()=> { clearTimeout(killer); if(done) return; done=true; resolve(null); };
          ws.onclose = ()=> {};
          ws.onmessage = (ev)=>{
            if (done) return;
            try{
              const msg = JSON.parse(ev.data);
              if (msg.id!==1 || !msg.result || !msg.result.amm) return; // wait until amm present or timeout
              const amm = msg.result.amm;
              const bagBal = parseIouAmount(amm.amount);
              const xrpBal = parseXrpAmount(amm.amount2);
              if (!(bagBal>0) || !(xrpBal>0)) { /* not a valid pool */ }
              const p = xrpBal / bagBal;
              if (p>0 && isFinite(p)){
                done = true; clearTimeout(killer);
                try{ ws.close(); }catch{};
                resolve(p);
                return;
              }
            }catch{ /* ignore */ }
          };
        });

        if (price && price>0){
          // convert to USD with whatever XRP price we have (live or cached)
          if (PRICES.xrpUsd>0){
            PRICES.bagUsd = PRICES.xrpUsd * price;
            PRICES.source = 'live-amm';
            cacheSet(LAST_LIVE_KEY, { bagUsd: PRICES.bagUsd, xrpUsd: PRICES.xrpUsd });
            cacheSet(VIEW_CACHE_KEY, { bagUsd: PRICES.bagUsd, xrpUsd: PRICES.xrpUsd });
            return true;
          } else {
            const cachedX = cacheGet(XRP_KEY, VIEW_CACHE_TTL_MS);
            if (Number(cachedX)>0){
              PRICES.xrpUsd = Number(cachedX);
              PRICES.bagUsd = PRICES.xrpUsd * price;
              PRICES.source = 'live-amm';
              cacheSet(LAST_LIVE_KEY, { bagUsd: PRICES.bagUsd, xrpUsd: PRICES.xrpUsd });
              cacheSet(VIEW_CACHE_KEY, { bagUsd: PRICES.bagUsd, xrpUsd: PRICES.xrpUsd });
              return true;
            }
            return false;
          }
        }
      }
      return false;
    }

    function loadLastLiveBundle(){
      const v = cacheGet(LAST_LIVE_KEY, LIVE_CACHE_TTL_MS);
      if (v && Number(v.bagUsd)>0){
        PRICES.bagUsd = Number(v.bagUsd);
        if (Number(v.xrpUsd)>0) PRICES.xrpUsd = Number(v.xrpUsd);
        PRICES.source = 'last-live';
        return true;
      }
      return false;
    }
    function loadViewCache(){
      const v = cacheGet(VIEW_CACHE_KEY, VIEW_CACHE_TTL_MS);
      const x = cacheGet(XRP_KEY, VIEW_CACHE_TTL_MS);
      let ok=false;
      if (v && Number(v.bagUsd)>0){ PRICES.bagUsd = Number(v.bagUsd); if (Number(v.xrpUsd)>0) PRICES.xrpUsd = Number(v.xrpUsd); ok=true; }
      if (!PRICES.xrpUsd && Number(x)>0){ PRICES.xrpUsd = Number(x); ok=true; }
      if (ok && PRICES.source==='â€”') PRICES.source = 'last-live';
      return ok;
    }

    async function refreshPrices(){
      // 1) Try to refresh XRP USD (live or cached)
      await fetchXrpUsdLive();

      // 2) Try AMM live across multiple nodes
      const ammOk = await fetchBagViaAMMLive();

      // 3) If AMM not live, keep the best cached bundle
      if (!ammOk){
        if (!loadLastLiveBundle()) loadViewCache();

        // If still nothing, restore last known good in-memory values so UI doesnâ€™t blank
        if (!(PRICES.bagUsd>0) && lastGood.bagUsd>0){
          PRICES.bagUsd = lastGood.bagUsd;
          PRICES.xrpUsd = lastGood.xrpUsd;
          PRICES.source = lastGood.source || 'last-live';
        }
      }

      updateLiveLine();
    }

    (async ()=>{ await refreshPrices(); setInterval(refreshPrices, PRICE_REFRESH_MS); })();

    addEventListener('storage', (e)=>{
      if (e.key === VIEW_CACHE_KEY || e.key === XRP_KEY || e.key === LAST_LIVE_KEY){
        if (!loadLastLiveBundle()) loadViewCache();
        updateLiveLine();
      }
    });
  })();
  </script>
</body>
</html>
