<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>$BAG — Live Pricing (AMM)</title>

<!-- XRPL + UI base -->
<link rel="preconnect" href="https://api.coingecko.com" crossorigin>
<link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/xrpl@2.13.0/dist/xrpl-latest.min.js"></script>

<!-- Domains to try for TOML discovery -->
<meta name="x-bag-toml-domains" content="https://getthebag.io/.well-known/xrp-ledger.toml,https://bagtoken.net/.well-known/xrp-ledger.toml" />

<style>
  :root{
    --bg:#020703;--panel:#0b1b13;--panel2:#0d2217;--fg:#eaf3ee;--muted:#aeb7af;--gold:#ffe175;
    --ok:#2fbf6b;--warn:#caa93a;--err:#d86161;--line:#173524
  }
  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:980px;margin:0 auto;padding:16px}
  h1{margin:0 0 6px;font-size:clamp(1rem,3vw,1.4rem);letter-spacing:.2px}
  .sub{color:var(--muted);font-size:.9rem;margin-bottom:16px}

  .ticker{
    display:grid;gap:12px;
    grid-template-columns: repeat(auto-fit,minmax(270px,1fr));
  }
  .card{
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border:1px solid #1a3a28;border-radius:14px;padding:14px 14px 16px;
    box-shadow:0 6px 22px rgba(0,0,0,.35)
  }
  .row{display:flex;align-items:center;justify-content:space-between;margin:8px 0}
  .label{color:var(--muted);font-size:.92rem}
  .value{font-variant-numeric:tabular-nums;letter-spacing:.2px}
  .mono{font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace}
  .big{font-size:1.25rem}
  .pill{
    display:inline-flex;align-items:center;gap:8px;padding:6px 10px;border-radius:999px;
    background:#0f2319;border:1px solid #1a3a28;font-size:.85rem
  }
  .dot{width:10px;height:10px;border-radius:50%}
  .green{background:var(--ok)}
  .amber{background:var(--warn)}
  .red{background:var(--err)}
  .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  .muted{color:var(--muted)}
  .hr{height:1px;background:#153a26;margin:10px 0}
  .foot{font-size:.82rem;color:var(--muted);margin-top:12px}
  code.k{font-size:.82rem;background:#0c2017;border:1px solid #1a3a28;border-radius:6px;padding:2px 6px}
</style>
</head>
<body>
  <div class="wrap">
    <h1>$BAG — Live Pricing</h1>
    <div class="sub">Source of truth: XRPL AMM BAG/XRP. Fallback: last known live AMM price only.</div>

    <div class="ticker">
      <section class="card" id="statusCard">
        <div class="row">
          <div class="label">Status</div>
          <div class="pill" id="livePill"><span class="dot red" id="liveDot"></span><span id="liveTxt">Connecting</span></div>
        </div>
        <div class="row"><div class="label">Resolved Issuer</div><div class="value mono" id="issuerVal">—</div></div>
        <div class="row"><div class="label">XRPL Node</div><div class="value mono" id="nodeVal">—</div></div>
        <div class="row"><div class="label">Last Updated</div><div class="value" id="tsVal">—</div></div>
      </section>

      <section class="card" id="priceCard">
        <div class="row"><div class="label">BAG/XRP</div><div class="value big mono" id="bagXrp">—</div></div>
        <div class="row"><div class="label">XRP/USD</div><div class="value mono" id="xrpUsd">—</div></div>
        <div class="hr"></div>
        <div class="row"><div class="label">$BAG (USD)</div><div class="value big mono" id="bagUsd">—</div></div>
        <div class="foot">Computed from AMM reserves. <code class="k">USD = (XRP/USD) × (XRP per BAG)</code></div>
      </section>

      <section class="card">
        <div class="row"><div class="label">Cache Policy</div><div class="value">Last Live Only</div></div>
        <div class="row"><div class="label">Order Book</div><div class="value">Never</div></div>
        <div class="row"><div class="label">OTC</div><div class="value">Never</div></div>
        <div class="row"><div class="label">Cache TTL</div><div class="value">15 minutes soft</div></div>
        <div class="foot">If live AMM fetch fails, UI shows the most recent live snapshot from local cache.</div>
      </section>
    </div>
  </div>

<script>
/* =========================
   $BAG Live Pricing Engine
   =========================
   - Discovers BAG issuer via xrp-ledger.toml on your domains
   - Connects to XRPL via multiple WebSocket endpoints (race-first)
   - Requests AMM reserves for BAG/XRP and computes price
   - Fetches XRP/USD from CoinGecko
   - Strict fallback: last live cached snapshot only
*/
(function(){
  const COINGECKO = 'https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd';
  const XRPL_ENDPOINTS = [
    'wss://xrplcluster.com',        // community cluster
    'wss://s1.ripple.com',          // Ripple primary
    'wss://xrpl.ws'                 // public
  ];

  const DOM = {
    dot: document.getElementById('liveDot'),
    txt: document.getElementById('liveTxt'),
    node: document.getElementById('nodeVal'),
    issuer: document.getElementById('issuerVal'),
    bagxrp: document.getElementById('bagXrp'),
    xrpUsd: document.getElementById('xrpUsd'),
    bagUsd: document.getElementById('bagUsd'),
    ts: document.getElementById('tsVal'),
  };

  const CACHE_KEY = 'bag_live_amm_snapshot_v2';
  const SOFT_TTL_MS = 15 * 60 * 1000;

  const state = {
    issuer: null,
    client: null,
    node: null,
    xrpUsd: null,
    bagPerXrp: null, // XRP per 1 BAG
    ts: null
  };

  function setStatus(color, text){
    DOM.dot.className = 'dot ' + color;
    DOM.txt.textContent = text;
  }

  function fmt(n, dp=6){
    if(n===null || n===undefined || Number.isNaN(n)) return '—';
    return Number(n).toLocaleString(undefined,{minimumFractionDigits:dp,maximumFractionDigits:dp});
  }

  function saveCache(snap){
    const payload = {
      v:2, ts: Date.now(),
      issuer: snap.issuer,
      node: snap.node,
      xrpUsd: snap.xrpUsd,
      bagXrp: snap.bagXrp // XRP per BAG
    };
    try{ localStorage.setItem(CACHE_KEY, JSON.stringify(payload)); }catch(e){}
  }

  function loadCache(){
    try{
      const raw = localStorage.getItem(CACHE_KEY);
      if(!raw) return null;
      const obj = JSON.parse(raw);
      return obj;
    }catch(e){ return null; }
  }

  async function fetchToml(url){
    const res = await fetch(url, {cache:'no-store'});
    if(!res.ok) throw new Error('TOML not found ' + url);
    return await res.text();
  }

  function parseIssuerFromToml(tomlText){
    // Minimal TOML scan for a [CURRENCIES] block with code/name = "BAG" and 'issuer'
    // Accepts either 'code' or 'currency' fields.
    const blocks = tomlText.split(/\n\[/).map((x,i)=> i?('['+x):x);
    for(const b of blocks){
      if(!/\[CURRENCIES\]/i.test(b)) continue;
      const hasBAG = /(^|\n)\s*(code|currency)\s*=\s*"(?:BAG)"/i.test(b);
      if(!hasBAG) continue;
      const m = b.match(/(^|\n)\s*issuer\s*=\s*"([rX][1-9A-HJ-NP-Za-km-z]{24,})"/i);
      if(m) return m[2];
    }
    return null;
  }

  async function resolveIssuer(){
    // Try meta list first
    const meta = document.querySelector('meta[name="x-bag-toml-domains"]');
    const urls = meta ? meta.content.split(',').map(s=>s.trim()).filter(Boolean) : [];
    const tried = [];
    for(const u of urls){
      try{
        const txt = await fetchToml(u);
        const iss = parseIssuerFromToml(txt);
        if(iss) return iss;
        tried.push(u+' (no issuer BAG)');
      }catch(e){
        tried.push(u+' (fail)');
      }
    }
    // Last resort: cached issuer inside previous snapshot
    const snap = loadCache();
    if(snap && snap.issuer){
      return snap.issuer;
    }
    throw new Error('Issuer not found via TOML. Tried: ' + tried.join(', '));
  }

  async function connectXRPL(){
    // race the endpoints — first successful wins
    const races = XRPL_ENDPOINTS.map(ep => new Promise(async (resolve, reject)=>{
      try{
        const c = new xrpl.Client(ep, { connectionTimeout: 10000 });
        await c.connect();
        resolve({client:c, ep});
      }catch(e){ reject(e); }
    }));
    // Promise.any polyfill-ish
    try{
      const winner = await Promise.any(races);
      // Close losers
      races.forEach(p => p.then(({client,ep})=>{
        if(ep!==winner.ep){ try{ client.disconnect(); }catch(e){} }
      }).catch(()=>{}));
      return winner;
    }catch(e){
      // All failed
      throw new Error('XRPL endpoints unreachable');
    }
  }

  async function getAMMPrice(client, issuer){
    // AMM reserves for BAG/XRP
    // XRP is denoted as currency: "XRP" with no issuer
    const req = {
      command: 'amm_info',
      asset:  { currency: 'BAG', issuer },
      asset2: { currency: 'XRP' }
    };
    const res = await client.request(req);
    if(!res?.result?.amm?.amount || !res?.result?.amm?.amount2){
      throw new Error('AMM reserves missing');
    }
    const A = res.result.amm.amount;   // BAG side reserve
    const B = res.result.amm.amount2;  // XRP side reserve
    const bagReserve = parseFloat(A.value);
    const xrpReserve = parseFloat(B.value);
    if(!(bagReserve>0) || !(xrpReserve>0)) throw new Error('Invalid reserves');
    // Price of 1 BAG in XRP = XRP_reserve / BAG_reserve
    const xrpPerBag = xrpReserve / bagReserve;
    return xrpPerBag;
  }

  async function getXrpUsd(){
    const r = await fetch(COINGECKO, {cache:'no-store'});
    if(!r.ok) throw new Error('XRP/USD fetch failed');
    const j = await r.json();
    const v = j?.ripple?.usd;
    if(!(v>0)) throw new Error('XRP/USD invalid');
    return Number(v);
  }

  function renderSnapshot({issuer,node,xrpUsd,bagXrp,ts}, live){
    DOM.issuer.textContent = issuer || '—';
    DOM.node.textContent = node || '—';
    DOM.xrpUsd.textContent = fmt(xrpUsd, 4);
    DOM.bagxrp.textContent = fmt(bagXrp, 6);
    const usd = (xrpUsd && bagXrp) ? (xrpUsd * bagXrp) : null;
    DOM.bagUsd.textContent = usd===null ? '—' : fmt(usd, 6);
    DOM.ts.textContent = ts ? new Date(ts).toLocaleString() : '—';

    if(live) setStatus('green', 'Live AMM');
    else setStatus('amber', 'Cached snapshot');
  }

  function renderUnavailable(){
    setStatus('red', 'Unavailable');
    DOM.node.textContent = '—';
    DOM.bagxrp.textContent = '—';
    DOM.bagUsd.textContent = '—';
  }

  async function runOnce(){
    try{
      setStatus('amber','Resolving issuer');
      const issuer = await resolveIssuer();
      state.issuer = issuer;
      DOM.issuer.textContent = issuer;

      setStatus('amber','Connecting XRPL');
      const {client, ep} = await connectXRPL();
      state.client = client;
      state.node = ep;
      DOM.node.textContent = ep;

      setStatus('amber','Pulling AMM');
      const bagXrp = await getAMMPrice(client, issuer);

      setStatus('amber','XRP/USD');
      const xrpUsd = await getXrpUsd();

      const ts = Date.now();
      state.xrpUsd = xrpUsd;
      state.bagPerXrp = bagXrp;
      state.ts = ts;

      const snap = { issuer, node: ep, xrpUsd, bagXrp, ts };
      saveCache(snap);
      renderSnapshot(snap, true);

      try{ await client.disconnect(); }catch(e){}
    }catch(e){
      // Strict fallback: last live only
      const cached = loadCache();
      if(cached && cached.xrpUsd>0 && cached.bagXrp>0){
        renderSnapshot({
          issuer: cached.issuer || state.issuer || '—',
          node: cached.node || '—',
          xrpUsd: cached.xrpUsd,
          bagXrp: cached.bagXrp,
          ts: cached.ts
        }, false);
      }else{
        renderUnavailable();
      }
    }
  }

  // Scheduler: refresh on load, then every 60s
  runOnce();
  setInterval(runOnce, 60_000);

})();
</script>
</body>
</html>
