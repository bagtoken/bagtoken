<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<meta name="format-detection" content="telephone=no" />
<title>$BAG Arcade ‚Äî Air Hockey (Demo)</title>

<style>
  :root{
    /* Core theme (mirrors Casino/Arcade style) */
    --bg:#020703; --panel:#0b1b13; --panel2:#0d2217; --line:#173524;
    --fg:#f5f7f4; --muted:#aeb7af; --gold:#ffd700; --shadow:rgba(0,0,0,.35);
    /* Frame and box geometry */
    --frame-ar: 2 / 3;             /* 1024√ó1536 portrait */
    --frame-max-h: 92vh;           /* keep some breathing room on mobile */
    --frame-max-w: 1120px;         /* don‚Äôt exceed desktop content width */
    --box-inset: 3.5%;             /* inner margin between skin edge and game box */
    --box-radius: 14px;            /* soften overlay edges */
  }

  *{box-sizing:border-box}
  html,body{margin:0;background:var(--bg);color:var(--fg);
    font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}

  /* Back link bar (same style family) */
  .backbar{position:sticky;top:0;z-index:999;background:linear-gradient(180deg,#0f1f17,#0e271c);
    border-bottom:1px solid #1b4a2f;box-shadow:0 4px 18px var(--shadow)}
  .backlink{display:inline-block;margin:10px 12px;padding:10px 14px;border-radius:12px;
    color:#08130d;text-decoration:none;font-weight:900;letter-spacing:.2px;
    background:linear-gradient(180deg,#ffe175 0%, #f5c94c 100%);
    box-shadow:0 3px 0 #b08a19;transition:transform .06s ease,box-shadow .2s ease,filter .2s ease}
  .backlink:hover{filter:brightness(1.05)}
  .backlink:active{transform:translateY(1px);box-shadow:0 2px 0 #9a7315}

  .wrap{max-width:1200px;margin:0 auto;padding:18px 12px 28px}
  .top{text-align:center;margin:4px 0 12px}
  .top h1{margin:6px 0 2px;font-size:clamp(20px,3.8vw,28px)}
  .tag{color:var(--muted)}

  /* === 1024√ó1536 SKIN FRAME ====================================== */
  .frame{
    position:relative;
    aspect-ratio:var(--frame-ar);
    margin:14px auto;
    width:min(100%, var(--frame-max-w));
    max-height:var(--frame-max-h);
    background:linear-gradient(180deg,var(--panel),var(--panel2));
    border:1px solid var(--line);
    border-radius:16px;
    box-shadow:0 10px 30px var(--shadow);
    overflow:hidden;
  }

  /* The skin image fills the frame under everything */
  .skin{
    position:absolute;inset:0;display:block;line-height:0;border-bottom:1px solid #1a3c2a;
  }
  .skin img{width:100%;height:100%;object-fit:cover;display:block}

  /* The actual game box (canvas holder) that sits on top of the skin */
  .gamebox{
    position:absolute;
    inset:var(--box-inset);
    border-radius:var(--box-radius);
    background:rgba(10,15,12,.65);
    border:1px solid rgba(39,86,61,.75);
    box-shadow:inset 0 0 40px rgba(0,0,0,.35), 0 12px 28px rgba(0,0,0,.35);
    overflow:hidden;
    display:grid;place-items:center;
  }

  /* Canvas scales fluidly with the box */
  canvas#rink{
    width:100%; height:100%;
    display:block;
    background:#0a1511; /* rink base before draw */
  }

  /* HUD */
  .hud{
    position:absolute;left:50%;top:10px;transform:translateX(-50%);
    background:rgba(0,0,0,.35);backdrop-filter:blur(6px) saturate(120%);
    border:1px solid #2b6a48;border-radius:10px;padding:6px 10px;font-weight:800;
    color:#d8efe4;font-size:13px;letter-spacing:.2px
  }

  /* Footer tip */
  .tip{
    text-align:center;color:#aab3ab;font-size:13px;margin:10px 0 0
  }

  /* Small screens: slightly reduce insets so the play area is larger */
  @media (max-width:720px){
    :root{ --box-inset: 2.5%; }
  }
</style>
</head>
<body>

<nav class="backbar" role="navigation" aria-label="Back">
  <a class="backlink" href="/arcade/" aria-label="Back to Arcade">‚¨Ö Back to Arcade</a>
</nav>

<div class="wrap">
  <div class="top">
    <h1>üèí $BAG Air Hockey ‚Äî Demo</h1>
    <div class="tag">Skin locked to 1024√ó1536. Game box expanded to match. Canvas overlays the skin.</div>
  </div>

  <!-- === SKIN + GAMEBOX ======================================== -->
  <section class="frame" aria-label="Air Hockey Game Frame">
    <!-- Skin underlay (responsive, 1024√ó1536 art) -->
    <picture class="skin" aria-hidden="true">
      <source type="image/webp"
              srcset="/arcade/assets/img/bag-airhockey-skin-960.webp 960w, /arcade/assets/img/bag-airhockey-skin-1024.webp 1024w"
              sizes="(min-width:1024px) 700px, 100vw">
      <img
        src="/arcade/assets/img/bag-airhockey-skin-1024.png"
        srcset="/arcade/assets/img/bag-airhockey-skin-960.png 960w, /arcade/assets/img/bag-airhockey-skin-1024.png 1024w"
        sizes="(min-width:1024px) 700px, 100vw"
        width="1024" height="1536" alt="">
    </picture>

    <!-- Overlay game box (fills inside edge; canvas goes here) -->
    <div class="gamebox">
      <div class="hud">Demo running ‚Äî drag to move your paddle</div>
      <canvas id="rink" width="1024" height="1536"></canvas>
    </div>
  </section>

  <p class="tip">If your skin has different safe margins, tweak <code>--box-inset</code> in <code>:root</code>.</p>
</div>

<script>
/* Minimal working demo so the page is alive.
   Replace this block with your real logic when ready.
*/
(() => {
  const canvas = document.getElementById('rink');
  const ctx = canvas.getContext('2d');

  // Make canvas pixel-perfect to its CSS size on resize
  function fitCanvas() {
    const rect = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = Math.floor(rect.width * dpr);
    const h = Math.floor(rect.height * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w; canvas.height = h;
    }
  }

  // Basic rink model in normalized space [0..1] x [0..1] for aspect independence
  const state = {
    puck: { x: 0.5, y: 0.5, vx: 0.32, vy: 0.38, r: 0.022 },
    p1:   { x: 0.5, y: 0.86, r: 0.045 },
    p2:   { x: 0.5, y: 0.14, r: 0.045 },
    friction: 0.995,
    walls: { left: 0.03, right: 0.97, top: 0.03, bottom: 0.97 },
    goals: { x1:0.3, x2:0.7, yTop:0.02, yBot:0.98, open:0.09 }
  };

  let pointer = null;

  canvas.addEventListener('pointerdown', e => { pointer = {x:e.clientX, y:e.clientY}; canvas.setPointerCapture(e.pointerId);});
  canvas.addEventListener('pointerup',   e => { pointer = null; canvas.releasePointerCapture(e.pointerId);});
  canvas.addEventListener('pointermove', e => { if (!pointer) return; pointer = {x:e.clientX, y:e.clientY}; });

  function clientToNorm(px, py){
    const rect = canvas.getBoundingClientRect();
    const x = (px - rect.left) / rect.width;
    const y = (py - rect.top)  / rect.height;
    return {x:Math.min(1,Math.max(0,x)), y:Math.min(1,Math.max(0,y))};
  }

  function circleCollide(ax,ay,ar,bx,by,br){
    const dx = bx-ax, dy = by-ay;
    const d2 = dx*dx + dy*dy, r = ar+br;
    if (d2 >= r*r) return null;
    const d = Math.sqrt(Math.max(1e-9,d2));
    return { dx, dy, d, overlap: r-d };
  }

  function step(dt){
    // simple AI: move p2 slowly towards puck x
    state.p2.x += (state.puck.x - state.p2.x) * Math.min(1, dt*1.8);

    // Player control (drag anywhere in lower half)
    if (pointer){
      const {x,y} = clientToNorm(pointer.x, pointer.y);
      const targetY = Math.max(0.55, Math.min(0.96, y));
      const targetX = Math.max(0.04, Math.min(0.96, x));
      state.p1.x += (targetX - state.p1.x) * Math.min(1, dt*16);
      state.p1.y += (targetY - state.p1.y) * Math.min(1, dt*16);
    }

    // advance puck
    state.puck.x += state.puck.vx * dt;
    state.puck.y += state.puck.vy * dt;
    state.puck.vx *= state.friction;
    state.puck.vy *= state.friction;

    // wall bounce
    const w = state.walls;
    if (state.puck.x - state.puck.r < w.left)   { state.puck.x = w.left + state.puck.r;   state.puck.vx *= -1; }
    if (state.puck.x + state.puck.r > w.right)  { state.puck.x = w.right - state.puck.r;  state.puck.vx *= -1; }
    if (state.puck.y - state.puck.r < w.top)    { state.puck.y = w.top + state.puck.r;    state.puck.vy *= -1; }
    if (state.puck.y + state.puck.r > w.bottom) { state.puck.y = w.bottom - state.puck.r; state.puck.vy *= -1; }

    // mallet collisions (elastic-ish)
    for (const m of [state.p1, state.p2]){
      const c = circleCollide(state.puck.x,state.puck.y,state.puck.r, m.x,m.y,m.r);
      if (!c) continue;
      const nx = c.dx / c.d, ny = c.dy / c.d;
      // separate
      state.puck.x -= nx * (c.overlap+1e-4);
      state.puck.y -= ny * (c.overlap+1e-4);
      // reflect velocity
      const vdotn = state.puck.vx*nx + state.puck.vy*ny;
      state.puck.vx -= 2*vdotn*nx;
      state.puck.vy -= 2*vdotn*ny;
      // add a little mallet impulse
      const boost = (m===state.p1? 0.35 : 0.25);
      state.puck.vx += nx * boost;
      state.puck.vy += ny * boost;
    }

    // naive goal check
    const g = state.goals;
    if (state.puck.x>g.x1 && state.puck.x<g.x2){
      if (state.puck.y < g.yTop + g.open){
        // player scores on top goal -> reset
        reset(1);
      } else if (state.puck.y > g.yBot - g.open){
        // ai scores bottom -> reset
        reset(-1);
      }
    }
  }

  function reset(dir){
    state.puck.x=0.5; state.puck.y=0.5;
    const s = 0.4;
    state.puck.vx = (Math.random()*0.4-0.2)*s;
    state.puck.vy = (dir>0? 1 : -1) * (0.28+Math.random()*0.18);
  }

  function draw(){
    fitCanvas();
    const W = canvas.width, H = canvas.height;

    // clear
    ctx.clearRect(0,0,W,H);

    // draw rink
    ctx.save();
    ctx.fillStyle = '#0c1f17';
    ctx.fillRect(0,0,W,H);

    // center line
    ctx.strokeStyle = '#2a6b4a'; ctx.lineWidth = Math.max(2, H*0.003);
    ctx.beginPath(); ctx.moveTo(0,H/2); ctx.lineTo(W,H/2); ctx.stroke();

    // circles
    const midR = Math.min(W,H)*0.08;
    ctx.strokeStyle = '#2b7d54'; ctx.lineWidth = Math.max(2, H*0.003);
    ctx.beginPath(); ctx.arc(W/2,H/2, midR, 0, Math.PI*2); ctx.stroke();

    // goals
    const gx1=W*state.goals.x1, gx2=W*state.goals.x2;
    ctx.beginPath();
    ctx.moveTo(gx1, H*0.02); ctx.lineTo(gx2, H*0.02);
    ctx.moveTo(gx1, H*0.98); ctx.lineTo(gx2, H*0.98);
    ctx.strokeStyle='#387f5a'; ctx.stroke();

    // puck
    const px = state.puck.x*W, py=state.puck.y*H, pr=state.puck.r*Math.min(W,H);
    ctx.fillStyle='#e05b5b'; ctx.beginPath(); ctx.arc(px,py,pr,0,Math.PI*2); ctx.fill();
    ctx.strokeStyle='#341818'; ctx.lineWidth=Math.max(1,pr*0.18); ctx.stroke();

    // mallets
    function drawM(m, col, rim){
      const x=m.x*W, y=m.y*H, r=m.r*Math.min(W,H);
      ctx.fillStyle=col; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
      ctx.strokeStyle=rim; ctx.lineWidth=Math.max(2,r*0.16); ctx.stroke();
      // small handle dot
      ctx.fillStyle='rgba(0,0,0,.25)'; ctx.beginPath(); ctx.arc(x,y,r*0.22,0,Math.PI*2); ctx.fill();
    }
    drawM(state.p1,'#d2b55a','#4b3b11');  // gold
    drawM(state.p2,'#2fbf6b','#0c4a2e');  // green

    ctx.restore();
  }

  let last=performance.now();
  function loop(t){
    const dt = Math.min(0.033, (t-last)/1000); last=t;
    step(dt);
    draw();
    requestAnimationFrame(loop);
  }

  reset(1);
  window.addEventListener('resize', fitCanvas);
  fitCanvas();
  requestAnimationFrame(loop);
})();
</script>

</body>
</html>
