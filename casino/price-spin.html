<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>The $BAG Is Right Wheel</title>
<style>
  html,body{margin:0;background:#06120d;color:#eaf3ee;font-family:Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif}
  .wrap{max-width:1100px;margin:0 auto;padding:18px}
  .board{background:linear-gradient(180deg,#0c2218,#091a13);border:1px solid #244b35;border-radius:14px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:14px}
  .marquee{text-align:center;font-weight:900;letter-spacing:.08em;color:#ffe9a6;background:linear-gradient(180deg,#17311f,#0e2419);border:1px solid #254a33;border-radius:10px;padding:8px;margin-bottom:8px}
  .stage{position:relative;height:72vh;min-height:460px;max-height:82vh;border-radius:12px;overflow:hidden;background:#0b1f16;border:1px dashed #2c6a49}
  #mount{position:absolute;inset:0}
  #hud{position:absolute;right:10px;top:10px;width:min(42vw,180px);height:min(24vw,110px);z-index:3}
  #err{position:absolute;inset:0;display:none;align-items:center;justify-content:center;text-align:center;padding:20px;background:rgba(0,0,0,.5);z-index:5}
  #err b{color:#ffb3b3}
  .row{display:flex;gap:10px;justify-content:center;flex-wrap:wrap;margin-top:12px}
  .btn{padding:14px 18px;border:0;border-radius:12px;font-weight:900;cursor:pointer}
  .spin{background:linear-gradient(180deg,#ffe175,#f5c94c);color:#0b120d;box-shadow:0 5px 0 #b08a19}
  .hold{background:linear-gradient(180deg,#d6f0e2,#cde7d9);color:#0b120d;box-shadow:0 5px 0 #7ba38d}
  .reset{background:linear-gradient(180deg,#c3c7cc,#aeb3b9);color:#0b1016;box-shadow:0 5px 0 #7b8086}
  .t{text-align:center;margin:10px 0 0}.t.win{color:#37cf82}.t.lose{color:#e65b5b}
</style>
</head>
<body>
<div class="wrap">
  <h2 style="margin:0 0 10px">ðŸŽ¡ The $BAG Is Right Wheel</h2>
  <div class="board">
    <div class="marquee">SWIPE UP/DOWN TO SPIN â€¢ UPRIGHT 3D WHEEL â€¢ Robust CDNâ†’local loader</div>
    <div class="stage">
      <div id="mount"></div>
      <canvas id="hud" width="220" height="130"></canvas>
      <div id="err"></div>
    </div>
    <div class="row">
      <button id="spinBtn" class="btn spin">SPIN</button>
      <button id="holdBtn" class="btn hold">HOLD</button>
      <button id="resetBtn" class="btn reset">RESET</button>
    </div>
    <div id="msg" class="t">Spin up to two times to reach 1.00 without going over.</div>
  </div>
</div>

<script>
(function(){
  const E=document.getElementById('err');
  function showError(html){E.style.display='flex';E.innerHTML=`<div><b>3D failed</b><br>${html}</div>`;}
  function load(src){return new Promise((res,rej)=>{const s=document.createElement('script');s.src=src;s.async=true;s.onload=res;s.onerror=rej;document.head.appendChild(s);});}
  (async()=>{try{await load('https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js');}catch(e){showError('Three.js failed to load');return;}init();})();

  function init(){
    const mount=document.getElementById('mount'),hud=document.getElementById('hud');
    const spinBtn=document.getElementById('spinBtn'),holdBtn=document.getElementById('holdBtn'),resetBtn=document.getElementById('resetBtn');
    holdBtn.disabled=true;

    // Scene + renderer
    const scene=new THREE.Scene();
    const renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
    renderer.setPixelRatio(Math.min(window.devicePixelRatio||1,2));
    renderer.setSize(mount.clientWidth,mount.clientHeight,false);
    renderer.outputColorSpace=THREE.SRGBColorSpace;
    renderer.domElement.style.width='100%';
    renderer.domElement.style.height='100%';
    mount.appendChild(renderer.domElement);

    // Camera (we'll auto-fit it to the wheel once built)
    const camera=new THREE.PerspectiveCamera(45,mount.clientWidth/mount.clientHeight,0.01,200);
    scene.add(camera);

    // Lights
    scene.add(new THREE.AmbientLight(0xffffff,0.45));
    const key=new THREE.DirectionalLight(0xffffff,1.2); key.position.set(6,7,8); scene.add(key);
    const fill=new THREE.DirectionalLight(0xffffff,0.7); fill.position.set(-6,-3,7); scene.add(fill);

    // ---------- Build the wheel ----------
    const R=2.55, DEPTH=1.1;
    const wheel=new THREE.Group(); scene.add(wheel);

    // Drum â€” axis X (so spinning around X feels like vertical pull)
    const drum=new THREE.Mesh(
      new THREE.CylinderGeometry(R,R,DEPTH,96,1,true),
      new THREE.MeshStandardMaterial({color:'#0d0d0d',metalness:.35,roughness:.75,side:THREE.DoubleSide})
    );
    drum.rotation.z=Math.PI/2; // cylinder axis â†’ X
    wheel.add(drum);

    // Front face + rim
    const face=new THREE.Mesh(
      new THREE.CircleGeometry(R-0.02,128),
      new THREE.MeshStandardMaterial({color:'#0f241b',metalness:.25,roughness:.55,side:THREE.DoubleSide})
    );
    face.rotation.y=Math.PI/2; face.position.x=DEPTH/2+0.01; wheel.add(face);

    const rim=new THREE.Mesh(
      new THREE.TorusGeometry(R+0.03,0.08,16,80),
      new THREE.MeshStandardMaterial({color:'#111',metalness:.85,roughness:.28})
    );
    rim.rotation.y=Math.PI/2; rim.position.x=DEPTH/2+0.02; wheel.add(rim);

    // Pegs
    const seq=[0.05,0.80,0.35,0.60,0.20,0.45,0.70,0.25,0.90,0.55,0.10,0.95,0.30,0.75,0.50,1.00,0.15,0.40,0.65,0.85];
    const N=seq.length, TAU=Math.PI*2, STEP=TAU/N;
    const pegGeo=new THREE.CylinderGeometry(0.06,0.06,0.32,12);
    const pegMat=new THREE.MeshStandardMaterial({color:'#d5b55c',metalness:.85,roughness:.35});
    const pegs=new THREE.Group();
    for(let i=0;i<N;i++){
      const a=i*STEP, y=Math.sin(a)*(R-0.03), z=Math.cos(a)*(R-0.03);
      const p=new THREE.Mesh(pegGeo,pegMat);
      p.position.set(DEPTH/2+0.22,y,z); p.rotation.y=Math.PI/2; pegs.add(p);
    }
    wheel.add(pegs);

    // Plates (snug ring inside the rim, all facing camera (+X))
    const labels=seq.map(v=>v.toFixed(2));
    const plates=new THREE.Group();
    const plateGeo=new THREE.PlaneGeometry(1.02,0.50); // sized for no overlap

    function plateTex(v, idx){
      const c=document.createElement('canvas'); c.width=768; c.height=384;
      const g=c.getContext('2d');
      const is100=v==='1.00', isG=(v==='0.05'||v==='0.15'), dark=!is100&&!isG&&(idx%2===0);
      const bg=is100?'#b90b0b':isG?'#1b7f3a':(dark?'#121212':'#f1f1f1');
      const fg=(is100||isG||dark)?'#f7f7f7':'#151515';
      g.fillStyle=bg; g.fillRect(0,0,c.width,c.height);
      g.strokeStyle='#d5b55c'; g.lineWidth=44; g.strokeRect(30,30,c.width-60,c.height-60);
      g.fillStyle=fg; g.font='900 210px Inter,Arial,Helvetica,sans-serif'; g.textAlign='center'; g.textBaseline='middle';
      g.fillText(is100?'100':String(Math.round(parseFloat(v)*100)), c.width/2, c.height/2+6);
      const t=new THREE.CanvasTexture(c); t.colorSpace=THREE.SRGBColorSpace; t.needsUpdate=true;
      t.anisotropy=renderer.capabilities.getMaxAnisotropy?.()||1; return t;
    }

    const plateRadius = R - 0.58; // pull in a bit so tiles sit comfortably inside the rim
    for(let i=0;i<N;i++){
      const a = i*STEP;
      const y = Math.sin(a)*plateRadius;
      const z = Math.cos(a)*plateRadius;

      const plate = new THREE.Mesh(
        plateGeo,
        new THREE.MeshBasicMaterial({map:plateTex(labels[i],i),side:THREE.DoubleSide})
      );
      plate.position.set(DEPTH/2+0.045, y, z); // a hair in front of the face
      plate.rotation.y = -Math.PI/2;           // normal â†’ +X (toward camera)
      plate.rotation.z = a;                     // follow the circular arc
      plates.add(plate);
    }
    wheel.add(plates);

    // Flapper (visual only for now)
    const flapper=new THREE.Mesh(
      new THREE.PlaneGeometry(0.5,0.28),
      new THREE.MeshStandardMaterial({color:'#e23a21',metalness:.4,roughness:.5,side:THREE.DoubleSide})
    );
    flapper.rotation.z=Math.PI/2;
    flapper.position.set(DEPTH/2+0.28,0,R*0.02);
    scene.add(flapper);

    // ---------- Auto-fit camera so the wheel is always visible ----------
    function fitCameraToObject(obj, sideAngleDeg=17){
      // camera sits on +X looking toward origin at a slight yaw so depth reads
      const box = new THREE.Box3().setFromObject(obj);
      const size = new THREE.Vector3(); box.getSize(size);
      const center = new THREE.Vector3(); box.getCenter(center);

      const fov = THREE.MathUtils.degToRad(camera.fov);
      const maxDim = Math.max(size.y, size.z);
      // distance needed from the center on +X to fit max dimension vertically
      const dist = (maxDim/2) / Math.tan(fov/2) + (size.x/2) + 1.2;

      const yaw = THREE.MathUtils.degToRad(sideAngleDeg);
      const x = dist;
      const y = size.y*0.06;     // slight high angle
      const z = dist * Math.sin(yaw);

      camera.position.set(x, y, z);
      camera.lookAt(center);
      camera.near = 0.01;
      camera.far  = dist*4 + 20;
      camera.updateProjectionMatrix();
    }

    fitCameraToObject(wheel);

    // ---------- Resize ----------
    function size(){
      const r=mount.getBoundingClientRect();
      const h=Math.max(460,r.height);
      renderer.setSize(r.width,h,false);
      camera.aspect=r.width/h;
      camera.updateProjectionMatrix();
      fitCameraToObject(wheel); // keep it framed when rotating to landscape
    }
    size(); addEventListener('resize', size);

    // ---------- HUD ----------
    function drawHUD(v){
      const g=hud.getContext('2d'), w=hud.width, h=hud.height;
      g.clearRect(0,0,w,h); g.fillStyle='#07090b'; g.fillRect(0,0,w,h);
      g.strokeStyle='#222'; g.lineWidth=6; g.strokeRect(4,4,w-8,h-8);
      g.fillStyle='#ffe26a'; g.font='700 88px "DM Mono",monospace';
      g.textAlign='center'; g.textBaseline='middle'; g.fillText((v||0).toFixed(2),w/2,h/2);
    }
    drawHUD(0);

    // ---------- Spin physics (around X) ----------
    let angX=-Math.PI/2, vel=0, spinning=false;
    const FRICTION=0.992, VMIN=0.002, PIX2RAD=0.012;
    function setAngle(a){ angX=a; wheel.rotation.x=a; }
    setAngle(-Math.PI/2);

    function startSpin(v){ vel=v; spinning=true; }
    spinBtn.onclick=()=> startSpin(6);
    resetBtn.onclick=()=>{ vel=0; spinning=false; setAngle(-Math.PI/2); };

    // Swipe input (drag up/down to flick)
    const surf=renderer.domElement, getY=e=>(e.touches?e.touches[0].clientY:e.clientY);
    let dragging=false,lastY=0,lastT=0,samples=[];
    function down(e){ if(spinning) return; dragging=true; samples.length=0; lastY=getY(e); lastT=performance.now(); e.preventDefault(); }
    function move(e){ if(!dragging) return; const y=getY(e), t=performance.now(), dy=y-lastY;
      setAngle(angX + dy*PIX2RAD);
      const dt=t-lastT; if(dt>0){ samples.push(((dy*PIX2RAD)/(dt/1000))); if(samples.length>6) samples.shift(); }
      lastY=y; lastT=t; e.preventDefault();
    }
    function up(){ if(!dragging) return; dragging=false;
      const v=samples.length?samples.reduce((a,b)=>a+b,0)/samples.length:0;
      startSpin(Math.max(1.2,Math.min(8,Math.abs(v*1.2)))*Math.sign(v||1));
    }
    surf.addEventListener('mousedown',down); addEventListener('mousemove',move); addEventListener('mouseup',up);
    surf.addEventListener('touchstart',down,{passive:false}); addEventListener('touchmove',move,{passive:false}); addEventListener('touchend',up);

    // Render loop
    function tick(){
      requestAnimationFrame(tick);
      if(spinning){
        setAngle(angX + vel*(1/60));
        vel*=FRICTION;
        if(Math.abs(vel)<VMIN) spinning=false;
      }
      renderer.render(scene,camera);
    }
    tick();
  }
})();
</script>
</body>
</html>
