  <!-- =========================================================
       [OVERLAYS] Win Overlay
       ========================================================= -->
  <div id="winOverlay" class="win-overlay" aria-hidden="true">
    <div class="win-card" role="status" aria-live="polite">
      <div class="win-title">WIN</div>
      <div class="win-amt mono" id="winAmt">+0 BAG</div>
      <div class="win-note" id="winNote">Nice hit</div>
    </div>
    <div class="confetti" id="confetti"></div>
  </div>

  <!-- =========================================================
       [AUDIO] Spin loop + FX (no external deps)
       ========================================================= -->
  <script>
  (function(){
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let AC=null, MASTER=null, lastTap=0, watchdog=null, armed=false;
    const SPIN_URL = '/assets/sounds/roulettewheel.mp3';
    let spinAudio=null;

    function getAC(){ if(AC && AC.state!=='closed') return AC; if(!AudioCtx) return null;
      AC=new AudioCtx(); MASTER=AC.createGain(); MASTER.gain.value=.22; MASTER.connect(AC.destination); return AC;}
    async function resume(){ const ac=getAC(); if(!ac) return; if(ac.state==='suspended'){ try{await ac.resume();}catch(e){} } }

    function ensureSpinAudio(){
      if(!spinAudio){
        spinAudio = new Audio(SPIN_URL);
        spinAudio.preload = 'auto';
        spinAudio.loop = true;
        spinAudio.crossOrigin = 'anonymous';
        spinAudio.volume = 0.45;
      }
      return spinAudio;
    }
    async function startSpinLoop(){ try{ await resume(); }catch{} try{ await ensureSpinAudio().play(); }catch{} }
    function stopSpinLoop(){ try{ const el=ensureSpinAudio(); el.pause(); el.currentTime=0; }catch{} }

    function chime(){ const ac=getAC(); if(!ac||ac.state!=='running') return; const now=ac.currentTime;
      [880,1320,1760].forEach((f,i)=>{ const o=getAC().createOscillator(); o.type='triangle'; o.frequency.value=f;
        const g=getAC().createGain(); g.gain.setValueAtTime(.0001,now+i*.02); g.gain.linearRampToValueAtTime(.18,now+i*.02+.04); g.gain.exponentialRampToValueAtTime(.0001,now+i*.02+.32);
        o.connect(g).connect(MASTER); o.start(now+i*.02); o.stop(now+i*.02+.34); });
    }
    function thud(){ const ac=getAC(); if(!ac||ac.state!=='running') return; const o=getAC().createOscillator(), g=getAC().createGain(); o.type='sine';
      const t=ac.currentTime; o.frequency.setValueAtTime(260,t); o.frequency.exponentialRampToValueAtTime(140,t+.22);
      g.gain.setValueAtTime(.0001,t); g.gain.linearRampToValueAtTime(.10,t+.02); g.gain.exponentialRampToValueAtTime(.0001,t+.25);
      o.connect(g).connect(MASTER); o.start(t); o.stop(t+.27); }

    addEventListener('pointerdown', ()=>{ lastTap=Date.now(); resume(); }, {passive:true});
    addEventListener('pointerdown', async ()=>{ if(armed) return; armed=true; await resume();
      try{ const o=getAC().createOscillator(), g=getAC().createGain(); g.gain.value=.0001; o.connect(g).connect(MASTER); o.start(); o.stop(getAC().currentTime+.02);}catch{} }, {once:true, passive:true});
    addEventListener('visibilitychange', ()=>{ if(!document.hidden) resume(); });
    if(!watchdog) watchdog=setInterval(()=>{ const ac=getAC(); if(!ac) return; if(Date.now()-lastTap<30000 && ac.state==='suspended') resume(); },1500);

    window.__bagAudio = { chime, thud, startSpinLoop, stopSpinLoop, resume };
  })();
  </script>

  <!-- =========================================================
       [GUARDS] Touch / Gesture
       ========================================================= -->
  <script>
  (function(){
    document.addEventListener('touchend', (e)=>{
      const n = Date.now();
      if(!window.__bagLastTouch) window.__bagLastTouch = n;
      if(n - window.__bagLastTouch < 300) e.preventDefault();
      window.__bagLastTouch = n;
    }, {passive:false});
    ['gesturestart','gesturechange','gestureend'].forEach(ev=>document.addEventListener(ev,(e)=>e.preventDefault(),{passive:false}));
    document.addEventListener('wheel',(e)=>{ if(e.ctrlKey) e.preventDefault(); },{passive:false});
  })();
  </script>

  <!-- =========================================================
       [PRICES] XRPL AMM (BAG/XRP) + CoinGecko XRP
       ========================================================= -->
  <script>
  (function(){
    const PRICE_REFRESH_MS = 15000;
    const FETCH_TIMEOUT_MS = 8000;

    const BAG_ISSUER = 'rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr';
    const BAG_CODE = 'BAG';

    const PRICES = (window.__PRICES__ = { bagUsd:0, xrpUsd:0, source:'—' });
    const liveDot = document.getElementById('liveDot');
    const liveBAG = document.getElementById('liveBAG');
    const liveXRP = document.getElementById('liveXRP');
    const liveNote = document.getElementById('liveNote');
    const liveConv = document.getElementById('liveConv');

    function fmt(n){ if(!Number.isFinite(n)) return '—'; return n.toLocaleString(undefined,{maximumFractionDigits:6}); }

    function updateUI(){
      if (liveBAG)  liveBAG.textContent  = fmt(PRICES.bagUsd);
      if (liveXRP)  liveXRP.textContent  = Number.isFinite(PRICES.xrpUsd)
        ? PRICES.xrpUsd.toLocaleString(undefined,{minimumFractionDigits:2, maximumFractionDigits:2})
        : '—';
      if (liveDot)  liveDot.className    = (PRICES.source==='live-amm' ? 'ok' : (PRICES.source==='cache' ? 'warn' : 'warn'));
      if (liveNote) liveNote.textContent = (PRICES.source==='live-amm' ? ' (AMM live)' : PRICES.source==='cache' ? ' (cached)' : ' (fallback)');
      if (liveConv){
        if(PRICES.bagUsd>0 && PRICES.xrpUsd>0){
          const xrpPerBag = PRICES.bagUsd/PRICES.xrpUsd;
          const bagPerXrp = PRICES.xrpUsd/PRICES.bagUsd;
          liveConv.innerHTML = '1 BAG &asymp; ' + xrpPerBag.toLocaleString(undefined,{maximumFractionDigits:6}) + ' XRP · 1 XRP &asymp; ' + bagPerXrp.toLocaleString(undefined,{maximumFractionDigits:6}) + ' BAG';
        } else {
          liveConv.textContent = '1 BAG ≈ — XRP · 1 XRP ≈ — BAG';
        }
      }
      window.dispatchEvent(new CustomEvent('bag:pricesUpdated'));
    }

    function timedFetch(url, opts={}, timeout=FETCH_TIMEOUT_MS){
      const ctrl = new AbortController();
      const id = setTimeout(()=>ctrl.abort(new Error('timeout')), timeout);
      return fetch(url, {...opts, signal:ctrl.signal}).finally(()=>clearTimeout(id));
    }

    async function fetchXRP(){
      try{
        const r = await timedFetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
        const v = (await r.json())?.ripple?.usd;
        if(Number(v)>0){ PRICES.xrpUsd = Number(v); return true; }
      }catch{}
      try{
        const r2 = await timedFetch('https://api.coingecko.com/api/v3/simple/price?ids=xrp&vs_currencies=usd');
        const v2 = (await r2.json())?.xrp?.usd;
        if(Number(v2)>0){ PRICES.xrpUsd = Number(v2); return true; }
      }catch{}
      return false;
    }

    function parseXrpAmount(a){ if (a==null) return null; if (typeof a==='string') return Number(a)/1_000_000; if (typeof a==='object' && a.currency==='XRP') return Number(a.value); return null; }
    function parseIouAmount(a){ if (!a || typeof a!=='object') return null; return Number(a.value); }

    async function fetchBAGFromAMM(){
      const req = { id:1, command:'amm_info', asset:{currency:BAG_CODE,issuer:BAG_ISSUER}, asset2:{currency:'XRP'} };
      const xrpPerBag = await new Promise((resolve)=>{
        const ws = new WebSocket('wss://s1.ripple.com');
        const t = setTimeout(()=>{ try{ws.close();}catch{}; resolve(null); }, 8000);
        ws.onopen = ()=> ws.send(JSON.stringify(req));
        ws.onerror = ()=>{ clearTimeout(t); try{ws.close();}catch{}; resolve(null); };
        ws.onmessage = (ev)=>{
          try{
            const msg = JSON.parse(ev.data);
            if (msg.id!==1 || !msg.result || !msg.result.amm) return;
            clearTimeout(t); try{ws.close();}catch{};
            const amm = msg.result.amm;
            const bagBal = parseIouAmount(amm.amount);
            const xrpBal = parseXrpAmount(amm.amount2);
            if (!(bagBal>0) || !(xrpBal>0)) return resolve(null);
            resolve(xrpBal / bagBal);
          }catch{ resolve(null); }
        };
      });
      if (!(xrpPerBag>0)) return false;
      if (!(PRICES.xrpUsd>0)) return false;
      PRICES.bagUsd = PRICES.xrpUsd * xrpPerBag;
      PRICES.source = 'live-amm';
      return true;
    }

    function readCache(){
      try{
        const v = JSON.parse(localStorage.getItem('__bag_price_cache_v1')||'null');
        if (v && v.ts && (Date.now()-v.ts) < 60*60*1000 && v.bagUsd>0 && v.xrpUsd>0){
          PRICES.bagUsd = v.bagUsd; PRICES.xrpUsd = v.xrpUsd; PRICES.source='cache'; return true;
        }
      }catch{}
      return false;
    }
    function writeCache(){
      try{ localStorage.setItem('__bag_price_cache_v1', JSON.stringify({bagUsd:PRICES.bagUsd, xrpUsd:PRICES.xrpUsd, ts:Date.now()})); }catch{}
    }

    (async function refresh(){
      let okX = await fetchXRP();
      let okB = await fetchBAGFromAMM();
      if (!(okX && okB)){
        if (!readCache()){
          if (!okX){ PRICES.xrpUsd = 0.50; }
          PRICES.bagUsd = 0.02; // fallback
          PRICES.source = 'fallback';
        }
      } else {
        writeCache();
      }
      updateUI();
      setTimeout(refresh, PRICE_REFRESH_MS);
    })();
  })();
  </script>

  <!-- =========================================================
       [SESSION] Universal Demo Session v2
       ========================================================= -->
  <script src="/js/bag-demo-session.js"></script>

  <!-- =========================================================
       [STAKE UI] Practice balances + Converter + Presets + Labels
       ========================================================= -->
  <script>
  (function(){
    const $ = (s)=>document.querySelector(s);
    const usdInput   = $('#usdBet');
    const qtyInput   = $('#betQty');
    const unitSpan   = document.querySelector('.unit');
    const curWrap    = $('#curToggle');
    const betLbl     = $('#betLbl');

    // Balances hooks
    const balBagEl = document.getElementById('balBag');
    const balXrpEl = document.getElementById('balXrp');
    const balUsdEl = document.getElementById('balUsd');

    // track which input was last edited to avoid "jumping" on currency toggle
    let lastEdited = 'usd'; // 'usd' | 'units'

    function selCur(){ return curWrap?.querySelector('input[name="betCur"]:checked')?.value || 'XRP'; }
    function P(){ return window.__PRICES__ || { bagUsd:0, xrpUsd:0, source:'—' }; }
    function pxFor(cur){ const p=P(); return cur==='BAG' ? (p.bagUsd||0) : (p.xrpUsd||0); }
    function fmt(n, max=6){ const x=Number(n); if(!Number.isFinite(x)) return '—'; return x.toLocaleString(undefined,{maximumFractionDigits:max}); }

    function bagFromUnits(qty, cur){
      const p = P();
      if (cur==='BAG') return qty;
      if (p.bagUsd>0 && p.xrpUsd>0){
        const bagPerXrp = p.xrpUsd / p.bagUsd;
        return qty * bagPerXrp;
      }
      return 0;
    }

    function updateUsdFromUnits(){
      const cur = selCur();
      const px  = pxFor(cur);
      const qty = Math.max(0, parseFloat(qtyInput.value||'0'));
      const usd = px>0 ? qty*px : 0;
      usdInput.value = usd>0 ? usd.toFixed(2) : '';
      betLbl && (betLbl.textContent = Number.isFinite(qty) ? qty.toFixed(6).replace(/\.?0+$/,'') : '—');
      renderBalances();
      renderPayoutScale(); // dynamic payouts
    }
    function updateUnitsFromUsd(){
      const cur = selCur();
      const px  = pxFor(cur);
      const raw = Math.min(2000, Math.max(0, parseFloat(usdInput.value||'0')));
      if (!Number.isFinite(raw) || raw<=0 || px<=0) { renderBalances(); renderPayoutScale(); return; }
      const units = raw/px;
      const out = units.toFixed(6).replace(/\.?0+$/,'');
      qtyInput.value = out;
      betLbl && (betLbl.textContent = out);
      renderBalances();
      renderPayoutScale(); // dynamic payouts
    }

    function balances(){
      const sess = (window.__bagSession && window.__bagSession.get && window.__bagSession.get()) || {};
      const bag = Number(sess.bag)||0;
      let xrp = Number(sess.xrp);
      const { bagUsd, xrpUsd } = P();
      if (!(xrp > 0)) {
        xrp = (bagUsd>0 && xrpUsd>0) ? bag * (bagUsd/xrpUsd) : 0;
      }
      const usd = (bagUsd>0) ? bag * bagUsd : 0;
      return {bag,xrp,usd};
    }
    function renderBalances(){
      const {bag,xrp,usd} = balances();
      if (balBagEl) balBagEl.textContent = fmt(bag,6);
      if (balXrpEl) balXrpEl.textContent = fmt(xrp,6);
      if (balUsdEl) balUsdEl.textContent = fmt(usd,2);
    }

    // === Dynamic Pay Scale numbers (Your Payouts) ===
    function renderPayoutScale(){
      const tiers = [1.00,1.25,1.50,1.75,2.00];
      const cur = selCur();
      const qty = Math.max(0, parseFloat(qtyInput.value||'0'));
      const bagStake = bagFromUnits(qty, cur);
      const bagUsd = P().bagUsd || 0;

      const vals = tiers.map(t=>{
        const winBag = bagStake * t;
        const winUsd = (bagUsd>0) ? (winBag * bagUsd) : 0;
        return `×${t.toFixed(2)} → +${winBag.toLocaleString(undefined,{maximumFractionDigits:6})} BAG${bagUsd>0?` (~$${winUsd.toLocaleString(undefined,{maximumFractionDigits:2})})`:''}`;
      });

      const el = document.getElementById('payoutVals');
      if (el) el.textContent = vals.join(' · ');
    }

    // Inputs + events
    usdInput?.addEventListener('input', ()=>{ lastEdited='usd'; updateUnitsFromUsd(); });
    qtyInput?.addEventListener('input', ()=>{ lastEdited='units'; updateUsdFromUnits(); });

    curWrap?.addEventListener('change', ()=>{
      document.querySelector('.unit').textContent = selCur();
      if (lastEdited === 'usd') updateUnitsFromUsd(); else updateUsdFromUnits();
    });

    // Presets (set USD, recompute units)
    (function mountPresets(){
      const row = document.getElementById('usdPresets');
      if (!row) return;
      row.querySelectorAll('button[data-usd]').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          const tag = btn.getAttribute('data-usd'); const val = (tag==='2000')?2000:Number(tag||0);
          usdInput.value = Number(val).toFixed(2);
          lastEdited='usd';
          updateUnitsFromUsd();
          row.querySelectorAll('button[data-usd]').forEach(x=>x.classList.remove('selected'));
          btn.classList.add('selected');
        });
      });
    })();

    // React to live prices + universal session refresh events
    window.addEventListener('bag:pricesUpdated', ()=>{ if (lastEdited==='usd') updateUnitsFromUsd(); else updateUsdFromUnits(); renderBalances(); });
    window.addEventListener('bag:hudRefresh', renderBalances);
    window.addEventListener('bag:sessionToppedUp', renderBalances);
    window.addEventListener('bag:sessionSpent', renderBalances);

    // Initial
    updateUnitsFromUsd();
    renderBalances();
    renderPayoutScale();
  })();
  </script>

  <!-- =========================================================
       [WALLET] Xaman Connect (kept, no-op in demo)
       ========================================================= -->
  <script>
  (function(){
    const WALLET_KEY = 'bag_wallet_v1';
    const API_KEY = '48d8a5b2-0f90-4c5a-b5c2-3d7c8fd6113f';

    const btn = document.getElementById('connectBtn');
    const statusEl = document.getElementById('connectStatus');
    if (!btn || !statusEl) return;

    const read  = () => { try { return JSON.parse(localStorage.getItem(WALLET_KEY)||'null'); } catch { return null; } };
    const write = (w) => { try { localStorage.setItem(WALLET_KEY, JSON.stringify(w)); } catch {} };
    const clear = () => { try { localStorage.removeItem(WALLET_KEY); } catch {} };

    function short(a){ try{ const s=String(a||''); return s? s.slice(0,6)+'…'+s.slice(-4):''; }catch{ return ''; } }

    function render(){
      const w = read();
      if (w?.address){
        statusEl.innerHTML = 'Wallet: <span style="color:#2fbf6b">'+short(w.address)+'</span>';
        btn.textContent = 'Disconnect';
      } else {
        statusEl.innerHTML = 'Wallet: <span style="color:#e8a85c">not connected</span>';
        btn.textContent = 'Connect Xaman';
      }
    }

    let xumm = null, ready = false, tries = 0;
    function initIfSdk(){
      if (ready) return true;
      if (typeof window.Xumm === 'function'){
        xumm = new Xumm(API_KEY);
        ready = true;
        xumm.on('success', () => {
          try{
            const acct = xumm?.user?.account || null;
            if (acct){
              write({ address: String(acct), ts: Date.now(), kind: 'xaman' });
              window.dispatchEvent(new CustomEvent('bag:walletConnected', { detail: { address: String(acct) }}));
              render();
            }
          }catch(e){}; 
        });
        xumm.on('ready', () => { render(); });
        return true;
      }
      if (tries++ < 60) setTimeout(initIfSdk, 200);
      return false;
    }

    async function connectXaman(){
      if (!ready && !initIfSdk()){
        alert('Loading Xaman… try again in a moment.');
        return;
      }
      btn.disabled = true;
      try {
        const auth = await xumm.authorize();
        const acct = (xumm && xumm.user && xumm.user.account) || auth?.me?.account || null;
        if (!acct) throw new Error('No account returned');
        write({ address: String(acct), ts: Date.now(), kind: 'xaman' });
        window.dispatchEvent(new CustomEvent('bag:walletConnected', { detail: { address: String(acct) }}));
        render();
      } catch (e) {
      } finally {
        btn.disabled = false;
      }
    }

    btn.addEventListener('click', async ()=>{
      const w = read();
      if (w?.address){ clear(); window.dispatchEvent(new CustomEvent('bag:walletDisconnected')); render(); }
      else { await connectXaman(); }
    });

    render(); initIfSdk();
  })();
  </script>

  <!-- =========================================================
       [FELT] Build Board + Selection State
       ========================================================= -->
  <script>
  (function(){
    const feltNums = document.getElementById('feltNums');
    const colBets = document.getElementById('colBets');
    const outside = document.getElementById('outsideBets');
    const zeroRow = document.getElementById('zeroRow');
    if(!feltNums || !colBets || !outside || !zeroRow) return;

    const RED = new Set([1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36]);
    const BLACK = new Set([2,4,6,8,10,11,13,15,17,20,22,24,26,28,29,31,33,35]);
    const colorOf = (n)=> (n===0 || n==='00') ? 'green' : (RED.has(n)?'red':'black');

    function makeNumCell(n){
      const d=document.createElement('div');
      d.className='cell num ' + colorOf(n);
      d.dataset.val=String(n);
      d.innerHTML = '<div class="num-inner"><div class="half"></div><div class="half"></div></div><div class="label">'+n+'</div>';
      return d;
    }

    zeroRow.innerHTML=''; zeroRow.appendChild(makeNumCell('0')); zeroRow.appendChild(makeNumCell('00'));

    feltNums.innerHTML='';
    for(let i=0;i<12;i++){
      const n1=3+i*3, n2=2+i*3, n3=1+i*3;
      [n1,n2,n3].forEach(n=> feltNums.appendChild(makeNumCell(n)));
    }

    colBets.innerHTML='';
    ['C1','C2','C3'].forEach(c=>{
      const d=document.createElement('div'); d.className='cell'; d.textContent='2:1'; d.dataset.type='COL'; d.dataset.val=c;
      colBets.appendChild(d);
    });

    const allNums = () => feltNums.querySelectorAll('.cell.num, #zeroRow .cell.num');
    const allCols = () => colBets.querySelectorAll('.cell');
    const allOutside = () => outside.querySelectorAll('.cell');
    let straight='', RB='', EO='', HL='', D='', COL='';

    function syncHidden(){
      document.getElementById('betStraight').value = straight;
      document.getElementById('betRB').value = RB;
      document.getElementById('betEO').value = EO;
      document.getElementById('betHL').value = HL;
      document.getElementById('betDozen').value = D;
      document.getElementById('betCol').value = COL;
    }

    document.addEventListener('click', (e)=>{
      const t=e.target.closest('.cell'); if(!t) return;
      if (t.classList.contains('num')){
        allNums().forEach(x=>x.classList.remove('selected'));
        t.classList.add('selected');
        straight = t.dataset.val || '';
        const v = straight==='00' ? null : Number(straight);
        D   = (!v||v===0)? '' : (v<=12?'D1' : v<=24?'D2':'D3');
        COL = (!v||v===0)? '' : (v%3===1?'C1' : v%3===2?'C2':'C3');
        syncHidden(); return;
      }
      if (t.closest('#colBets')){
        allCols().forEach(x=>x.classList.remove('selected'));
        t.classList.add('selected'); COL = String(t.dataset.val||''); syncHidden(); return;
      }
      if (t.closest('#outsideBets')){
        const type = t.dataset.type, val = t.dataset.val;
        if (type==='RB'){ allOutside().forEach(x=>{ if(x.dataset.type==='RB') x.classList.remove('selected'); }); t.classList.add('selected'); RB = val; }
        else if (type==='EO'){ allOutside().forEach(x=>{ if(x.dataset.type==='EO') x.classList.remove('selected'); }); t.classList.add('selected'); EO = val; }
        else if (type==='HL'){ allOutside().forEach(x=>{ if(x.dataset.type==='HL') x.classList.remove('selected'); }); t.classList.add('selected'); HL = val; }
        syncHidden(); return;
      }
    });
  })();
  </script>

  <!-- =========================================================
       [ENGINE] Wheel Geometry + Spin + Pay Scale Engine
       ========================================================= -->
  <script>
  (function(){
    // American sequence (locked)
    const WHEEL = ["00",27,10,25,29,12,8,19,31,18,6,21,33,16,4,23,35,14,2,0,28,9,26,30,11,7,20,32,17,5,22,34,15,3,24,36,13,1];

    // Colors
    const COLOR = {}; ["00",0].forEach(n=>COLOR[n]="green");
    [1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36].forEach(n=>COLOR[n]="red");
    [2,4,6,8,10,11,13,15,17,20,22,24,26,28,29,31,33,35].forEach(n=>COLOR[n]="black");

    // Columns
    const COLUMN = {};
    [1,4,7,10,13,16,19,22,25,28,31,34].forEach(n=>COLUMN[n]="C1");
    [2,5,8,11,14,17,20,23,26,29,32,35].forEach(n=>COLUMN[n]="C2");
    [3,6,9,12,15,18,21,24,27,30,33,36].forEach(n=>COLUMN[n]="C3");

    // DOM
    const svg = document.getElementById('ringSvg');
    const ringG = document.getElementById('ringG');
    const clipP = document.getElementById('ringClipPath');
    const ball = document.getElementById('ball');
    const spinBtn = document.getElementById('spinBtn');
    const spinText = document.getElementById('spinText');
    const winOverlay = document.getElementById('winOverlay');
    const winAmtEl = document.getElementById('winAmt');
    const winNoteEl = document.getElementById('winNote');
    const confetti = document.getElementById('confetti');
    if (!svg || !ringG || !clipP || !ball || !spinBtn) return;

    // Geometry
    const MARKER_DEG   = 0;      // ball rests at CSS 0° (to the RIGHT)
    const cx=500, cy=500;
    const R0=338, R1=492;        // inner/outer ring radii (long wedges)
    const labelR = 452;
    const DEG = 360 / WHEEL.length;

    // Build clip (donut)
    function circlePath(r){ return `M ${cx} ${cy} m -${r},0 a ${r},${r} 0 1,0 ${2*r},0 a ${r},${r} 0 1,0 -${2*r},0`; }
    clipP.setAttribute('d', circlePath(R1) + ' ' + circlePath(R0));

    // Polar helper
    function pol(r, angTop){
      const a=(angTop-90)*Math.PI/180;
      return [cx + r*Math.cos(a), cy + r*Math.sin(a)];
    }

    // Build wedges + labels
    ringG.innerHTML='';
    for(let i=0;i<WHEEL.length;i++){
      const a0 = i*DEG, a1 = (i+1)*DEG, am = a0 + DEG/2;

      const [x0,y0] = pol(R1,a0), [x1,y1] = pol(R1,a1);
      const [x2,y2] = pol(R0,a1), [x3,y3] = pol(R0,a0);

      const p = document.createElementNS('http://www.w3.org/2000/svg','path');
      p.setAttribute('d', `M ${x0} ${y0} A ${R1} ${R1} 0 0 1 ${x1} ${y1} L ${x2} ${y2} A ${R0} ${R0} 0 0 0 ${x3} ${y3} Z`);
      const c = COLOR[WHEEL[i]]||'black';
      p.setAttribute('fill', c==='red' ? '#cf2b2b' : c==='black' ? '#141414' : '#1b7b3a');
      p.setAttribute('stroke','#000'); p.setAttribute('stroke-width','2');
      ringG.appendChild(p);

      const [tx, ty] = pol(labelR, am);
      const t = document.createElementNS('http://www.w3.org/2000/svg','text');
      t.setAttribute('x', tx); t.setAttribute('y', ty);
      t.setAttribute('transform', `rotate(${am-90} ${tx} ${ty})`);
      t.textContent = String(WHEEL[i]);
      ringG.appendChild(t);
    }

    // State + transforms
    const state = { ringDeg: 0, ballDeg: MARKER_DEG };

    function ringBoxSize(){ return svg.getBoundingClientRect().width || 300; }
    function ballRadiusPx(){ return Math.max(60, Math.round(ringBoxSize() * 0.345)); }

    function setTransforms(rDeg, bDeg, rpx){
      state.ringDeg = rDeg;
      state.ballDeg = bDeg;
      ringG.style.transform = `rotate(${rDeg}deg)`;
      ball.style.transform  = `rotate(${bDeg}deg) translate(${rpx}px)`;
    }

    requestAnimationFrame(()=> setTransforms(0, MARKER_DEG, ballRadiusPx()));
    addEventListener('resize', ()=> setTransforms(state.ringDeg, state.ballDeg, ballRadiusPx()));

    // Spin engine
    let spinning=false;
    function randSeed(){ const a=new Uint32Array(1); crypto.getRandomValues(a); return a[0]; }

    function stakeBag(){
      const p = window.__PRICES__ || {};
      const c = (document.querySelector('#curToggle input[name="betCur"]:checked')?.value || 'XRP').toUpperCase();
      const qty = Math.max(0, parseFloat(document.getElementById('betQty')?.value||'0'));
      if (c==='BAG') return qty;
      if (p.bagUsd>0 && p.xrpUsd>0){ return qty * (p.xrpUsd/p.bagUsd); }
      return 0;
    }
    function stakeUsd(){
      const p = window.__PRICES__ || {};
      const qty = Math.max(0, parseFloat(document.getElementById('betQty')?.value||'0'));
      const c = (document.querySelector('#curToggle input[name="betCur"]:checked')?.value || 'XRP').toUpperCase();
      const px = (c==='BAG') ? (p.bagUsd||0) : (p.xrpUsd||0);
      return px>0 ? qty*px : 0;
    }

    function showWinOverlay(amountBag, hit, notes){
      try{
        if (!winOverlay) return;
        winAmtEl.textContent = '+' + amountBag.toLocaleString(undefined,{maximumFractionDigits:6}) + ' BAG';
        winNoteEl.textContent = 'Hit ' + String(hit) + (notes && notes.length ? ' • ' + notes.join(', ') : '');
        winOverlay.style.display = 'flex';
        winOverlay.setAttribute('aria-hidden','false');

        if (confetti){
          confetti.innerHTML = '';
          const N = 42;
          for (let i=0;i<N;i++){
            const s = document.createElement('span');
            if (i%3===0) s.classList.add('alt');
            if (i%9===0) s.classList.add('dark');
            const angle = (Math.PI * 2) * (i/N);
            const radius = 120 + Math.random()*120;
            const dx = Math.cos(angle) * radius;
            const dy = Math.sin(angle) * radius + 40 + Math.random()*80;
            s.style.setProperty('--dx', dx.toFixed(1)+'px');
            s.style.setProperty('--dy', dy.toFixed(1)+'px');
            s.style.animationDelay = (Math.random()*0.15)+'s';
            s.style.rotate = (Math.random()*360)+'deg';
            confetti.appendChild(s);
          }
        }

        setTimeout(()=>{
          if (!winOverlay) return;
          winOverlay.style.display = 'none';
          winOverlay.setAttribute('aria-hidden','true');
          if (confetti) confetti.innerHTML='';
        }, 1600);
      }catch{}
    }

    document.getElementById('spinBtn').addEventListener('click', async ()=>{
      if (spinning) return;

      const sBag = stakeBag(), sUsd = stakeUsd();
      if (sUsd < 1 && !window.__BAG_FORCE_DEMO){ alert('Minimum $1 stake'); return; }
      if (!window.__BAG_FORCE_DEMO){
        if (!(window.__bagSession && window.__bagSession.spend && window.__bagSession.spend(sBag))) return;
      } else {
        if (window.__bagSession && window.__bagSession.spend) window.__bagSession.spend(sBag);
      }

      spinning = true;
      const btn = document.getElementById('spinBtn');
      btn.disabled = true; spinText.className='t'; spinText.textContent='Spinning…';

      try{ window.__bagAudio?.resume?.(); window.__bagAudio?.startSpinLoop?.(); }catch{}

      // Result
      const seed = randSeed();
      const idx = Math.floor((seed / 0x100000000) * WHEEL.length);
      const hit = WHEEL[idx];

      // Animation plan
      const DURATION_MS = 9000;
      const ringRevs = 16;
      const ballRevs = 24;

      // Center of the winning pocket measured from TOP (SVG space)
      const pocketCenterTop = idx*DEG + DEG/2;

      // ABS target for ring: land winner at right marker
      const desiredAbs = 0 + 90 - pocketCenterTop;

      const rpx = ballRadiusPx();

      const ringTarget = 360*ringRevs + desiredAbs;
      const ballTarget = state.ballDeg - 360*ballRevs;

      ringG.style.transition = `transform ${DURATION_MS}ms cubic-bezier(.2,.9,.2,1)`;
      ball.style.transition  = `transform ${DURATION_MS}ms cubic-bezier(.2,.9,.2,1)`;

      requestAnimationFrame(()=> setTransforms(ringTarget, ballTarget, rpx));

      setTimeout(()=>{
        try{ window.__bagAudio?.stopSpinLoop?.(); }catch{}

        // Selections
        const b = {
          straight:(document.getElementById('betStraight').value||'').trim().toUpperCase(),
          rb:document.getElementById('betRB').value,
          eo:document.getElementById('betEO').value,
          hl:document.getElementById('betHL').value,
          dozen:document.getElementById('betDozen').value,
          col:document.getElementById('betCol').value
        };

        // Pay scale
        const TIERS = [1.00, 1.25, 1.50, 1.75, 2.00];
        const DEMO = (window.__BAG_FORCE_DEMO === true);
        function pickTier(betType){
          let w;
          if (betType === 'OUTSIDE'){
            w = DEMO ? [0.44, 0.38, 0.12, 0.05, 0.01]
                     : [0.58, 0.30, 0.08, 0.035, 0.005];
          } else if (betType === 'MID'){
            w = DEMO ? [0.40, 0.34, 0.16, 0.07, 0.03]
                     : [0.50, 0.30, 0.12, 0.06, 0.02];
          } else {
            w = DEMO ? [0.38, 0.30, 0.17, 0.10, 0.05]
                     : [0.46, 0.28, 0.14, 0.08, 0.04];
          }
          let r = Math.random();
          for (let i=0;i<w.length;i++){ if ((r-=w[i])<=0) return TIERS[i]; }
          return TIERS[TIERS.length-1];
        }

        const colorH = COLOR[hit];
        const isNum  = (n)=> typeof n==="number" && isFinite(n);

        function hitStraight(){
          if (!b.straight) return false;
          if (b.straight === '00') return hit === "00";
          const v = Number(b.straight);
          return isNum(v) && v>=0 && v<=36 && hit === v;
        }
        function hitRB(){
          if (!b.rb || !colorH) return false;
          return colorH.toUpperCase() === b.rb;
        }
        function hitEO(){
          if (!b.eo || !isNum(hit) || hit===0) return false;
          return (b.eo==="EVEN" && hit%2===0) || (b.eo==="ODD" && hit%2===1);
        }
        function hitHL(){
          if (!b.hl || !isNum(hit) || hit===0) return false;
          return (b.hl==="LOW"  && hit>=1  && hit<=18) ||
                 (b.hl==="HIGH" && hit>=19 && hit<=36);
        }
        function hitDozen(){
          if (!b.dozen || !isNum(hit) || hit===0) return false;
          return (b.dozen==="D1" && hit>=1  && hit<=12) ||
                 (b.dozen==="D2" && hit>=13 && hit<=24) ||
                 (b.dozen==="D3" && hit>=25 && hit<=36);
        }
        function hitCol(){
          if (!b.col || !isNum(hit) || hit===0) return false;
          return COLUMN[hit] === b.col;
        }

        const baseStake = sBag;
        let totalWin = 0;
        const notes = [];

        if (hitStraight()){ const t = pickTier('INSIDE'); totalWin += baseStake * t; notes.push(`Straight ×${t.toFixed(2)}`); }
        if (hitRB()){       const t = pickTier('OUTSIDE'); totalWin += baseStake * t; notes.push(`RB ×${t.toFixed(2)}`); }
        if (hitEO()){       const t = pickTier('OUTSIDE'); totalWin += baseStake * t; notes.push(`EO ×${t.toFixed(2)}`); }
        if (hitHL()){       const t = pickTier('OUTSIDE'); totalWin += baseStake * t; notes.push(`HL ×${t.toFixed(2)}`); }
        if (hitDozen()){    const t = pickTier('MID');     totalWin += baseStake * t; notes.push(`Dozen ×${t.toFixed(2)}`); }
        if (hitCol()){      const t = pickTier('MID');     totalWin += baseStake * t; notes.push(`Column ×${t.toFixed(2)}`); }

        document.getElementById('lastLbl').textContent = String(hit);

        if (totalWin > 0){
          try{ window.__bagAudio?.chime?.(); }catch{}
          window.__bagSession?.credit?.(totalWin);
          spinText.className='t win';
          spinText.textContent = `WIN on ${String(hit)} · +${totalWin.toLocaleString(undefined,{maximumFractionDigits:6})} BAG` +
                                 (notes.length ? ` (${notes.join(', ')})` : '');
          showWinOverlay(totalWin, hit, notes);
          window.dispatchEvent(new Event('bag:hudRefresh'));
        } else {
          try{ window.__bagAudio?.thud?.(); }catch{}
          spinText.className='t lose';
          spinText.textContent = `Lose on ${String(hit)} — try again`;
        }

        const norm = d => ((d % 360) + 360) % 360;
        const finalRing = norm(ringTarget);

        ringG.style.transition = 'none';
        ball.style.transition = 'none';
        setTransforms(finalRing, MARKER_DEG, rpx);

        const ballFinal = `rotate(${MARKER_DEG}deg) translate(${rpx}px)`;
        ball.style.setProperty('--finalBall', ballFinal);
        ball.style.setProperty('--finalBallDeg', `${MARKER_DEG}deg`);
        ball.style.setProperty('--finalBallR', `${rpx}px`);
        ball.classList.remove('bounce'); void ball.offsetWidth; ball.classList.add('bounce');

        spinning = false; btn.disabled = false;
      }, DURATION_MS + 60);
    });
  })();
  </script>

  <!-- =========================================================
       [HUD] Mirror chips
       ========================================================= -->
  <script>
  (function(){
    function PR(){ return window.__PRICES__ || { bagUsd:0, xrpUsd:0 }; }
    function fmt(n, max=6){ const x=Number(n); if(!Number.isFinite(x)) return '—'; return x.toLocaleString(undefined,{maximumFractionDigits:max}); }
    function cur(){ const el=document.querySelector('#curToggle input[name="betCur"]:checked'); return el?String(el.value).toUpperCase():'XRP'; }
    function balances(){
      const sess = (window.__bagSession && window.__bagSession.get && window.__bagSession.get()) || {};
      const bag = Number(sess.bag)||0;
      let xrp = Number(sess.xrp);
      const { bagUsd, xrpUsd } = PR();
      if (!(xrp > 0)) {
        xrp = (bagUsd>0 && xrpUsd>0) ? bag * (bagUsd/xrpUsd) : 0;
      }
      return {bag,xrp};
    }
    function render(){
      const balLbl=document.getElementById('balLbl'), ccyLbl=document.getElementById('ccyLbl'), betLbl=document.getElementById('betLbl'), modeLbl=document.getElementById('modeLbl');
      const {bag,xrp} = balances(); const c=cur();
      if (modeLbl) modeLbl.textContent = (window.__BAG_FORCE_DEMO ? 'DEMO' : 'LIVE');
      if (ccyLbl) ccyLbl.textContent = c;
      if (balLbl) balLbl.textContent = fmt(c==='XRP'?xrp:bag,6);
      if (betLbl){
        const v=parseFloat(document.getElementById('betQty')?.value||'0');
        betLbl.textContent = Number.isFinite(v) ? v.toFixed(6).replace(/\.?0+$/,'') : '—';
      }
    }
    ['input','change'].forEach(ev=>{
      document.getElementById('betQty')?.addEventListener(ev, render);
      document.getElementById('curToggle')?.addEventListener(ev, render);
    });
    addEventListener('bag:pricesUpdated', render);
    addEventListener('bag:hudRefresh', render);
    addEventListener('bag:sessionToppedUp', render);
    addEventListener('bag:sessionSpent', render);
    render();
  })();
  </script>

  <!-- =========================================================
       [UI] Rules Modal Wiring + Viewport var helper
       ========================================================= -->
  <script>
  (function(){
    const pill = document.getElementById('rulesPill');
    const modal = document.getElementById('rulesModal');
    const close = document.getElementById('rulesClose');
    function open(){ modal.style.display='block'; pill.setAttribute('aria-expanded','true'); }
    function hide(){ modal.style.display='none'; pill.setAttribute('aria-expanded','false'); }
    pill?.addEventListener('click', open);
    close?.addEventListener('click', hide);
    modal?.addEventListener('click', (e)=>{ if (e.target===modal) hide(); });
    addEventListener('keydown', (e)=>{ if (e.key==='Escape') hide(); });
  })();
  </script>

  <script>
  (function(){function setVW(){var vw=Math.min(window.innerWidth||0,document.documentElement.clientWidth||0);document.documentElement.style.setProperty('--vwpx',vw+'px');}setVW();addEventListener('resize',setVW);addEventListener('orientationchange',setVW);}());
  </script>

  <!-- =========================================================
       [FOOTER]
       ========================================================= -->
  <footer class="footer" style="text-align:center; padding:12px 0; line-height:1.6; width:100%; margin:0 auto;">
    © 2025 $BAG Protocol | getthebag.io | Powered by $XRP
    <br>
    <a href="https://x.com/getthebag_io" target="_blank" rel="noopener" style="color:#e0c66f;text-decoration:none;font-weight:700;">𝕏 @getthebag_io</a> |
    <a href="https://t.me/getthebag_io" target="_blank" rel="noopener" style="color:#e0c66f;text-decoration:none;font-weight:700;">Telegram @getthebag_io</a>
  </footer>
</body>
</html>
