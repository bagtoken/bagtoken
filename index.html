<script>
/* ===== $BAG index: play on scroll-into-view, first-scroll unlock, no-zoom ===== */
(function(){
  const MONEY_SRC = '/assets/sounds/here-come-the-money.mp3';  // exact filename
  const IMG_MATCH = /\/assets\/bag-casino\.(png|PNG)$/i;       // target image
  const THRESHOLD = 0.6;                                       // % visible to count as "in view"
  const MIN_GAP_MS = 1500;                                     // cooldown between plays

  // Create audio (no DOM changes)
  const sfx = new Audio(MONEY_SRC);
  sfx.preload = 'auto';
  sfx.playsInline = true;

  // --- Audio unlock on first user interaction (scroll counts) ---
  let unlocked = false;
  const UNLOCK_EVENTS = ['scroll','wheel','touchstart','pointerdown','keydown','mousedown'];
  async function tryUnlock() {
    if (unlocked) return;
    try {
      // Attempt a tiny play-pause to satisfy mobile policies
      sfx.muted = true;
      await sfx.play();
      sfx.pause();
      sfx.currentTime = 0;
      sfx.muted = false;
      unlocked = true;
      UNLOCK_EVENTS.forEach(t => {
        window.removeEventListener(t, tryUnlock, unlockOpts);
        document.removeEventListener(t, tryUnlock, unlockOpts);
      });
    } catch(_) { /* ignore; will retry on next interaction */ }
  }
  const unlockOpts = { passive:true, capture:true };
  UNLOCK_EVENTS.forEach(t => {
    window.addEventListener(t, tryUnlock, unlockOpts);
    document.addEventListener(t, tryUnlock, unlockOpts);
  });

  // --- Observe the specific image coming into view ---
  let lastPlay = 0;
  const visibleSet = new WeakSet(); // track current visibility to require leave-before-next-play

  async function playIfReady() {
    const now = performance.now();
    if (!unlocked) return;                   // wait until audio is unlocked by user interaction
    if (now - lastPlay < MIN_GAP_MS) return; // cooldown
    try {
      sfx.currentTime = 0;
      await sfx.play();
      lastPlay = now;
      if (navigator.vibrate) navigator.vibrate(10);
    } catch(_) {
      // If still blocked, user hasnâ€™t granted gesture yet; next scroll or tap will unlock
    }
  }

  const io = new IntersectionObserver((entries) => {
    for (const e of entries) {
      const img = e.target;
      const src = img.currentSrc || img.src || '';
      if (!IMG_MATCH.test(src)) continue;

      if (e.isIntersecting && e.intersectionRatio >= THRESHOLD) {
        if (!visibleSet.has(img)) {
          visibleSet.add(img);     // became visible
          playIfReady();           // fire once per enter
        }
      } else {
        visibleSet.delete(img);    // mark as not visible to allow re-trigger on next enter
      }
    }
  }, { threshold: THRESHOLD });

  function watchTargets(root=document) {
    root.querySelectorAll('img').forEach(img => {
      const src = img.currentSrc || img.src || '';
      if (IMG_MATCH.test(src)) io.observe(img);
    });
  }
  watchTargets();

  // If the image is injected later, observe it without touching layout
  const mo = new MutationObserver(muts => {
    for (const m of muts) {
      m.addedNodes && m.addedNodes.forEach(n => {
        if (n.nodeType !== 1) return;
        if (n.tagName === 'IMG') {
          const s = n.currentSrc || n.src || '';
          if (IMG_MATCH.test(s)) io.observe(n);
        } else if (n.querySelectorAll) {
          watchTargets(n);
        }
      });
    }
  });
  mo.observe(document.documentElement, { childList:true, subtree:true });

  // --- Preload when near viewport for snappy start ---
  const preIO = new IntersectionObserver((entries) => {
    if (entries.some(e => e.isIntersecting)) {
      sfx.load();
      preIO.disconnect();
    }
  }, { rootMargin: '400px' });
  // Preload off the first matching image we find
  const firstImg = Array.from(document.images).find(i => IMG_MATCH.test(i.currentSrc || i.src || ''));
  if (firstImg) preIO.observe(firstImg);

  // --- Prevent zoom (pinch, Ctrl+wheel, double-tap) ---
  window.addEventListener('wheel', (e) => { if (e.ctrlKey) e.preventDefault(); }, { passive:false });
  ['gesturestart','gesturechange','gestureend'].forEach(ev => {
    window.addEventListener(ev, (e) => e.preventDefault(), { passive:false });
  });
  let lastTouchEnd = 0;
  document.addEventListener('touchend', (e) => {
    const now = Date.now();
    if (now - lastTouchEnd <= 300) e.preventDefault(); // block double-tap zoom
    lastTouchEnd = now;
  }, { passive:false });
})();
</script>
