<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>üèí $BAG Air Hockey ‚Äî Arcade P2E</title>

<link rel="preconnect" href="https://api.coingecko.com" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>

<style>
:root{
 --gold:#ffe175;--bg:#020703;--panel:#0b1b13;--panel2:#0d2217;
 --muted:#aeb7af;--fg:#f5f7f4;--green:#2fbf6b;--line:#173524;
 --shadow:rgba(0,0,0,.35);
}
html,body{
 margin:0;padding:0;background:var(--bg);color:var(--fg);
 font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
 line-height:1.5;overflow-y:auto;scrollbar-width:thin;
 scrollbar-color:#2fbf6b #0b1b13;
 overscroll-behavior: contain;
 -webkit-tap-highlight-color: transparent;
 touch-action: pan-y;              /* normal page scroll */
 user-select: none; -webkit-user-select: none;
}
.panel{
 background:linear-gradient(180deg,var(--panel),var(--panel2));
 border:1px solid var(--line);
 border-radius:16px;box-shadow:0 8px 24px var(--shadow);
 padding:16px;margin:0 auto;max-width:1080px;
}
.btn{
 cursor:pointer;border:0;border-radius:12px;padding:10px 14px;
 font-weight:900;background:linear-gradient(180deg,#ffe175,#f5c94c);
 color:#08130d;box-shadow:0 4px 0 #b08a19;
}
.btn:active{transform:translateY(1px);box-shadow:0 3px 0 #9a7315;}
.divider{height:1px;background:#123221;margin:14px 0;}
.marquee{
 text-align:center;font-weight:900;letter-spacing:.08em;color:#ffe9a6;
 background:linear-gradient(180deg,#17311f,#0e2419);
 border:1px solid #254a33;border-radius:12px;padding:8px;margin:10px 0;
}
canvas{display:block;margin:auto;}
#gameContainer{max-width:1024px;margin:auto;border-radius:12px;overflow:hidden;}
#gameContainer canvas{touch-action:none; -ms-touch-action:none;} /* capture touches only in game */
</style>

</head>
<body>

<a href="/casino/" class="btn" style="position:fixed;top:18px;left:18px;z-index:1000;">‚¨ÖÔ∏è Back</a>

<section style="text-align:center;padding-top:70px;">
 <h2 style="margin:0;font-size:1.6rem;">üèí $BAG Air Hockey ‚Äî Arcade P2E</h2>
 <p style="font-size:.95rem;opacity:.9;">üí∞ All payouts in $BAG ¬∑ $XRP bets convert automatically.</p>
</section>

<section style="padding:0 16px 80px;">
 <div class="panel">
   <!-- SESSION -->
   <div style="display:flex;justify-content:space-between;align-items:center;">
     <div id="sessionStatus" style="font-size:.9rem">Session: <span style="color:#2fbf6b">Practice</span></div>
     <button id="startSessionBtn" class="btn">Start Session</button>
   </div>

   <div class="divider"></div>

   <div class="marquee">üíπ Live Prices</div>
   <div style="text-align:center;font-family:monospace;">
     BAG $<span id="liveBAG">‚Äî</span> ¬∑ XRP $<span id="liveXRP">‚Äî</span>
     <div id="liveConv" style="font-size:.85rem;opacity:.85;margin-top:4px;">
       1 BAG ‚âà ‚Äî XRP ¬∑ 1 XRP ‚âà ‚Äî BAG
     </div>
   </div>

   <div class="divider"></div>

   <div style="text-align:center;line-height:1.6;">
     <div style="font-weight:800">Practice Balance</div>
     <div>BAG: <span id="balBAG">‚Äî</span>  XRP: <span id="balXRP">‚Äî</span></div>
     <div>USD: <span id="balUSD">‚Äî</span></div>
   </div>

   <div class="divider"></div>
   <div class="marquee">$BAG AIR HOCKEY</div>

   <div id="gameContainer"></div>
 </div>
</section>

<footer style="text-align:center;padding:14px 0;font-size:.9rem;color:#b9c1b5;">
  ¬© 2025 $BAG Protocol | getthebag.io | Powered by $XRP
</footer>

<!-- Live Prices -->
<script>
(function(){
 const BAG_ISSUER='rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr',BAG_CODE='BAG';
 window.P={bagUsd:0,xrpUsd:0};
 const fmt=n=>Number.isFinite(n)?n.toFixed(6):'‚Äî';
 async function refresh(){
  try{
   const r=await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
   const xrp=(await r.json())?.ripple?.usd||0;
   const ws=new WebSocket('wss://s1.ripple.com');
   const bagUsd=await new Promise(res=>{
    const req={id:1,command:'amm_info',asset:{currency:BAG_CODE,issuer:BAG_ISSUER},asset2:{currency:'XRP'}};
    ws.onopen=()=>ws.send(JSON.stringify(req));
    ws.onmessage=e=>{
     try{const d=JSON.parse(e.data);if(d.result?.amm){
      const a=+d.result.amm.amount.value,b=+d.result.amm.amount2.value;
      if(a>0&&b>0)res(b/a*xrp);ws.close();}}catch{}};
    setTimeout(()=>{try{ws.close();}catch{};res(null);},6000);
   });
   if(xrp>0&&bagUsd>0){P.xrpUsd=xrp;P.bagUsd=bagUsd;update();}
  }catch{}
 }
 function update(){
  document.getElementById('liveBAG').textContent=fmt(P.bagUsd);
  document.getElementById('liveXRP').textContent=fmt(P.xrpUsd);
  if(P.bagUsd&&P.xrpUsd){
   const xrpPerBag=P.bagUsd/P.xrpUsd,bagPerXrp=P.xrpUsd/P.bagUsd;
   document.getElementById('liveConv').textContent=
    `1 BAG ‚âà ${xrpPerBag.toFixed(6)} XRP ¬∑ 1 XRP ‚âà ${bagPerXrp.toFixed(6)} BAG`;
  }
  document.dispatchEvent(new Event('bag:pricesUpdated'));
 }
 refresh();setInterval(refresh,15000);
})();
</script>

<!-- Practice Balance -->
<script>
(function(){
 const BAL_KEY='bag_demo_balance',USD_START=2000;
 function getBag(){return Number(localStorage.getItem(BAL_KEY)||0);}
 function setBag(v){localStorage.setItem(BAL_KEY,v);}
 function seed(){if(getBag()>0)return;const p=window.P?.bagUsd||0;if(p>0)setBag(USD_START/p);}
 function render(){
  const bal=getBag(),p=window.P;
  const usd=(p.bagUsd>0)?bal*p.bagUsd:USD_START;
  const xrp=(p.bagUsd>0&&p.xrpUsd>0)?bal*(p.bagUsd/p.xrpUsd):0;
  document.getElementById('balBAG').textContent=bal.toFixed(2);
  document.getElementById('balXRP').textContent=xrp.toFixed(2);
  document.getElementById('balUSD').textContent='$'+usd.toFixed(2);
 }
 document.getElementById('startSessionBtn').addEventListener('click',()=>{seed();render();});
 document.addEventListener('bag:pricesUpdated',render);
})();
</script>

<!-- üéÆ Air Hockey Game -->
<script>
const config={
 type:Phaser.AUTO,
 scale:{mode:Phaser.Scale.FIT,autoCenter:Phaser.Scale.CENTER_BOTH,width:1024,height:1536,parent:'gameContainer'},
 backgroundColor:'#021107',
 physics:{default:'arcade',arcade:{debug:false,fps:120,step:1/240}},
 input:{activePointers:5}
};

let puck,player,cpu,scoreText,topGoal,bottomGoal;
let scorePlayer=0,scoreCPU=0;
let prevPlayer={x:0,y:0};
let prevCPU={x:0,y:0};
let goalAnimating=false;
let inputLocked=false;

new Phaser.Game(Object.assign({},config,{scene:{preload,create,update}}));

function preload(){
 this.load.image('table','/arcade/assets/img/airhockey-table-skin-1024.webp');
 this.load.image('puck','/arcade/assets/img/puck-1024.webp');
 this.load.image('paddle_gold','/arcade/assets/img/paddle_gold-1024.webp');
 this.load.image('paddle_green','/arcade/assets/img/paddle_green-1024.webp');
}

function create(){
 const w=this.scale.width,h=this.scale.height,cx=w/2,cy=h/2;

 // Table
 this.add.image(cx,cy,'table').setDisplaySize(w,h);

 // Visual goal refs (invisible ‚Äî only for positions)
 const GOAL_W=260, GOAL_H=40;
 topGoal=this.add.rectangle(cx,70,GOAL_W,GOAL_H,0x000000,0);
 bottomGoal=this.add.rectangle(cx,h-70,GOAL_W,GOAL_H,0x000000,0);

 // World bounds with top/bottom walls; we‚Äôll detect ‚Äúslot‚Äù at center
 this.physics.world.setBounds(80,80,w-160,h-160);

 // üèí PUCK
 puck=this.physics.add.image(cx,cy,'puck').setScale(0.07);
 puck.setCollideWorldBounds(true).setBounce(0.995).setDamping(true)
     .setDrag(0.995,0.995).setMaxVelocity(2000);
 puck.body.setCircle(puck.displayWidth/2); centerBodyOnTexture(puck);

 // üü° PLAYER / üü¢ CPU ‚Äî bigger paddles
 player=this.physics.add.image(cx,h*0.85,'paddle_gold').setScale(0.14);
 cpu=this.physics.add.image(cx,h*0.15,'paddle_green').setScale(0.14);
 [player,cpu].forEach(p=>{
   p.setImmovable(true);
   p.setCollideWorldBounds(true);
   p.body.setCircle(p.displayWidth/2); centerBodyOnTexture(p);
 });

 // Input: finger-anywhere on lower half
 const radius=Math.max(player.displayWidth,player.displayHeight)*0.5;
 player.setInteractive(new Phaser.Geom.Circle(0,0,radius),Phaser.Geom.Circle.Contains);
 this.input.setDraggable(player);
 this.input.on('drag',(pointer,obj,dragX,dragY)=>{ movePaddleTo({x:dragX,y:dragY},w,h); });
 this.input.on('pointerdown',p=>{ if(p.y>=h*0.5) movePaddleTo(p,w,h); });
 this.input.on('pointermove',p=>{ if(p.isDown && p.y>=h*0.5) movePaddleTo(p,w,h); });

 // Score
 scoreText=this.add.text(cx,40,'0 - 0',{
   fontFamily:'Orbitron',fontSize:'48px',color:'#ffe175',stroke:'#2fbf6b',strokeThickness:3
 }).setOrigin(0.5,0);

 resetPuck.call(this);
}

function centerBodyOnTexture(img){
  const bw = img.body.width, bh = img.body.height;
  img.body.setOffset(img.width/2 - bw/2, img.height/2 - bh/2);
}

// No-parking near goal lips
function clampPlayerY(y,h){ return Phaser.Math.Clamp(y, h*0.5+60, h-110); }
function clampCPUY(y,h){ return Phaser.Math.Clamp(y, 110, h*0.45-40); }

function movePaddleTo(p,w,h){
 if(inputLocked) return;
 player.x = Phaser.Math.Clamp(p.x,100,w-100);
 player.y = clampPlayerY(p.y,h);
}

function resolvePaddle(paddle, prev){
  if(goalAnimating) return;
  const dx = puck.x - paddle.x;
  const dy = puck.y - paddle.y;
  const dist = Math.hypot(dx,dy) || 0.0001;
  const rSum = puck.displayWidth/2 + paddle.displayWidth/2;
  if(dist < rSum){
    const nx = dx / dist, ny = dy / dist;
    const penetration = rSum - dist;
    puck.x += nx * penetration;
    puck.y += ny * penetration;

    const pvx = (paddle.x - prev.x) * 60;
    const pvy = (paddle.y - prev.y) * 60;

    const tx = -ny, ty = nx;
    const vN = pvx*nx + pvy*ny;
    const vT = pvx*tx + pvy*ty;

    const base = 520, gainN = 9.0, gainT = 5.0, maxV = 2000;
    const vx = nx*(base + gainN*Math.abs(vN)) + tx*(vT*gainT);
    const vy = ny*(base + gainN*Math.abs(vN)) + ty*(vT*gainT);

    puck.setVelocity(Phaser.Math.Clamp(vx,-maxV,maxV),Phaser.Math.Clamp(vy,-maxV,maxV));
    puck.setAngularVelocity(Phaser.Math.Clamp(vT*1.5,-450,450));
  }
}

// Goal pocket animation + safe reset
function animateGoalPocket(scene, side){
  goalAnimating = true;
  inputLocked   = true;

  // Freeze velocities
  puck.body.setVelocity(0,0);
  player.body.setVelocity(0,0);
  cpu.body.setVelocity(0,0);

  // Pull paddles away from the mouth
  const w=scene.scale.width, h=scene.scale.height, cx=w/2;
  scene.tweens.add({ targets: player, x: w*0.75, y: clampPlayerY(h*0.82,h), duration:180, ease:'Quad.easeOut' });
  scene.tweens.add({ targets: cpu,    x: w*0.25, y: clampCPUY(h*0.20,h),   duration:180, ease:'Quad.easeOut' });

  // Slot geometry
  const slotY = side==='top' ? (scene.physics.world.bounds.top + 6) : (scene.physics.world.bounds.bottom - 6);
  const targetY = side==='top' ? (slotY - 56) : (slotY + 56);

  // Allow puck to move inside during animation
  puck.setCollideWorldBounds(false);
  puck.body.setEnable(false);

  scene.tweens.timeline({
    tweens: [
      { targets:puck, x:cx, y:slotY, ease:'Quad.easeOut', duration:160 },
      { targets:puck, x:cx, y:targetY, scaleX:puck.scaleX*0.55, scaleY:puck.scaleY*0.55, alpha:0, ease:'Quad.easeIn', duration:180 }
    ],
    onComplete: ()=>{
      // hide puck off-screen before reset to avoid overlaps
      puck.setAlpha(0).setPosition(-9999,-9999).setScale(0.07);

      scene.time.delayedCall(80, ()=>{
        puck.body.setEnable(true);
        puck.setCollideWorldBounds(true);
        goalAnimating=false;
        resetPuck.call(scene, side==='top' ? 'player' : 'cpu');
        scene.time.delayedCall(80, ()=>{ inputLocked=false; puck.setAlpha(1); }, null, scene);
      });
    }
  });
}

let aiTimer=0;

function update(time, delta){
 const w=this.scale.width,h=this.scale.height;

 const curPlayer={x:player.x,y:player.y};
 const curCPU={x:cpu.x,y:cpu.y};

 // CPU AI
 if(!goalAnimating){
   aiTimer += delta;
   cpu.x += (puck.x - cpu.x) * 0.10;
   cpu.y += (puck.y - cpu.y) * 0.06;
   cpu.x = Phaser.Math.Clamp(cpu.x,100,w-100);
   cpu.y = clampCPUY(cpu.y,h);
 }

 // Continuous collisions
 resolvePaddle(player, prevPlayer);
 resolvePaddle(cpu, prevCPU);

 // ---------- GOAL DETECTION THROUGH WALL SLOT ----------
 if(!goalAnimating){
   const bounds = this.physics.world.bounds;
   const r      = puck.displayWidth/2;
   const halfW  = topGoal.width/2;       // matches GOAL_W/2
   const withinGoalX = Math.abs(puck.x - (bounds.centerX)) < (halfW - r);

   // top slot: puck touching/penetrating the top wall near center
   if( withinGoalX && puck.y <= bounds.top + r + 2 ){
     scorePlayer++; scoreText.setText(`${scorePlayer} - ${scoreCPU}`);
     animateGoalPocket(this,'top');
   }

   // bottom slot
   if( withinGoalX && puck.y >= bounds.bottom - r - 2 ){
     scoreCPU++; scoreText.setText(`${scorePlayer} - ${scoreCPU}`);
     animateGoalPocket(this,'bottom');
   }
 }
 // ------------------------------------------------------

 // Keep puck sane
 const v = puck.body.velocity, vmax=2000, keep=0.999;
 v.x = Phaser.Math.Clamp(v.x*keep,-vmax,vmax);
 v.y = Phaser.Math.Clamp(v.y*keep,-vmax,vmax);

 prevPlayer = curPlayer;
 prevCPU = curCPU;
}

function resetPuck(scoredBy){
 const w=this.scale.width,h=this.scale.height;
 puck.setPosition(w/2,h/2);
 const angle=Phaser.Math.Between(20,160)*(Phaser.Math.Between(0,1)?1:-1);
 const speed=Phaser.Math.Between(650,800);
 const vx=Math.cos(angle*Math.PI/180)*speed;
 const vy=(scoredBy==='player'?-1:1)*Math.abs(Math.sin(angle*Math.PI/180)*speed);
 puck.setVelocity(vx,vy);
 puck.setAngularVelocity(Phaser.Math.Between(-120,120));
 puck.setAlpha(1).setScale(0.07);
}
</script>

</body>
</html>
