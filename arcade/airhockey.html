<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>üèí $BAG Air Hockey ‚Äî Arcade P2E</title>

<link rel="preconnect" href="https://api.coingecko.com" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>

<style>
:root{--gold:#ffe175;--bg:#020703;--panel:#0b1b13;--panel2:#0d2217;--muted:#aeb7af;--fg:#f5f7f4;--green:#2fbf6b;--line:#173524;--shadow:rgba(0,0,0,.35)}
html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.5;overflow-y:auto;scrollbar-width:thin;scrollbar-color:#2fbf6b #0b1b13;overscroll-behavior:contain;-webkit-tap-highlight-color:transparent;touch-action:pan-y;user-select:none;-webkit-user-select:none}
.panel{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 24px var(--shadow);padding:16px;margin:0 auto;max-width:1080px}
.btn{cursor:pointer;border:0;border-radius:12px;padding:10px 14px;font-weight:900;background:linear-gradient(180deg,#ffe175,#f5c94c);color:#08130d;box-shadow:0 4px 0 #b08a19}
.btn:active{transform:translateY(1px);box-shadow:0 3px 0 #9a7315}
.divider{height:1px;background:#123221;margin:14px 0}
.marquee{text-align:center;font-weight:900;letter-spacing:.08em;color:#ffe9a6;background:linear-gradient(180deg,#17311f,#0e2419);border:1px solid #254a33;border-radius:12px;padding:8px;margin:10px 0}
canvas{display:block;margin:auto}
#gameContainer{max-width:1024px;margin:auto;border-radius:12px;overflow:hidden}
#gameContainer canvas{touch-action:none;-ms-touch-action:none}
</style>
</head>
<body>

<a href="/casino/" class="btn" style="position:fixed;top:18px;left:18px;z-index:1000;">‚¨ÖÔ∏è Back</a>

<section style="text-align:center;padding-top:70px;">
  <h2 style="margin:0;font-size:1.6rem;">üèí $BAG Air Hockey ‚Äî Arcade P2E</h2>
  <p style="font-size:.95rem;opacity:.9;">üí∞ All payouts in $BAG ¬∑ $XRP bets convert automatically.</p>
</section>

<section style="padding:0 16px 80px;">
  <div class="panel">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div id="sessionStatus" style="font-size:.9rem">Session: <span style="color:#2fbf6b">Practice</span></div>
      <button id="startSessionBtn" class="btn">Start Session</button>
    </div>

    <div class="divider"></div>

    <div class="marquee">üíπ Live Prices</div>
    <div style="text-align:center;font-family:monospace;">
      BAG $<span id="liveBAG">‚Äî</span> ¬∑ XRP $<span id="liveXRP">‚Äî</span>
      <div id="liveConv" style="font-size:.85rem;opacity:.85;margin-top:4px;">1 BAG ‚âà ‚Äî XRP ¬∑ 1 XRP ‚âà ‚Äî BAG</div>
    </div>

    <div class="divider"></div>

    <div style="text-align:center;line-height:1.6;">
      <div style="font-weight:800">Practice Balance</div>
      <div>BAG: <span id="balBAG">‚Äî</span>  XRP: <span id="balXRP">‚Äî</span></div>
      <div>USD: <span id="balUSD">‚Äî</span></div>
    </div>

    <div class="divider"></div>
    <div class="marquee">$BAG AIR HOCKEY</div>

    <div id="gameContainer"></div>
  </div>
</section>

<footer style="text-align:center;padding:14px 0;font-size:.9rem;color:#b9c1b5;">¬© 2025 $BAG Protocol | getthebag.io | Powered by $XRP</footer>

<!-- Live Prices -->
<script>
(function(){
 const BAG_ISSUER='rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr',BAG_CODE='BAG';
 window.P={bagUsd:0,xrpUsd:0};
 const fmt=n=>Number.isFinite(n)?n.toFixed(6):'‚Äî';
 async function refresh(){
  try{
   const r=await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
   const xrp=(await r.json())?.ripple?.usd||0;
   const ws=new WebSocket('wss://s1.ripple.com');
   const bagUsd=await new Promise(res=>{
    const req={id:1,command:'amm_info',asset:{currency:BAG_CODE,issuer:BAG_ISSUER},asset2:{currency:'XRP'}};
    ws.onopen=()=>ws.send(JSON.stringify(req));
    ws.onmessage=e=>{
     try{const d=JSON.parse(e.data);if(d.result?.amm){
      const a=+d.result.amm.amount.value,b=+d.result.amm.amount2.value;
      if(a>0&&b>0)res(b/a*xrp);ws.close();}}catch{}};
    setTimeout(()=>{try{ws.close();}catch{};res(null);},6000);
   });
   if(xrp>0&&bagUsd>0){P.xrpUsd=xrp;P.bagUsd=bagUsd;update();}
  }catch{}
 }
 function update(){
  document.getElementById('liveBAG').textContent=fmt(P.bagUsd);
  document.getElementById('liveXRP').textContent=fmt(P.xrpUsd);
  if(P.bagUsd&&P.xrpUsd){
   const xrpPerBag=P.bagUsd/P.xrpUsd,bagPerXrp=P.xrpUsd/P.bagUsd;
   document.getElementById('liveConv').textContent=`1 BAG ‚âà ${xrpPerBag.toFixed(6)} XRP ¬∑ 1 XRP ‚âà ${bagPerXrp.toFixed(6)} BAG`;
  }
  document.dispatchEvent(new Event('bag:pricesUpdated'));
 }
 refresh();setInterval(refresh,15000);
})();
</script>

<!-- Practice Balance -->
<script>
(function(){
 const BAL_KEY='bag_demo_balance',USD_START=2000;
 function getBag(){return Number(localStorage.getItem(BAL_KEY)||0);}
 function setBag(v){localStorage.setItem(BAL_KEY,v);}
 function seed(){if(getBag()>0)return;const p=window.P?.bagUsd||0;if(p>0)setBag(USD_START/p);}
 function render(){
  const bal=getBag(),p=window.P;
  const usd=(p.bagUsd>0)?bal*p.bagUsd:USD_START;
  const xrp=(p.bagUsd>0&&p.xrpUsd>0)?bal*(p.bagUsd/p.xrpUsd):0;
  document.getElementById('balBAG').textContent=bal.toFixed(2);
  document.getElementById('balXRP').textContent=xrp.toFixed(2);
  document.getElementById('balUSD').textContent='$'+usd.toFixed(2);
 }
 document.getElementById('startSessionBtn').addEventListener('click',()=>{seed();render();});
 document.addEventListener('bag:pricesUpdated',render);
})();
</script>

<!-- üéÆ Air Hockey Game -->
<script>
const config={
 type:Phaser.AUTO,
 scale:{mode:Phaser.Scale.FIT,autoCenter:Phaser.Scale.CENTER_BOTH,width:1024,height:1536,parent:'gameContainer'},
 backgroundColor:'#021107',
 physics:{default:'arcade',arcade:{debug:false,fps:120,step:1/240}},
 input:{activePointers:5}
};

let puck,player,cpu,scoreText;
let scorePlayer=0,scoreCPU=0;
let prevPlayer={x:0,y:0};
let prevCPU={x:0,y:0};
let inGoal=false;
let sensors, walls;

new Phaser.Game(Object.assign({},config,{scene:{preload,create,update}}));

function preload(){
 this.load.image('table','/arcade/assets/img/airhockey-table-skin-1024.webp');
 this.load.image('puck','/arcade/assets/img/puck-1024.webp');
 this.load.image('paddle_gold','/arcade/assets/img/paddle_gold-1024.webp');
 this.load.image('paddle_green','/arcade/assets/img/paddle_green-1024.webp');
}

function create(){
 const w=this.scale.width,h=this.scale.height,cx=w/2,cy=h/2;

 // background
 this.add.image(cx,cy,'table').setDisplaySize(w,h);

 // Playfield geometry
 const PAD=80;                        // board margin
 const TOP=PAD, BOTTOM=h-PAD;
 const LEFT=PAD, RIGHT=w-PAD;
 const GOAL_W=260, GOAL_HALF=GOAL_W/2;

 // reference bounds only
 this.physics.world.setBounds(LEFT,TOP,RIGHT-LEFT,BOTTOM-TOP);

 // puck (no collideWorldBounds; we use custom walls)
 puck=this.physics.add.image(cx,cy,'puck').setScale(0.07);
 puck.setBounce(0.995).setDamping(true).setDrag(0.995,0.995).setMaxVelocity(2000);
 puck.body.setCircle(puck.displayWidth/2); centerBodyOnTexture(puck);

 // paddles (big)
 player=this.physics.add.image(cx,h*0.85,'paddle_gold').setScale(0.14);
 cpu=this.physics.add.image(cx,h*0.15,'paddle_green').setScale(0.14);
 [player,cpu].forEach(p=>{
   p.setImmovable(true);
   p.setCollideWorldBounds(true);
   p.body.setCircle(p.displayWidth/2); centerBodyOnTexture(p);
 });

 // STATIC WALLS: left/right + split top/bottom
 walls=this.physics.add.staticGroup();

 // L/R strips
 walls.add(rect(this, LEFT,  (TOP+BOTTOM)/2, 8, (BOTTOM-TOP)));
 walls.add(rect(this, RIGHT, (TOP+BOTTOM)/2, 8, (BOTTOM-TOP)));

 // compute split widths so GOAL_W gap is centered
 const leftSpan  = (cx - GOAL_HALF) - LEFT;
 const rightSpan = RIGHT - (cx + GOAL_HALF);
 walls.add(rect(this, LEFT + leftSpan/2,  TOP,    leftSpan, 8));    // top-left
 walls.add(rect(this, RIGHT - rightSpan/2,TOP,    rightSpan,8));    // top-right
 walls.add(rect(this, LEFT + leftSpan/2,  BOTTOM, leftSpan, 8));    // bottom-left
 walls.add(rect(this, RIGHT - rightSpan/2,BOTTOM, rightSpan,8));    // bottom-right

 this.physics.add.collider(puck, walls);

 // GOAL SENSORS (thin zones)
 sensors = {
   top:    makeSensor(this, cx, TOP+6,    GOAL_W-12, 12),
   bottom: makeSensor(this, cx, BOTTOM-6, GOAL_W-12, 12)
 };
 this.physics.add.overlap(puck, sensors.top,    ()=>onGoal(this,'top'),    null, this);
 this.physics.add.overlap(puck, sensors.bottom, ()=>onGoal(this,'bottom'), null, this);

 // input (lower half touch/drag)
 const radius=Math.max(player.displayWidth,player.displayHeight)*0.5;
 player.setInteractive(new Phaser.Geom.Circle(0,0,radius),Phaser.Geom.Circle.Contains);
 this.input.setDraggable(player);
 this.input.on('drag',(pointer,obj,dx,dy)=>movePaddleTo({x:dx,y:dy},w,h,TOP,BOTTOM,LEFT,RIGHT));
 this.input.on('pointerdown',p=>{ if(p.y>=h*0.5) movePaddleTo(p,w,h,TOP,BOTTOM,LEFT,RIGHT); });
 this.input.on('pointermove',p=>{ if(p.isDown && p.y>=h*0.5) movePaddleTo(p,w,h,TOP,BOTTOM,LEFT,RIGHT); });

 // score
 scoreText=this.add.text(cx,40,'0 - 0',{fontFamily:'Orbitron',fontSize:'48px',color:'#ffe175',stroke:'#2fbf6b',strokeThickness:3}).setOrigin(0.5,0);

 serve(this); // first serve
}

// helpers
function rect(scene,x,y,w,h){
 const r=scene.add.rectangle(x,y,Math.max(2,w),Math.max(2,h),0x000000,0);
 scene.physics.add.existing(r,true);
 return r;
}
function makeSensor(scene,x,y,w,h){
 const z=scene.add.zone(x,y,Math.max(2,w),Math.max(2,h));
 scene.physics.add.existing(z,true); // static sensor
 z.body.setAllowGravity(false);
 return z;
}
function centerBodyOnTexture(img){
 const bw=img.body.width,bh=img.body.height;
 img.body.setOffset(img.width/2-bw/2,img.height/2-bh/2);
}
function clampPlayerY(y,h,TOP,BOTTOM){ return Phaser.Math.Clamp(y, h*0.5+60, BOTTOM-30); }
function clampCPUY(y,h,TOP){ return Phaser.Math.Clamp(y, TOP+30, h*0.45-40); }
function movePaddleTo(p,w,h,TOP,BOTTOM,LEFT,RIGHT){
 if(inGoal) return;
 player.x=Phaser.Math.Clamp(p.x,LEFT+20,RIGHT-20);
 player.y=clampPlayerY(p.y,h,TOP,BOTTOM);
}

function resolvePaddle(paddle, prev){
 if(inGoal || !puck.body || !puck.body.enable) return;
 const dx=puck.x-paddle.x, dy=puck.y-paddle.y, dist=Math.hypot(dx,dy)||0.0001;
 const rSum=puck.displayWidth/2+paddle.displayWidth/2;
 if(dist<rSum){
   const nx=dx/dist, ny=dy/dist, pen=rSum-dist;
   puck.x+=nx*pen; puck.y+=ny*pen;
   const pvx=(paddle.x-prev.x)*60, pvy=(paddle.y-prev.y)*60;
   const tx=-ny, ty=nx, vN=pvx*nx+pvy*ny, vT=pvx*tx+pvy*ty;
   const base=520,gainN=9,gainT=5,maxV=2000;
   const vx=nx*(base+gainN*Math.abs(vN))+tx*(vT*gainT);
   const vy=ny*(base+gainN*Math.abs(vN))+ty*(vT*gainT);
   puck.setVelocity(Phaser.Math.Clamp(vx,-maxV,maxV),Phaser.Math.Clamp(vy,-maxV,maxV));
   puck.setAngularVelocity(Phaser.Math.Clamp(vT*1.5,-450,450));
 }
}

// HARD goal handler (no tweens, no ghost, no pauses)
function onGoal(scene, side){
 if(inGoal || !puck.body || !puck.body.enable) return;
 inGoal = true;

 // prevent re-firing while handling
 sensors.top.active = false;
 sensors.bottom.active = false;

 // score
 if(side==='top'){ scorePlayer++; } else { scoreCPU++; }
 scoreText.setText(`${scorePlayer} - ${scoreCPU}`);

 // park puck safely off-screen & disable body
 puck.body.setEnable(false);
 puck.setPosition(-9999,-9999).setAlpha(0);

 // quick clean reset after 120ms
 scene.time.delayedCall(120, ()=>{
   serve(scene, side==='top' ? 'player' : 'cpu');
   puck.setAlpha(1);
   // re-enable sensors a tick later
   scene.time.delayedCall(60, ()=>{
     sensors.top.active = true;
     sensors.bottom.active = true;
     inGoal = false;
   });
 });
}

function serve(scene, scoredBy){
 const w=scene.scale.width,h=scene.scale.height;
 puck.setPosition(w/2,h/2).setScale(0.07);
 if(puck.body){
   puck.body.setEnable(true);
   const angle=Phaser.Math.Between(20,160)*(Phaser.Math.Between(0,1)?1:-1);
   const speed=Phaser.Math.Between(650,800);
   const vx=Math.cos(angle*Math.PI/180)*speed;
   const vy=(scoredBy==='player'?-1:1)*Math.abs(Math.sin(angle*Math.PI/180)*speed);
   puck.setVelocity(vx,vy);
   puck.setAngularVelocity(Phaser.Math.Between(-120,120));
 }
}

let aiTimer=0;

function update(time,delta){
 const w=this.scale.width,h=this.scale.height;

 const curPlayer={x:player.x,y:player.y};
 const curCPU={x:cpu.x,y:cpu.y};

 // CPU AI
 if(!inGoal && puck.body && puck.body.enable){
   aiTimer+=delta;
   cpu.x+=(puck.x-cpu.x)*0.10;
   cpu.y+=(puck.y-cpu.y)*0.06;
   const TOP=this.physics.world.bounds.top, BOTTOM=this.physics.world.bounds.bottom, LEFT=this.physics.world.bounds.left, RIGHT=this.physics.world.bounds.right;
   cpu.x=Phaser.Math.Clamp(cpu.x,LEFT+20,RIGHT-20);
   cpu.y=clampCPUY(cpu.y,h,TOP);
 }

 // Paddle vs puck resolver
 resolvePaddle(player,prevPlayer);
 resolvePaddle(cpu,prevCPU);

 // Clamp puck velocity only when enabled
 if(puck.body && puck.body.enable){
   const v=puck.body.velocity, vmax=2000, keep=0.999;
   v.x=Phaser.Math.Clamp(v.x*keep,-vmax,vmax);
   v.y=Phaser.Math.Clamp(v.y*keep,-vmax,vmax);
 }

 prevPlayer=curPlayer;
 prevCPU=curCPU;
}
</script>
</body>
</html>
