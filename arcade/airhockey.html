<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>$BAG Air Hockey — Arcade P2E</title>
<link rel="preconnect" href="https://api.coingecko.com" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>
<style>
:root{
 --gold:#ffe175;--bg:#020703;--panel:#0b1b13;--panel2:#0d2217;
 --muted:#aeb7af;--fg:#f5f7f4;--green:#2fbf6b;--line:#173524;
 --shadow:rgba(0,0,0,.35);
}
html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);
 font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
 line-height:1.5;overflow-y:auto;scrollbar-width:thin;
 scrollbar-color:#2fbf6b #0b1b13;overscroll-behavior:contain;
 -webkit-tap-highlight-color:transparent;touch-action:pan-y;
 user-select:none;-webkit-user-select:none;}
.panel{background:linear-gradient(180deg,var(--panel),var(--panel2));
 border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 24px var(--shadow);
 padding:16px;margin:0 auto;max-width:1080px;}
.btn{cursor:pointer;border:0;border-radius:12px;padding:10px 14px;
 font-weight:900;background:linear-gradient(180deg,#ffe175,#f5c94c);
 color:#08130d;box-shadow:0 4px 0 #b08a19;}
.btn:active{transform:translateY(1px);box-shadow:0 3px 0 #9a7315;}
.divider{height:1px;background:#123221;margin:14px 0;}
.marquee{text-align:center;font-weight:900;letter-spacing:.08em;color:#ffe9a6;
 background:linear-gradient(180deg,#17311f,#0e2419);
 border:1px solid #254a33;border-radius:12px;padding:8px;margin:10px 0;}
canvas{display:block;margin:auto;}
#gameContainer{max-width:1024px;margin:auto;border-radius:12px;overflow:hidden;}
#gameContainer canvas{touch-action:none;-ms-touch-action:none;}
</style>
</head>
<body>
<a href="/casino/" class="btn" style="position:fixed;top:18px;left:18px;z-index:1000;">Back</a>
<section style="text-align:center;padding-top:70px;">
 <h2 style="margin:0;font-size:1.6rem;">$BAG Air Hockey — Arcade P2E</h2>
 <p style="font-size:.95rem;opacity:.9;">All payouts in $BAG · $XRP bets convert automatically.</p>
</section>
<section style="padding:0 16px 80px;">
 <div class="panel">
   <div style="display:flex;justify-content:space-between;align-items:center;">
     <div id="sessionStatus" style="font-size:.9rem">Session: <span style="color:#2fbf6b">Practice</span></div>
     <button id="startSessionBtn" class="btn">Start Session</button>
   </div>
   <div class="divider"></div>
   <div class="marquee">Live Prices</div>
   <div style="text-align:center;font-family:monospace;">
     BAG $<span id="liveBAG">—</span> · XRP $<span id="liveXRP">—</span>
     <div id="liveConv" style="font-size:.85rem;opacity:.85;margin-top:4px;">
       1 BAG ≈ — XRP · 1 XRP ≈ — BAG
     </div>
   </div>
   <div class="divider"></div>
   <div style="text-align:center;line-height:1.6;">
     <div style="font-weight:800">Practice Balance</div>
     <div>BAG: <span id="balBAG">—</span> XRP: <span id="balXRP">—</span></div>
     <div>USD: <span id="balUSD">—</span></div>
   </div>
   <div class="divider"></div>
   <div class="marquee">$BAG AIR HOCKEY</div>
   <div id="gameContainer"></div>
 </div>
</section>
<footer style="text-align:center;padding:14px 0;font-size:.9rem;color:#b9c1b5;">
  © 2025 $BAG Protocol | getthebag.io | Powered by $XRP
</footer>

<!-- Live Prices -->
<script>
(function(){
 const BAG_ISSUER='rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr',BAG_CODE='BAG';
 window.P={bagUsd:0,xrpUsd:0};
 const fmt=n=>Number.isFinite(n)?n.toFixed(6):'—';
 async function refresh(){
  try{
   const r=await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
   const xrp=(await r.json())?.ripple?.usd||0;
   const ws=new WebSocket('wss://s1.ripple.com');
   const bagUsd=await new Promise(res=>{
    const req={id:1,command:'amm_info',asset:{currency:BAG_CODE,issuer:BAG_ISSUER},asset2:{currency:'XRP'}};
    ws.onopen=()=>ws.send(JSON.stringify(req));
    ws.onmessage=e=>{
     try{const d=JSON.parse(e.data);if(d.result?.amm){
      const a=+d.result.amm.amount.value,b=+d.result.amm.amount2.value;
      if(a>0&&b>0)res(b/a*xrp);ws.close();}}catch{}};
    setTimeout(()=>{try{ws.close();}catch{};res(null);},6000);
   });
   if(xrp>0&&bagUsd>0){P.xrpUsd=xrp;P.bagUsd=bagUsd;update();}
  }catch{}
 }
 function update(){
  document.getElementById('liveBAG').textContent=fmt(P.bagUsd);
  document.getElementById('liveXRP').textContent=fmt(P.xrpUsd);
  if(P.bagUsd&&P.xrpUsd){
   const xrpPerBag=P.bagUsd/P.xrpUsd,bagPerXrp=P.xrpUsd/P.bagUsd;
   document.getElementById('liveConv').textContent=
    `1 BAG ≈ ${xrpPerBag.toFixed(6)} XRP · 1 XRP ≈ ${bagPerXrp.toFixed(6)} BAG`;
  }
  document.dispatchEvent(new Event('bag:pricesUpdated'));
 }
 refresh();setInterval(refresh,15000);
})();
</script>

<!-- Practice Balance -->
<script>
(function(){
 const BAL_KEY='bag_demo_balance',USD_START=2000;
 function getBag(){return Number(localStorage.getItem(BAL_KEY)||0);}
 function setBag(v){localStorage.setItem(BAL_KEY,v);}
 function seed(){if(getBag()>0)return;const p=window.P?.bagUsd||0;if(p>0)setBag(USD_START/p);}
 function render(){
  const bal=getBag(),p=window.P;
  const usd=(p.bagUsd>0)?bal*p.bagUsd:USD_START;
  const xrp=(p.bagUsd>0&&p.xrpUsd>0)?bal*(p.bagUsd/p.xrpUsd):0;
  document.getElementById('balBAG').textContent=bal.toFixed(2);
  document.getElementById('balXRP').textContent=xrp.toFixed(2);
  document.getElementById('balUSD').textContent='$'+usd.toFixed(2);
 }
 document.getElementById('startSessionBtn').addEventListener('click',()=>{seed();render();});
 document.addEventListener('bag:pricesUpdated',render);
})();
</script>

<!-- Air Hockey Game (FINAL FIX: Puck SCORES 100%) -->
<script>
const config = {
  type: Phaser.AUTO,
  scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: 1024, height: 1536, parent: 'gameContainer' },
  backgroundColor: '#021107',
  physics: { default: 'arcade', arcade: { debug: false, fps: 120, step: 1/240 } },
  input: { activePointers: 5 }
};

let puck, player, cpu, scoreText, topGoal, bottomGoal, topSlot, bottomSlot;
let scorePlayer = 0, scoreCPU = 0;
let prevPlayer = {x:0,y:0}, prevCPU = {x:0,y:0};
let pocketTween = null;

new Phaser.Game(Object.assign({}, config, { scene: { preload, create, update } }));

function preload() {
  this.load.image('table','/arcade/assets/img/airhockey-table-skin-1024.webp');
  this.load.image('puck','/arcade/assets/img/puck-1024.webp');
  this.load.image('paddle_gold','/arcade/assets/img/paddle_gold-1024.webp');
  this.load.image('paddle_green','/arcade/assets/img/paddle_green-1024.webp');
  try{
    this.load.audio('hit1','/arcade/assets/sounds/hit1.mp3');
    this.load.audio('goal','/arcade/assets/sounds/goal.mp3');
  }catch(e){}
}

function create() {
  const w = this.scale.width, h = this.scale.height, cx = w/2;

  this.add.image(cx, h/2, 'table').setDisplaySize(w, h);

  const GOAL_W = 260, GOAL_H = 40, SLOT_H = 36;
  topGoal    = this.add.rectangle(cx, 70, GOAL_W, GOAL_H, 0xff0000, 0.4).setDepth(0);
  bottomGoal = this.add.rectangle(cx, h-70, GOAL_W, GOAL_H, 0x00ff00, 0.4).setDepth(0);
  topSlot    = this.add.rectangle(cx, 70, GOAL_W, SLOT_H, 0x000000, 0.85).setDepth(1);
  bottomSlot = this.add.rectangle(cx, h-70, GOAL_W, SLOT_H, 0x000000, 0.85).setDepth(1);

  // NO WORLD BOUNDS — puck can enter goals!
  // this.physics.world.setBounds(...);

  // PUCK
  puck = this.physics.add.image(cx, h/2, 'puck').setScale(0.07);
  puck.setCollideWorldBounds(false); // allow goal entry
  puck.setBounce(0.995).setDamping(true)
      .setDrag(0.995, 0.995).setMaxVelocity(2000);
  puck.body.setCircle(puck.displayWidth/2);
  centerBodyOnTexture(puck);

  // PADDLES
  player = this.physics.add.image(cx, h*0.85, 'paddle_gold').setScale(0.14);
  cpu    = this.physics.add.image(cx, h*0.15, 'paddle_green').setScale(0.14);
  [player, cpu].forEach(p => {
    p.setImmovable(true);
    p.setCollideWorldBounds(true);
    p.body.setCircle(p.displayWidth/2);
    centerBodyOnTexture(p);
  });

  // SFX
  this.sfx = { hit1: null, goal: null };
  try{
    this.sfx.hit1 = this.sound.add('hit1', { volume: 0.35 });
    this.sfx.goal = this.sound.add('goal', { volume: 0.5 });
  }catch(e){}

  // INPUT
  const radius = Math.max(player.displayWidth, player.displayHeight) * 0.5;
  player.setInteractive(new Phaser.Geom.Circle(0,0,radius), Phaser.Geom.Circle.Contains);
  this.input.setDraggable(player);
  this.input.on('drag', (pointer,obj,dragX,dragY) => movePaddleTo({x:dragX,y:dragY},w,h));
  this.input.on('pointerdown', p => { if(p.y >= h*0.5) movePaddleTo(p,w,h); });
  this.input.on('pointermove', p => { if(p.isDown && p.y >= h*0.5) movePaddleTo(p,w,h); });

  scoreText = this.add.text(cx, 40, '0 - 0', {
    fontFamily: 'Orbitron', fontSize: '48px', color: '#ffe175',
    stroke: '#2fbf6b', strokeThickness: 3
  }).setOrigin(0.5, 0);

  resetPuck.call(this);
}

function centerBodyOnTexture(img){
  const bw = img.body.width, bh = img.body.height;
  img.body.setOffset(img.width/2 - bw/2, img.height/2 - bh/2);
}

function movePaddleTo(p,w,h){
  const clampedX = Phaser.Math.Clamp(p.x,100,w-100);
  const clampedY = Phaser.Math.Clamp(p.y,h*0.5+40,h-80);
  player.x = clampedX; player.y = clampedY;
}

function resolvePaddle(paddle, prev){
  const dx = puck.x - paddle.x;
  const dy = puck.y - paddle.y;
  const dist = Math.hypot(dx,dy) || 0.0001;
  const rPuck = puck.displayWidth/2;
  const rPad  = paddle.displayWidth/2;
  const rSum  = rPuck + rPad;
  if(dist < rSum){
    const nx = dx/dist, ny = dy/dist;
    const penetration = rSum - dist;
    puck.x += nx*penetration;
    puck.y += ny*penetration;
    const pvx = (paddle.x - prev.x)*60;
    const pvy = (paddle.y - prev.y)*60;
    const tx = -ny, ty = nx;
    const vN = pvx*nx + pvy*ny;
    const vT = pvx*tx + pvy*ty;
    const base = 520, gainN = 9.0, gainT = 5.0, maxV = 2000;
    const vx = nx*(base + gainN*Math.abs(vN)) + tx*(vT*gainT);
    const vy = ny*(base + gainN*Math.abs(vN)) + ty*(vT*gainT);
    puck.setVelocity(Phaser.Math.Clamp(vx,-maxV,maxV), Phaser.Math.Clamp(vy,-maxV,maxV));
    const spin = Phaser.Math.Clamp(vT*1.5, -450, 450);
    puck.setAngularVelocity(spin);
    try{ this.sfx?.hit1?.play(); }catch{}
  }
}

let aiTimer = 0;
function update(time, delta){
  const w = this.scale.width, h = this.scale.height;
  const curPlayer = {x:player.x, y:player.y};
  const curCPU    = {x:cpu.x,    y:cpu.y};

  // AI
  aiTimer += delta;
  cpu.x += (puck.x - cpu.x) * 0.10;
  cpu.y += (puck.y - cpu.y) * 0.06;
  cpu.x = Phaser.Math.Clamp(cpu.x,100,w-100);
  cpu.y = Phaser.Math.Clamp(cpu.y,80,h*0.45);

  // Collisions
  resolvePaddle.call(this, player, prevPlayer);
  resolvePaddle.call(this, cpu,    prevCPU);

  // GOAL DETECTION — NO BOUNDS, PURE Y + X CHECK
  const GOAL_HALF = 130;  // 260 / 2
  const cx = w/2;

  // PLAYER scores (top)
  if(puck.y < 70 && Math.abs(puck.x - cx) < GOAL_HALF){
    scorePlayer++;
    flashGoal(topGoal, 0xff0000);
    playGoalSound.call(this);
    animatePuckIntoSlot.call(this, puck.x, puck.y, topSlot, -120, 'player');
  }

  // CPU scores (bottom)
  if(puck.y > h - 70 && Math.abs(puck.x - cx) < GOAL_HALF){
    scoreCPU++;
    flashGoal(bottomGoal, 0x00ff00);
    playGoalSound.call(this);
    animatePuckIntoSlot.call(this, puck.x, puck.y, bottomSlot, h+120, 'cpu');
  }

  // Velocity clamp
  const v = puck.body.velocity;
  const vmax = 2000, keep = 0.999;
  v.x = Phaser.Math.Clamp(v.x*keep, -vmax, vmax);
  v.y = Phaser.Math.Clamp(v.y*keep, -vmax, vmax);

  scoreText.setText(`${scorePlayer} - ${scoreCPU}`);

  prevPlayer = curPlayer;
  prevCPU    = curCPU;
}

/* ---------- GOAL HELPERS ---------- */
function flashGoal(goal,color){
  goal.setFillStyle(color,0.9);
  setTimeout(()=>goal.setFillStyle(color,0.4),180);
}
function playGoalSound(){ try{ this.sfx?.goal?.play(); }catch{} }

function animatePuckIntoSlot(x, y, slot, targetY, winner){
  // Hide real puck + stop physics
  puck.setAlpha(0);
  puck.body.stop();

  const ghost = this.add.image(x, y, 'puck')
    .setScale(puck.scaleX)
    .setDepth(9999)
    .setAlpha(1);

  if(pocketTween) pocketTween.remove();

  pocketTween = this.tweens.add({
    targets: ghost,
    y: targetY,
    scaleX: ghost.scaleX * 0.35,
    scaleY: ghost.scaleY * 0.35,
    angle: '+=360',
    alpha: 0,
    duration: 340,
    ease: 'Power2',
    onComplete: () => {
      ghost.destroy();
      resetPuck.call(this, winner);
      puck.setAlpha(1);  // show fresh puck
    }
  });
}

function resetPuck(scoredBy){
  const w = this.scale.width, h = this.scale.height;
  puck.setPosition(w/2, h/2);
  puck.body.stop();

  const angle = Phaser.Math.Between(20,160) * (Phaser.Math.Between(0,1)?1:-1);
  const speed = Phaser.Math.Between(650,800);
  const vx = Math.cos(angle*Math.PI/180)*speed;
  const vy = (scoredBy==='player' ? -1 : 1) * Math.abs(Math.sin(angle*Math.PI/180)*speed);

  puck.setVelocity(vx, vy);
  puck.setAngularVelocity(Phaser.Math.Between(-120,120));
}
</script>
</body>
</html>
