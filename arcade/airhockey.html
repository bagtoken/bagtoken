<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>$BAG Air Hockey â€” Arcade P2E</title>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
<style>
body{margin:0;background:#021107;overflow:hidden;}
canvas{display:block;margin:auto;}
</style>
</head>
<body>
<script>
const config = {
  type: Phaser.AUTO,
  width: 1024,
  height: 1536,
  parent: 'game',
  physics: { default: 'arcade', arcade: { debug: false, fps: 60 } },
  scene: { preload, create, update }
};

let puck, player, cpuPaddle, scorePlayer = 0, scoreCPU = 0, scoreText;
let prevPlayer = {x:0,y:0}, playerVel = {x:0,y:0};
const game = new Phaser.Game(config);

function preload() {
  const hiRes = window.innerWidth > 1000 ? '1024' : '960';
  this.load.image('table', `/arcade/assets/img/airhockey_table-${hiRes}.webp`);
  this.load.image('puck', `/arcade/assets/img/puck-${hiRes}.webp`);
  this.load.image('paddle_gold', `/arcade/assets/img/paddle_gold-${hiRes}.webp`);
  this.load.image('paddle_green', `/arcade/assets/img/paddle_green-${hiRes}.webp`);
}

function create() {
  const w = config.width, h = config.height;
  const cx = w / 2, cy = h / 2;

  this.add.image(cx, cy, 'table').setDisplaySize(w, h);

  puck = this.physics.add.image(cx, cy, 'puck').setScale(0.07);
  player = this.physics.add.image(cx, h * 0.9, 'paddle_gold').setScale(0.1);
  cpuPaddle = this.physics.add.image(cx, h * 0.1, 'paddle_green').setScale(0.1);

  puck.setCollideWorldBounds(true).setBounce(0.98).setCircle(puck.width / 2).setDrag(20, 20);
  player.setCollideWorldBounds(true);
  cpuPaddle.setCollideWorldBounds(true);

  this.physics.add.collider(puck, player, onPaddleHit, null, this);
  this.physics.add.collider(puck, cpuPaddle, onPaddleHit, null, this);

  this.input.on('pointermove', pointer => {
    player.x = Phaser.Math.Clamp(pointer.x, 60, w - 60);
    player.y = Phaser.Math.Clamp(pointer.y, h / 2 + 60, h - 60);
  });

  scoreText = this.add.text(cx, 40, '0 - 0', {
    fontFamily: 'Orbitron',
    fontSize: '48px',
    color: '#ffe175',
    stroke: '#2fbf6b',
    strokeThickness: 3
  }).setOrigin(0.5, 0);

  resetPuck();
}

function onPaddleHit(puck, paddle) {
  const dx = puck.x - paddle.x;
  const dy = puck.y - paddle.y;
  const len = Math.sqrt(dx * dx + dy * dy) || 1;
  const nx = dx / len, ny = dy / len;
  const relVelX = paddle.body.velocity.x - puck.body.velocity.x;
  const relVelY = paddle.body.velocity.y - puck.body.velocity.y;
  const relSpeed = Math.sqrt(relVelX * relVelX + relVelY * relVelY);
  const impulse = Phaser.Math.Clamp(relSpeed * 0.4, 0, 400);
  puck.body.velocity.x += nx * impulse;
  puck.body.velocity.y += ny * impulse;
  puck.setAngularVelocity(Phaser.Math.Between(-60, 60));
}

function update() {
  const w = config.width, h = config.height;
  playerVel.x = player.x - prevPlayer.x;
  playerVel.y = player.y - prevPlayer.y;
  prevPlayer.x = player.x;
  prevPlayer.y = player.y;

  // CPU tracking AI
  cpuPaddle.x += (puck.x - cpuPaddle.x) * 0.08;
  if (puck.y < h / 2) cpuPaddle.y += (puck.y - cpuPaddle.y) * 0.05;
  cpuPaddle.y = Phaser.Math.Clamp(cpuPaddle.y, 60, h / 2 - 60);

  // goals (top & bottom)
  const goalWidth = 200;
  if (puck.y < 30 && Math.abs(puck.x - w / 2) < goalWidth / 2) {
    scorePlayer++; resetPuck('player');
  }
  if (puck.y > h - 30 && Math.abs(puck.x - w / 2) < goalWidth / 2) {
    scoreCPU++; resetPuck('cpu');
  }
}

function resetPuck(scoredBy) {
  const w = config.width, h = config.height;
  puck.setPosition(w / 2, h / 2);
  const angle = Phaser.Math.Between(25, 155) * (Phaser.Math.Between(0, 1) ? 1 : -1);
  const speed = Phaser.Math.Between(260, 340);
  const vx = Math.cos(angle * Math.PI / 180) * speed;
  const vy = (scoredBy === 'player' ? -1 : 1) * Math.abs(Math.sin(angle * Math.PI / 180) * speed);
  puck.setVelocity(vx, vy);
  scoreText.setText(`${scorePlayer} - ${scoreCPU}`);
}
</script>
</body>
</html>
