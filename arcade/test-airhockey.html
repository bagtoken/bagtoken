<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<meta name="format-detection" content="telephone=no"/>
<title>$BAG Air Hockey ‚Äî Arcade P2E</title>

<style>
  *{box-sizing:border-box}
  :root{
    --gold:#ffe175;--bg:#020703;--panel:#0b1b13;--panel2:#0d2217;--muted:#aeb7af;--fg:#f5f7f4;
    --green:#2fbf6b;--green-600:#249a55;--line:#173524;--shadow:rgba(0,0,0,.35);
  }
  html,body{margin:0;background:var(--bg);color:var(--fg);
    font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.55}
  body{touch-action:manipulation;}
  img{display:block;max-width:100%;height:auto}
  button,input{font-size:16px}

  .wrap{max-width:1120px;margin:0 auto;padding:16px}
  .back-casino{
    position:fixed;top:16px;left:16px;z-index:1000;
    background:linear-gradient(180deg,#ffe175 0%,#f5c94c 100%);
    color:#08130d;text-decoration:none;font-weight:800;padding:8px 14px;border-radius:10px;
    box-shadow:0 4px 0 #b08a19;transition:all .15s ease
  }
  .back-casino:hover{filter:brightness(1.05);box-shadow:0 4px 0 #b08a19,0 14px 28px rgba(255,225,117,.22)}
  .back-casino:active{transform:translateY(1px);box-shadow:0 3px 0 #9a7315}

  .hero{text-align:center;padding:64px 10px 16px}
  .hero h2{font-size:clamp(1.6rem,5vw,2.2rem);margin:8px 0 0}
  .micro{font-size:.92rem;color:#cfe1d6}
  .panel{background:linear-gradient(180deg,var(--panel) 0%,var(--panel2) 100%);
    border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 24px var(--shadow)}
  .pad{padding:16px}
  .grid{display:grid;grid-template-columns:1.1fr .9fr;gap:20px}
  @media (max-width:900px){.grid{grid-template-columns:1fr}}

  .section-title{font-weight:800;font-size:1.1rem;margin:6px 0 10px}
  .divider{height:1px;background:#123221;margin:12px 0}

  .hudbar{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin:8px 0 0}
  .pill{background:#0a1e15;border:1px solid #244330;border-radius:999px;padding:6px 10px;font-size:12px;color:#cfe6d8}
  .pill b{font-weight:800}
  .mono{font-variant-numeric:tabular-nums}

  /* Quick amount chips: slightly larger */
  .preset-chips{display:flex;gap:10px;flex-wrap:wrap;margin-top:8px}
  .preset-chip{
    appearance:none;border:1px solid var(--green-600);background:var(--green);color:#fff;border-radius:999px;
    padding:10px 14px;font-weight:900;letter-spacing:.2px;cursor:pointer;
    box-shadow:0 4px 10px rgba(47,191,107,.18), inset 0 1px 0 rgba(255,255,255,.12);
    transition:transform .06s ease, box-shadow .2s ease, filter .2s ease;
  }
  .preset-chip:active{transform:translateY(1px)}
  .preset-chip.active{box-shadow:0 0 0 2px rgba(255,255,255,.25) inset, 0 8px 22px rgba(47,191,107,.25)}

  /* Game board card */
  .board-card{position:relative;border-radius:16px;overflow:hidden}
  .board-top{padding:8px 12px;border-bottom:1px solid #123221;background:linear-gradient(180deg,#0e2419,#0a1b13)}
  .board-top .title{font-weight:900;letter-spacing:.08em;color:#ffe9a6;text-align:center}
  .board-wrap{position:relative;background:#07140e}
  canvas#air{display:block;width:100%;height:auto;touch-action:none}

  /* Start overlay floating over board */
  .start-overlay{
    position:absolute;inset:0;display:grid;place-items:center;background:rgba(0,0,0,.38);
    z-index:5;backdrop-filter:blur(2px)
  }
  .start-box{
    background:linear-gradient(180deg,var(--panel) 0%,var(--panel2) 100%);
    border:1px solid var(--line);border-radius:14px;padding:14px 16px;text-align:center;
    box-shadow:0 20px 50px rgba(0,0,0,.45);max-width:min(92vw,520px)
  }
  .btn{min-width:140px;padding:12px 14px;border:0;border-radius:12px;font-weight:900;cursor:pointer;color:#08130d;background:linear-gradient(180deg,#ffe175,#f5c94c)}
  .btn.alt{color:#e9efe9;background:#15261c;border:1px solid #2b6a48}

  /* Countdown badge */
  .countdown{
    position:absolute;top:10px;left:50%;transform:translateX(-50%);
    background:#0e2a1c;border:1px solid #2b6a48;border-radius:999px;padding:6px 12px;font-weight:900;z-index:4
  }

  /* Mobile layout helpers */
  @media (max-width:600px){
    .btn{min-width:120px}
    .pill{font-size:12px;padding:6px 10px}
  }
</style>
</head>
<body>

<a href="/casino/" class="back-casino">‚¨ÖÔ∏è Back to Casino</a>

<main class="wrap">

  <!-- HERO (kept clean) -->
  <section class="hero">
    <picture>
      <source type="image/webp" srcset="/arcade/assets/img/bag-airhockey-1024.webp 1024w, /arcade/assets/img/bag-airhockey-960.webp 960w" sizes="(min-width:900px) 560px, 90vw">
      <img src="/arcade/assets/img/bag-airhockey-960.png" alt="$BAG Air Hockey" width="1024" height="576" loading="eager" decoding="async" style="margin:0 auto 10px;filter:drop-shadow(0 10px 24px rgba(46,191,107,.18))">
    </picture>
    <h2>üèí $BAG AIR HOCKEY</h2>
    <p class="micro" style="margin-top:4px;opacity:.9;">All payouts settle in $BAG. $XRP wagers auto-convert at the live rate.</p>
  </section>

  <section class="grid">
    <!-- LEFT: Controls / Session / Prices -->
    <div class="panel pad">

      <!-- Session + Practice pills (BAG ¬∑ XRP ¬∑ USD) -->
      <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
        <div id="sessionStatus" class="micro" style="opacity:.9">Session: <span style="color:#2fbf6b">Practice</span></div>
        <div style="display:flex;gap:8px">
          <button id="startSessionBtn" class="btn">Start Session</button>
          <button id="topUpBtn" class="btn" style="display:none">Top Up</button>
          <button id="endSessionBtn" class="btn" style="display:none">End</button>
        </div>
      </div>

      <div id="practiceReadout" class="hudbar" style="margin-top:10px">
        <span class="pill"><b>BAG</b>: <span id="pracBag" class="mono">‚Äî</span></span>
        <span class="pill"><b>XRP</b>: <span id="pracXrp" class="mono">‚Äî</span></span>
        <span class="pill"><b>USD</b>: <span id="pracUsd" class="mono">‚Äî</span></span>
      </div>

      <!-- Live prices BELOW practice -->
      <div class="divider"></div>
      <div class="micro">Live prices</div>
      <div class="hudbar">
        <span class="pill">Source: <b id="priceSrc">‚Äî</b></span>
        <span class="pill">BAG: <b id="bagUsd" class="mono">‚Äî</b> USD</span>
        <span class="pill">XRP: <b id="xrpUsd" class="mono">‚Äî</b> USD</span>
        <span class="pill">1 XRP ‚âà <b id="bagPerXrp" class="mono">‚Äî</b> BAG</span>
      </div>

      <!-- Match settings -->
      <div class="divider"></div>
      <div class="section-title">Match Setup</div>

      <div class="micro">Series</div>
      <div class="hudbar" role="group" aria-label="Best-of series">
        <label class="pill"><input type="radio" name="series" value="3" checked> Best of 3</label>
        <label class="pill"><input type="radio" name="series" value="5"> Best of 5</label>
        <label class="pill"><input type="radio" name="series" value="7"> Best of 7</label>
      </div>

      <div class="micro" style="margin-top:8px">Target score (per game)</div>
      <div class="hudbar" role="group" aria-label="Target score">
        <label class="pill"><input type="radio" name="target" value="5" checked> 5</label>
        <label class="pill"><input type="radio" name="target" value="7"> 7</label>
        <label class="pill"><input type="radio" name="target" value="10"> 10</label>
      </div>

      <!-- Head-to-Head connect -->
      <div class="divider"></div>
      <div class="section-title">Head-to-Head</div>
      <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center">
        <button id="createMatchBtn" class="btn">Create Match</button>
        <input id="matchCodeInput" class="mono" placeholder="Enter code"
               style="width:160px;background:#0b2217;border:1px solid #1b4a2f;border-radius:10px;color:#f5f7f4;padding:10px">
        <button id="joinMatchBtn" class="btn">Join Match</button>
        <span id="matchStatus" class="micro" style="opacity:.9;margin-left:6px">Not connected</span>
      </div>

      <!-- Wager -->
      <div class="divider"></div>
      <div class="section-title">Wager</div>
      <div style="display:flex;flex-wrap:wrap;gap:10px;align-items:center">
        <div style="display:flex;gap:6px;align-items:center">
          <input id="wagerQty" class="mono" type="number" inputmode="decimal" min="0" step="any" value="1"
                 style="width:140px;background:#0b2217;border:1px solid #1b4a2f;border-radius:10px;color:#f5f7f4;padding:12px">
          <span class="micro">XRP</span>
        </div>
        <button id="proposeWagerBtn" class="btn">Propose</button>
        <button id="lockStakeBtn" class="btn">Lock Stake</button>
        <span id="wagerStatus" class="micro" style="opacity:.9;margin-left:6px">No wager</span>
      </div>

      <!-- Quick amount chips (bigger) -->
      <div class="preset-chips" id="wagerPresets" style="margin-top:8px">
        <button type="button" class="preset-chip" data-xrp="1">1 XRP</button>
        <button type="button" class="preset-chip" data-xrp="2">2 XRP</button>
        <button type="button" class="preset-chip" data-xrp="5">5 XRP</button>
        <button type="button" class="preset-chip" data-xrp="10">10 XRP</button>
        <button type="button" class="preset-chip" data-xrp="25">25 XRP</button>
      </div>

    </div>

    <!-- RIGHT: Board -->
    <div class="panel board-card">
      <div class="board-top"><div class="title">$BAG AIR HOCKEY</div></div>
      <div class="board-wrap" id="boardWrap">
        <div class="countdown" id="countdown" style="display:none">3</div>

        <!-- Start overlay (floats, disappears once game begins) -->
        <div class="start-overlay" id="startOverlay">
          <div class="start-box">
            <div style="font-weight:900;margin-bottom:6px">Ready to play</div>
            <div class="micro" style="margin-bottom:12px">
              Select series & target, set your wager, then start.
              <br>In Head-to-Head, both players must lock stakes.
            </div>
            <div style="display:flex;gap:10px;justify-content:center;flex-wrap:wrap">
              <button id="startBtn" class="btn">Start Game</button>
              <button id="practiceBtn" class="btn alt">Practice (solo)</button>
            </div>
          </div>
        </div>

        <!-- Canvas (kept logical size; CSS scales to width) -->
        <canvas id="air" width="900" height="560" aria-label="Air Hockey table"></canvas>
      </div>
    </div>
  </section>
</main>

<!-- AUDIO: paddle-hit only, countdown beeps, final buzzer -->
<script>
(function(){
  const AC = new (window.AudioContext||window.webkitAudioContext)();
  let primed=false;
  function prime(){ if(primed) return; primed=true; try{ AC.resume(); }catch{} }
  ['pointerdown','touchstart','keydown','wheel','mousedown'].forEach(ev=>addEventListener(ev, prime, {once:true,passive:true}));

  function envHit(){
    const t=AC.currentTime;
    const o=AC.createOscillator(); o.type='square';
    const g=AC.createGain();
    o.frequency.setValueAtTime(1700,t);
    o.frequency.exponentialRampToValueAtTime(650,t+.06);
    g.gain.setValueAtTime(.0001,t);
    g.gain.linearRampToValueAtTime(.22,t+.008);
    g.gain.exponentialRampToValueAtTime(.0001,t+.12);
    o.connect(g).connect(AC.destination);
    o.start(t); o.stop(t+.14);
  }
  function beep(n=3, interval=.5){
    const now=AC.currentTime;
    for(let i=0;i<n;i++){
      const t=now + i*interval;
      const o=AC.createOscillator(); o.type='sine';
      const g=AC.createGain();
      o.frequency.setValueAtTime(800 + i*80, t);
      g.gain.setValueAtTime(.0001,t);
      g.gain.linearRampToValueAtTime(.25,t+.02);
      g.gain.exponentialRampToValueAtTime(.0001,t+.24);
      o.connect(g).connect(AC.destination); o.start(t); o.stop(t+.24);
    }
  }
  function buzzer(){
    const t=AC.currentTime;
    const n=AC.createBufferSource(), b=AC.createBuffer(1, AC.sampleRate*0.35|0, AC.sampleRate);
    const d=b.getChannelData(0); for(let i=0;i<d.length;i++){ d[i]=(Math.random()*2-1)*((1-i/d.length)**2)*.45; }
    const lp=AC.createBiquadFilter(); lp.type='lowpass'; lp.Q.value=0.7; lp.frequency.value=360;
    const g=AC.createGain(); g.gain.setValueAtTime(.2,t); g.gain.exponentialRampToValueAtTime(.0001,t+.35);
    n.buffer=b; n.connect(lp).connect(g).connect(AC.destination); n.start(t); n.stop(t+.36);
  }

  window.__AH_AUDIO__ = { hit:envHit, beeps:beep, over:buzzer, resume:()=>AC.resume().catch(()=>{}) };
})();
</script>

<!-- PRICES (BAG via XRPL AMM; XRP via CoinGecko). Cached fallback. -->
<script>
(function(){
  const PRICE_REFRESH_MS = 15000, FETCH_TIMEOUT_MS = 8000;
  const VIEW_CACHE_TTL_MS = 6*60*60*1000, LIVE_CACHE_TTL_MS = 24*60*60*1000;

  const VIEW_KEY='bag_prices_v8', LAST_LIVE='bag_last_live_v1', XRP_KEY='xrp_usd';
  const PRICES = (window.__PRICES__ = { bagUsd:0, xrpUsd:0, source:'‚Äî' });

  const elSrc = document.getElementById('priceSrc');
  const elB   = document.getElementById('bagUsd');
  const elX   = document.getElementById('xrpUsd');
  const elC   = document.getElementById('bagPerXrp');

  function fmt(n, d=6){ return Number(n||0).toLocaleString(undefined,{maximumFractionDigits:d}); }
  function cacheSet(k,v){ try{ localStorage.setItem(k, JSON.stringify({t:Date.now(), v})); }catch{} }
  function cacheGet(k, ttl){ try{ const o=JSON.parse(localStorage.getItem(k)||'null'); if(!o) return null; if(Date.now()-(o.t||0) > ttl) return null; return o.v; }catch{ return null; } }

  function updateUI(){
    if (elSrc) elSrc.textContent = PRICES.source==='live-amm'?'AMM Live': (PRICES.source==='last-live'?'Last Live':'‚Äî');
    if (elB) elB.textContent = fmt(PRICES.bagUsd, 6);
    if (elX) elX.textContent = Number(PRICES.xrpUsd||0).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
    if (elC){
      if (PRICES.bagUsd>0 && PRICES.xrpUsd>0){
        elC.textContent = (PRICES.xrpUsd/PRICES.bagUsd).toLocaleString(undefined,{maximumFractionDigits:6});
      } else elC.textContent = '‚Äî';
    }
    window.dispatchEvent(new CustomEvent('bag:pricesUpdated'));
  }

  function timedFetch(u, opts={}, timeout=FETCH_TIMEOUT_MS){
    const ctrl=new AbortController(); const id=setTimeout(()=>ctrl.abort(), timeout);
    return fetch(u,{...opts,signal:ctrl.signal,cache:'no-store'}).finally(()=>clearTimeout(id));
  }

  async function fetchXrpUsd(){
    try{
      const r=await timedFetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
      const v=(await r.json())?.ripple?.usd;
      if (Number(v)>0){ PRICES.xrpUsd = Number(v); cacheSet(XRP_KEY, PRICES.xrpUsd); return true; }
    }catch{}
    return false;
  }

  async function fetchBagViaAMM(){
    const BAG_ISSUER='rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr', BAG_CODE='BAG';
    const req={ id:1, command:'amm_info', asset:{currency:BAG_CODE,issuer:BAG_ISSUER}, asset2:{currency:'XRP'} };
    const xrpPerBag = await new Promise((resolve)=>{
      const ws=new WebSocket('wss://s1.ripple.com'); const t=setTimeout(()=>{try{ws.close();}catch{}; resolve(null);}, 7000);
      ws.onopen=()=>ws.send(JSON.stringify(req));
      ws.onerror=()=>{ clearTimeout(t); try{ws.close();}catch{}; resolve(null); };
      ws.onmessage=(e)=>{ try{
        const m=JSON.parse(e.data); if(m.id!==1||!m.result||!m.result.amm) return;
        clearTimeout(t); try{ws.close();}catch{};
        const bag=Number(m.result.amm.amount?.value||0), xrp=Number(m.result.amm.amount2?.value||0);
        if (bag>0 && xrp>0) resolve(xrp/bag); else resolve(null);
      }catch{ resolve(null); }};
    });
    if (!(xrpPerBag>0)) return false;
    if (!(PRICES.xrpUsd>0)) return false;
    PRICES.bagUsd = PRICES.xrpUsd * xrpPerBag;
    PRICES.source = 'live-amm';
    cacheSet(LAST_LIVE,{ bagUsd:PRICES.bagUsd, xrpUsd:PRICES.xrpUsd });
    cacheSet(VIEW_KEY,{ bagUsd:PRICES.bagUsd, xrpUsd:PRICES.xrpUsd });
    return true;
  }

  function loadLastLive(){
    const v=cacheGet(LAST_LIVE,LIVE_CACHE_TTL_MS);
    if (v && Number(v.bagUsd)>0){ PRICES.bagUsd=Number(v.bagUsd); if(Number(v.xrpUsd)>0) PRICES.xrpUsd=Number(v.xrpUsd); PRICES.source='last-live'; return true; }
    return false;
  }
  function loadView(){
    const v=cacheGet(VIEW_KEY,VIEW_CACHE_TTL_MS), x=cacheGet(XRP_KEY,VIEW_CACHE_TTL_MS); let ok=false;
    if (v && Number(v.bagUsd)>0){ PRICES.bagUsd=Number(v.bagUsd); if(Number(v.xrpUsd)>0) PRICES.xrpUsd=Number(v.xrpUsd); ok=true; }
    if (!PRICES.xrpUsd && Number(x)>0){ PRICES.xrpUsd=Number(x); ok=true; }
    if (ok && PRICES.source==='‚Äî') PRICES.source='last-live';
    return ok;
  }

  async function refresh(){
    const gotX=await fetchXrpUsd();
    const gotB=await fetchBagViaAMM();
    if(!(gotX&&gotB)){ if(!loadLastLive()) loadView(); }
    updateUI();
  }

  refresh(); setInterval(refresh, PRICE_REFRESH_MS);
})();
</script>

<!-- DEMO SESSION (Practice balance): seeds $2,000 equivalent -->
<script>
(function(){
  const START_USD=2000, DEMO_BAL_KEY='__bag_demo_bag_v2', DEMO_INIT_KEY='__bag_demo_init_v2';
  const statusEl=document.getElementById('sessionStatus');
  const bEl=document.getElementById('pracBag'), xEl=document.getElementById('pracXrp'), uEl=document.getElementById('pracUsd');
  const startBtn=document.getElementById('startSessionBtn'), topBtn=document.getElementById('topUpBtn'), endBtn=document.getElementById('endSessionBtn');

  function PR(){ return window.__PRICES__||{bagUsd:0,xrpUsd:0}; }
  function getBag(){ try{ const n=Number(localStorage.getItem(DEMO_BAL_KEY)); return Number.isFinite(n)&&n>0?n:0; }catch{ return 0; } }
  function setBag(v){ try{ localStorage.setItem(DEMO_BAL_KEY, String(Math.max(0, Number(v)||0))); }catch{} }
  function fmtN(n,d=6){ return Number(n||0).toLocaleString(undefined,{maximumFractionDigits:d}); }

  function ensureSeed(){
    if (localStorage.getItem(DEMO_INIT_KEY)) return true;
    const { bagUsd } = PR(); if (!(bagUsd>0)) return false;
    setBag(START_USD/bagUsd); localStorage.setItem(DEMO_INIT_KEY,'1'); return true;
  }
  function render(){
    const { bagUsd, xrpUsd } = PR();
    const bag=getBag();
    const usd = bagUsd>0 ? bag*bagUsd : START_USD;
    const xrp = (bagUsd>0 && xrpUsd>0) ? (bag*(bagUsd/xrpUsd)) : 0;
    if (statusEl) statusEl.innerHTML = 'Session: <span style="color:#2fbf6b">Practice</span>';
    if (bEl) bEl.textContent = fmtN(bag);
    if (xEl) xEl.textContent = fmtN(xrp);
    if (uEl) uEl.textContent = (Number(usd)||0).toLocaleString(undefined,{style:'currency',currency:'USD',minimumFractionDigits:2,maximumFractionDigits:2});
    if (startBtn) startBtn.style.display='inline-block';
    if (topBtn) topBtn.style.display='none';
    if (endBtn)  endBtn.style.display='none';
  }

  window.__bagSession = {
    active:()=>true,
    get:()=>({ addr:'demo', bag:getBag(), ts:Date.now() }),
    spend:(bag)=>{ const b=getBag(); if(!(bag>0)||b<bag) return false; setBag(b-bag); render(); window.dispatchEvent(new Event('bag:hudRefresh')); return true; },
    credit:(bag)=>{ if(!(bag>0)) return false; setBag(getBag()+bag); render(); window.dispatchEvent(new Event('bag:hudRefresh')); return true; }
  };

  function maybeSeed(){ if (!localStorage.getItem(DEMO_INIT_KEY)){ if(ensureSeed()) render(); } else render(); }
  maybeSeed();
  addEventListener('bag:pricesUpdated', maybeSeed);
  topBtn?.addEventListener('click', ()=>{ const { bagUsd }=PR(); if (bagUsd>0){ setBag(START_USD/bagUsd); render(); } });

})();
</script>

<!-- H2H minimal state + Wager lock (Demo escrow). Start gate helpers. -->
<script>
(function(){
  const S = (window.__AH_MATCH__ = {
    role:null, code:null, connected:false, peerReady:false, youReady:false,
    wagerXrp:0, stakeYouLocked:0, stakePeerLocked:0
  });
  const $=s=>document.querySelector(s);
  const status=txt=>{ const el=$('#matchStatus'); if(el) el.textContent=txt; };
  function randomCode(len=6){ const A='ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; let o=''; for(let i=0;i<len;i++) o+=A[(Math.random()*A.length)|0]; return o; }

  $('#createMatchBtn')?.addEventListener('click', ()=>{
    if(S.connected) return;
    S.role='host'; S.code=randomCode(); S.connected=true; S.youReady=true; status(`Hosting ${S.code} ‚Äî waiting for opponent`);
    console.log('[AH] Host code:', S.code);
  });
  $('#joinMatchBtn')?.addEventListener('click', ()=>{
    if(S.connected) return;
    const code=($('#matchCodeInput')?.value||'').trim().toUpperCase();
    if(!code){ alert('Enter a match code'); return; }
    S.role='guest'; S.code=code; S.connected=true; S.youReady=true; status(`Joined ${S.code} ‚Äî waiting for host`);
    console.log('[AH] Joined code:', S.code);
  });

  // Exposed for future signaling
  window.AH_MARK_PEER_READY = function(){ S.peerReady=true; status(`Connected: ${S.code}`); };
  window.AH_CAN_START = function(){
    if (!S.connected) return true; // solo/practice allowed
    return S.connected && S.peerReady && S.stakeYouLocked>0 && S.stakePeerLocked>0;
  };
})();
</script>

<script>
(function(){
  const S = window.__AH_MATCH__;
  const $=s=>document.querySelector(s);
  function PR(){ return window.__PRICES__||{bagUsd:0,xrpUsd:0}; }
  const nf=(n,d=6)=> Number(n||0).toLocaleString(undefined,{maximumFractionDigits:d});
  function xrpToBag(xrp){ const {bagUsd,xrpUsd}=PR(); if(!(bagUsd>0&&xrpUsd>0)) return 0; return (xrp*xrpUsd)/bagUsd; }
  function spend(bag){ const sess=window.__bagSession; return (sess&&sess.spend)?sess.spend(bag):false; }
  function credit(bag){ const sess=window.__bagSession; return (sess&&sess.credit)?sess.credit(bag):false; }
  function wStatus(t){ const el=$('#wagerStatus'); if(el) el.textContent=t; }

  // Quick chips
  (function(){
    const root=document.getElementById('wagerPresets'); if(!root) return;
    root.querySelectorAll('button[data-xrp]').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        const v=parseFloat(btn.getAttribute('data-xrp')||'0')||0;
        const inp=document.getElementById('wagerQty'); if(inp){ inp.value=String(v); }
        root.querySelectorAll('button').forEach(b=>b.classList.remove('active')); btn.classList.add('active');
      });
    });
  })();

  document.getElementById('proposeWagerBtn')?.addEventListener('click', ()=>{
    const amt=parseFloat(document.getElementById('wagerQty')?.value||'0')||0;
    if(!(amt>0)) return alert('Enter a wager');
    S.wagerXrp=amt; S.stakeYouLocked=0; S.stakePeerLocked=0;
    wStatus(`Proposed ${nf(amt)} XRP ‚Äî waiting peer`);
    console.log('[AH] Proposed wager', amt, 'XRP');
  });

  // For future: call this when peer proposes
  window.AH_ON_PEER_WAGER = function(xrp){
    S.wagerXrp = Number(xrp)||0; S.stakeYouLocked=0; S.stakePeerLocked=0;
    wStatus(`Peer proposed ${nf(S.wagerXrp)} XRP ‚Äî lock to accept`);
  };

  document.getElementById('lockStakeBtn')?.addEventListener('click', ()=>{
    if(!(S.wagerXrp>0)) return alert('No wager set');
    const needBag = xrpToBag(S.wagerXrp);
    if(!(needBag>0)) return alert('Live price unavailable');
    if(!spend(needBag)) return alert('Insufficient Practice balance');
    S.stakeYouLocked=needBag; wStatus(`You locked ${nf(S.wagerXrp)} XRP (${nf(needBag)} BAG). Waiting peer.`);
    window.dispatchEvent(new Event('bag:hudRefresh'));
    console.log('[AH] You locked stake');
  });

  // Call when peer confirms lock (future)
  window.AH_ON_PEER_LOCK = function(){
    S.stakePeerLocked = xrpToBag(S.wagerXrp||0);
    wStatus('Both locked');
    window.dispatchEvent(new Event('bag:hudRefresh'));
  };

  window.AH_PAYOUT_SERIES = function(result){
    const total = Number(S.stakeYouLocked||0)+Number(S.stakePeerLocked||0);
    if(!total) return;
    if(result==='win') credit(total);
    S.stakeYouLocked=0; S.stakePeerLocked=0;
    wStatus('No wager');
    window.dispatchEvent(new Event('bag:hudRefresh'));
  };
})();
</script>

<!-- AIR HOCKEY GAME CORE -->
<script>
(function(){
  const canvas = document.getElementById('air');
  const ctx = canvas.getContext('2d');

  // Fit canvas within viewport width while keeping logical resolution
  function resizeCss(){
    const wrap = document.getElementById('boardWrap');
    if(!wrap) return;
    const maxW = wrap.clientWidth;
    const ratio = canvas.height / canvas.width;
    canvas.style.width = Math.min(maxW, 1024) + 'px';
    canvas.style.height = Math.round(Math.min(maxW, 1024) * ratio) + 'px';
  }
  addEventListener('resize', resizeCss);
  resizeCss();

  // Table dimensions (logical)
  const W = canvas.width, H = canvas.height;
  const GOAL_W = 160, RINK = { x:20, y:20, w:W-40, h:H-40, r:22 };
  const CENTER_LINE = H/2;

  // Entities
  const puck = { x:W/2, y:H/2, r:14, vx:0, vy:0, max:12, damp:0.995 };
  const p1 = { x:W/2, y:H-90, r:26, isDown:false, ox:0, oy:0, zone:[H/2, H], lastY:null };
  const cpu= { x:W/2, y:90,   r:26, speed:7 };

  // Game state
  let running=false, countdown=false, bestOf=3, target=5, gLeft=0;
  let score1=0, score2=0, gameNo=1;
  let seriesWins1=0, seriesWins2=0;
  const cdEl = document.getElementById('countdown');
  const startOv = document.getElementById('startOverlay');
  const startBtn = document.getElementById('startBtn');
  const pracBtn  = document.getElementById('practiceBtn');

  // Physics helpers
  function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  function resetPuck(dir= (Math.random()<0.5?1:-1)){
    puck.x=W/2; puck.y=H/2;
    const a = (Math.random()*Math.PI/3) + (Math.PI/6);
    const s = 6.5;
    puck.vx = s * Math.cos(a) * dir;
    puck.vy = s * Math.sin(a) * (Math.random()<0.5?-1:1);
  }
  function resetRound(){
    score1=0; score2=0; resetPuck();
  }

  // Touch/mouse: smooth slide (no hop)
  let pointerId=null;
  function pt(e){ const rect=canvas.getBoundingClientRect(); const x=(e.clientX-rect.left)*(canvas.width/rect.width); const y=(e.clientY-rect.top)*(canvas.height/rect.height); return {x,y}; }
  function onDown(e){
    if(pointerId!==null) return;
    pointerId = e.pointerId||0;
    const {x,y}=pt(e);
    const dy = y - p1.y, dx = x - p1.x;
    if (dx*dx + dy*dy <= (p1.r*1.6)*(p1.r*1.6)){ p1.isDown=true; p1.ox=x-p1.x; p1.oy=y-p1.y; p1.lastY=y; }
    canvas.setPointerCapture && canvas.setPointerCapture(pointerId);
    e.preventDefault();
  }
  function onMove(e){
    if(pointerId!== (e.pointerId||0)) return;
    if(!p1.isDown) return;
    const {x,y}=pt(e);
    // Constrain to your half
    const nx = clamp(x-p1.ox, RINK.x + p1.r, RINK.x + RINK.w - p1.r);
    const ny = clamp(y-p1.oy, CENTER_LINE + p1.r, RINK.y + RINK.h - p1.r);
    // Smooth: interpolate to avoid jump
    const alpha = 0.7;
    p1.x = p1.lastX ? p1.x*(1-alpha) + nx*alpha : nx;
    p1.y = p1.lastY ? p1.y*(1-alpha) + ny*alpha : ny;
    p1.lastX = nx; p1.lastY = ny;
    e.preventDefault();
  }
  function onUp(e){
    if(pointerId!== (e.pointerId||0)) return;
    p1.isDown=false; pointerId=null;
    canvas.releasePointerCapture && canvas.releasePointerCapture(e.pointerId||0);
    e.preventDefault();
  }
  canvas.addEventListener('pointerdown', onDown, {passive:false});
  canvas.addEventListener('pointermove', onMove, {passive:false});
  addEventListener('pointerup', onUp, {passive:false});
  addEventListener('pointercancel', onUp, {passive:false});

  // Countdown flow
  async function doCountdown(cb){
    countdown=true; cdEl.style.display='block';
    window.__AH_AUDIO__?.beeps(3,0.6);
    for (let i=3;i>0;i--){
      cdEl.textContent=String(i);
      await new Promise(r=>setTimeout(r,600));
    }
    cdEl.textContent='GO'; await new Promise(r=>setTimeout(r,300));
    cdEl.style.display='none'; countdown=false;
    cb && cb();
  }

  // Start handlers
  function readMatchOptions(){
    bestOf = parseInt(document.querySelector('input[name="series"]:checked')?.value||'3',10);
    target = parseInt(document.querySelector('input[name="target"]:checked')?.value||'5',10);
    gLeft = Math.ceil(bestOf/2);
  }
  function canStart(){
    if (typeof window.AH_CAN_START === 'function'){
      return window.AH_CAN_START();
    }
    return true;
  }

  startBtn.onclick = ()=>{
    if (!canStart()){ alert('Both players must connect and lock stakes.'); return; }
    readMatchOptions();
    startOv.style.display='none';
    doCountdown(()=>{
      gameNo=1; seriesWins1=0; seriesWins2=0; resetRound(); running=true;
    });
  };
  // Solo practice bypass H2H gate
  pracBtn.onclick = ()=>{
    readMatchOptions();
    startOv.style.display='none';
    doCountdown(()=>{
      gameNo=1; seriesWins1=0; seriesWins2=0; resetRound(); running=true;
    });
  };

  // CPU (simple)
  function cpuThink(){
    // Track puck only when on CPU half or approaching
    const targetY = (puck.y < CENTER_LINE || puck.vy < 0) ? clamp(puck.y, p1.r, CENTER_LINE - cpu.r) : cpu.y;
    const targetX = clamp(puck.x, RINK.x+cpu.r, RINK.x+RINK.w-cpu.r);
    // Move toward target with speed cap
    const dx = targetX - cpu.x, dy = targetY - cpu.y;
    const d = Math.hypot(dx,dy) || 1;
    const step = Math.min(cpu.speed, d);
    cpu.x += dx/d * step;
    cpu.y += dy/d * step;
  }

  // Collision + audio (hit only on paddle contact)
  function collideCircle(a, b){
    const dx=b.x-a.x, dy=b.y-a.y, dist=Math.hypot(dx,dy);
    const min = a.r + b.r;
    if (dist < min){
      // Resolve overlap
      const nx = dx/(dist||1), ny = dy/(dist||1);
      const overlap = min - dist;
      b.x += nx * overlap * 0.6;
      b.y += ny * overlap * 0.6;
      // Reflect puck velocity on normal
      const v = {x:puck.vx, y:puck.vy};
      const dot = v.x*nx + v.y*ny;
      puck.vx = v.x - 2*dot*nx;
      puck.vy = v.y - 2*dot*ny;
      // Add paddle motion influence (for player feel)
      const k=0.35;
      if (a === p1 && p1.lastY!=null){
        const py = p1.lastY - p1.y; // how fast player dragged
        puck.vy -= py * k;
      }
      // Cap speed
      const sp = Math.hypot(puck.vx,puck.vy);
      const max = puck.max;
      if (sp>max){ puck.vx = puck.vx/sp*max; puck.vy = puck.vy/sp*max; }
      // Sound
      window.__AH_AUDIO__?.hit();
    }
  }

  function walls(){
    // Side walls
    if (puck.x - puck.r < RINK.x){ puck.x = RINK.x + puck.r; puck.vx = -puck.vx; }
    if (puck.x + puck.r > RINK.x + RINK.w){ puck.x = RINK.x + RINK.w - puck.r; puck.vx = -puck.vx; }
    // Top/bottom w/ goals
    const goalL = (W/2 - GOAL_W/2), goalR=(W/2 + GOAL_W/2);
    // Top (CPU goal)
    if (puck.y - puck.r < RINK.y){
      // If within goal mouth, it's a score for Player 1
      if (puck.x>goalL && puck.x<goalR){
        score1++; onScore(1);
      } else { puck.y = RINK.y + puck.r; puck.vy = -puck.vy; }
    }
    // Bottom (Player goal)
    if (puck.y + puck.r > RINK.y + RINK.h){
      if (puck.x>goalL && puck.x<goalR){
        score2++; onScore(2);
      } else { puck.y = RINK.y + RINK.h - puck.r; puck.vy = -puck.vy; }
    }
  }

  function onScore(who){
    // Reset positions
    p1.x=W/2; p1.y=H-90; cpu.x=W/2; cpu.y=90;
    if (score1>=target || score2>=target){
      // Game end
      if (score1>score2) seriesWins1++; else seriesWins2++;
      // Buzzer
      window.__AH_AUDIO__?.over();
      // Next game or series end
      if (seriesWins1 > bestOf/2 || seriesWins2 > bestOf/2){
        // Series end
        const youWin = seriesWins1>seriesWins2;
        // Demo payout
        window.AH_PAYOUT_SERIES && window.AH_PAYOUT_SERIES( youWin ? 'win' : 'loss' );
        // Show overlay again to restart fresh
        startOv.style.display='grid';
        running=false;
        return;
      } else {
        gameNo++;
        score1=0; score2=0;
      }
    }
    resetPuck(who===2 ? 1 : -1);
  }

  // Main loop
  function step(){
    if (running && !countdown){
      // CPU AI
      cpuThink();
      // Puck integrate
      puck.x += puck.vx; puck.y += puck.vy;
      puck.vx *= puck.damp; puck.vy *= puck.damp;

      // Collisions
      collideCircle(p1, puck);
      collideCircle(cpu, puck);
      walls();
    }
    draw();
    requestAnimationFrame(step);
  }

  function drawTable(){
    ctx.clearRect(0,0,W,H);
    // Rink
    ctx.fillStyle='#0b2016'; ctx.strokeStyle='#1b4a2f'; ctx.lineWidth=2;
    roundRect(RINK.x,RINK.y,RINK.w,RINK.h, RINK.r);
    ctx.fill(); ctx.stroke();

    // Center line
    ctx.strokeStyle='#1f5a3a'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(RINK.x, H/2); ctx.lineTo(RINK.x+RINK.w, H/2); ctx.stroke();

    // Goals
    ctx.strokeStyle='#2b6a48'; ctx.lineWidth=4;
    ctx.beginPath(); ctx.moveTo(W/2-GOAL_W/2, RINK.y); ctx.lineTo(W/2+GOAL_W/2, RINK.y); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(W/2-GOAL_W/2, RINK.y+RINK.h); ctx.lineTo(W/2+GOAL_W/2, RINK.y+RINK.h); ctx.stroke();

    // Scores
    ctx.fillStyle='#ffe175'; ctx.font='700 20px Inter, system-ui, sans-serif';
    ctx.textAlign='left'; ctx.fillText(`You ${score1}`, RINK.x+8, H/2+24+20);
    ctx.textAlign='right'; ctx.fillText(`CPU ${score2}`, RINK.x+RINK.w-8, H/2-12);

    // Series HUD
    ctx.fillStyle='#cfe1d6'; ctx.font='700 14px Inter, system-ui, sans-serif';
    ctx.textAlign='center';
    ctx.fillText(`Game ${gameNo} / Best of ${bestOf} ¬∑ First to ${target}`, W/2, 34);
    ctx.fillText(`Series: You ${seriesWins1} ‚Äî ${seriesWins2} CPU`, W/2, 54);
  }
  function drawActors(){
    // Puck
    ctx.fillStyle='#e0f2ea'; circle(puck.x,puck.y,puck.r); ctx.fill();
    // Player
    ctx.fillStyle='#36c77a'; circle(p1.x,p1.y,p1.r); ctx.fill();
    // CPU
    ctx.fillStyle='#5aa0ff'; circle(cpu.x,cpu.y,cpu.r); ctx.fill();
  }
  function draw(){
    drawTable(); drawActors();
  }

  function circle(x,y,r){ ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); }
  function roundRect(x,y,w,h,r){
    ctx.beginPath();
    ctx.moveTo(x+r,y);
    ctx.arcTo(x+w,y,x+w,y+h,r);
    ctx.arcTo(x+w,y+h,x,y+h,r);
    ctx.arcTo(x,y+h,x,y,r);
    ctx.arcTo(x,y,x+w,y,r);
    ctx.closePath();
  }

  // Initial
  resetRound(); draw(); step();
})();
</script>

<script>
/* Simple HUD sync hook (if needed later) */
addEventListener('bag:hudRefresh', ()=>{ /* reserved */ });
</script>

<footer class="wrap" style="text-align:center;padding:14px 0;color:#a9b9af">
  ¬© 2025 $BAG Protocol ‚Äî getthebag.io ¬∑ Powered by $XRP
</footer>

</body>
</html>
