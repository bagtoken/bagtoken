<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>$BAG Air Hockey — Arcade P2E</title>
<link rel="preconnect" href="https://api.coingecko.com" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>
<style>
:root{--gold:#ffe175;--bg:#020703;--panel:#0b1b13;--panel2:#0d2217;--muted:#aeb7af;--fg:#f5f7f4;--green:#2fbf6b;--line:#173524;--shadow:rgba(0,0,0,.35)}
html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;line-height:1.5;overflow-y:auto;scrollbar-width:thin;scrollbar-color:#2fbf6b #0b1b13;overscroll-behavior:contain;-webkit-tap-highlight-color:transparent;touch-action:pan-y;user-select:none;-webkit-user-select:none}
.panel{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--line);border-radius:16px;box-shadow:0 8px 24px var(--shadow);padding:16px;margin:0 auto;max-width:1080px}
.btn{cursor:pointer;border:0;border-radius:12px;padding:10px 14px;font-weight:900;background:linear-gradient(180deg,#ffe175,#f5c94c);color:#08130d;box-shadow:0 4px 0 #b08a19}
.btn:active{transform:translateY(1px);box-shadow:0 3px 0 #9a7315}
.divider{height:1px;background:#123221;margin:14px 0}
.marquee{text-align:center;font-weight:900;letter-spacing:.08em;color:#ffe9a6;background:linear-gradient(180deg,#17311f,#0e2419);border:1px solid #254a33;border-radius:12px;padding:8px;margin:10px 0}
canvas{display:block;margin:auto}
#gameContainer{max-width:1024px;margin:auto;border-radius:12px;overflow:hidden}
#gameContainer canvas{touch-action:none;-ms-touch-action:none}
</style>
</head>
<body>
<a href="/casino/" class="btn" style="position:fixed;top:18px;left:18px;z-index:1000;">Back</a>

<section style="text-align:center;padding-top:70px;">
  <h2 style="margin:0;font-size:1.6rem;">$BAG Air Hockey — Arcade P2E</h2>
  <p style="font-size:.95rem;opacity:.9;">All payouts in $BAG · $XRP bets convert automatically.</p>
</section>

<section style="padding:0 16px 80px;">
  <div class="panel">
    <div style="display:flex;justify-content:space-between;align-items:center;">
      <div id="sessionStatus" style="font-size:.9rem">Session: <span style="color:#2fbf6b">Practice</span></div>
      <button id="startSessionBtn" class="btn">Start Session</button>
    </div>
    <div class="divider"></div>

    <div class="marquee">Live Prices</div>
    <div style="text-align:center;font-family:monospace;">
      BAG $<span id="liveBAG">—</span> · XRP $<span id="liveXRP">—</span>
      <div id="liveConv" style="font-size:.85rem;opacity:.85;margin-top:4px;">1 BAG ≈ — XRP · 1 XRP ≈ — BAG</div>
    </div>

    <div class="divider"></div>
    <div style="text-align:center;line-height:1.6;">
      <div style="font-weight:800">Practice Balance</div>
      <div>BAG: <span id="balBAG">—</span> XRP: <span id="balXRP">—</span></div>
      <div>USD: <span id="balUSD">—</span></div>
    </div>

    <div class="divider"></div>
    <div class="marquee">$BAG AIR HOCKEY</div>
    <div id="gameContainer"></div>
  </div>
</section>

<footer style="text-align:center;padding:14px 0;font-size:.9rem;color:#b9c1b5;">
  © 2025 $BAG Protocol | getthebag.io | Powered by $XRP
</footer>

<!-- Live Prices -->
<script>
(function(){
 const BAG_ISSUER='rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr',BAG_CODE='BAG';
 window.P={bagUsd:0,xrpUsd:0};
 const fmt=n=>Number.isFinite(n)?n.toFixed(6):'—';
 async function refresh(){
  try{
   const r=await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
   const xrp=(await r.json())?.ripple?.usd||0;
   const ws=new WebSocket('wss://s1.ripple.com');
   const bagUsd=await new Promise(res=>{
    const req={id:1,command:'amm_info',asset:{currency:BAG_CODE,issuer:BAG_ISSUER},asset2:{currency:'XRP'}};
    ws.onopen=()=>ws.send(JSON.stringify(req));
    ws.onmessage=e=>{
     try{const d=JSON.parse(e.data);if(d.result?.amm){
      const a=+d.result.amm.amount.value,b=+d.result.amm.amount2.value;
      if(a>0&&b>0)res(b/a*xrp);ws.close();}}catch{}};
    setTimeout(()=>{try{ws.close();}catch{};res(null);},6000);
   });
   if(xrp>0&&bagUsd>0){P.xrpUsd=xrp;P.bagUsd=bagUsd;update();}
  }catch{}
 }
 function update(){
  document.getElementById('liveBAG').textContent=fmt(P.bagUsd);
  document.getElementById('liveXRP').textContent=fmt(P.xrpUsd);
  if(P.bagUsd&&P.xrpUsd){
   const xrpPerBag=P.bagUsd/P.xrpUsd,bagPerXrp=P.xrpUsd/P.bagUsd;
   document.getElementById('liveConv').textContent=`1 BAG ≈ ${xrpPerBag.toFixed(6)} XRP · 1 XRP ≈ ${bagPerXrp.toFixed(6)} BAG`;
  }
  document.dispatchEvent(new Event('bag:pricesUpdated'));
 }
 refresh();setInterval(refresh,15000);
})();
</script>

<!-- Practice Balance -->
<script>
(function(){
 const BAL_KEY='bag_demo_balance',USD_START=2000;
 function getBag(){return Number(localStorage.getItem(BAL_KEY)||0);}
 function setBag(v){localStorage.setItem(BAL_KEY,v);}
 function seed(){if(getBag()>0)return;const p=window.P?.bagUsd||0;if(p>0)setBag(USD_START/p);}
 function render(){
  const bal=getBag(),p=window.P;
  const usd=(p.bagUsd>0)?bal*p.bagUsd:USD_START;
  const xrp=(p.bagUsd>0&&p.xrpUsd>0)?bal*(p.bagUsd/p.xrpUsd):0;
  document.getElementById('balBAG').textContent=bal.toFixed(2);
  document.getElementById('balXRP').textContent=xrp.toFixed(2);
  document.getElementById('balUSD').textContent='$'+usd.toFixed(2);
 }
 document.getElementById('startSessionBtn').addEventListener('click',()=>{seed();render();});
 document.addEventListener('bag:pricesUpdated',render);
})();
</script>

<!-- Air Hockey Game (NO FREEZE GOALS) -->
<script>
const config = {
  type: Phaser.AUTO,
  scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: 1024, height: 1536, parent: 'gameContainer' },
  backgroundColor: '#021107',
  physics: { default: 'arcade', arcade: { debug: false, fps: 120, step: 1/240 } },
  input: { activePointers: 5 }
};

let puck, player, cpu, scoreText;
let scorePlayer = 0, scoreCPU = 0;
let prevPlayer = {x:0,y:0}, prevCPU = {x:0,y:0};
let goalLock = false; // guard while sinking/resetting

new Phaser.Game(Object.assign({}, config, { scene: { preload, create, update } }));

function preload(){
  this.load.image('table','/arcade/assets/img/airhockey-table-skin-1024.webp');
  this.load.image('puck','/arcade/assets/img/puck-1024.webp');
  this.load.image('paddle_gold','/arcade/assets/img/paddle_gold-1024.webp');
  this.load.image('paddle_green','/arcade/assets/img/paddle_green-1024.webp');
  try{
    this.load.audio('hit1','/arcade/assets/sounds/hit1.mp3');
    this.load.audio('goal','/arcade/assets/sounds/goal.mp3');
  }catch(e){}
}

function create(){
  const w=this.scale.width, h=this.scale.height, cx=w/2;

  this.add.image(cx, h/2, 'table').setDisplaySize(w, h);
  this.physics.world.setBounds(80, 80, w-160, h-160);

  // puck
  puck = this.physics.add.image(cx, h/2, 'puck').setScale(0.07);
  puck.setCollideWorldBounds(true).setBounce(0.995).setDamping(true).setDrag(0.995,0.995).setMaxVelocity(2000);
  puck.body.setCircle(puck.displayWidth/2); centerBodyOnTexture(puck);

  // paddles
  player = this.physics.add.image(cx, h*0.85, 'paddle_gold').setScale(0.14);
  cpu    = this.physics.add.image(cx, h*0.15, 'paddle_green').setScale(0.14);
  [player,cpu].forEach(p=>{
    p.setImmovable(true);
    p.setCollideWorldBounds(true);
    p.body.setCircle(p.displayWidth/2);
    centerBodyOnTexture(p);
  });

  // sfx
  this.sfx = {hit1:null,goal:null};
  try{
    this.sfx.hit1 = this.sound.add('hit1',{volume:.35});
    this.sfx.goal = this.sound.add('goal',{volume:.5});
  }catch(e){}

  // input
  const r = player.displayWidth*0.5;
  player.setInteractive(new Phaser.Geom.Circle(0,0,r), Phaser.Geom.Circle.Contains);
  this.input.setDraggable(player);
  this.input.on('drag',(ptr,obj,dx,dy)=>movePaddleTo({x:dx,y:dy},w,h));
  this.input.on('pointerdown',p=>{ if(p.y>=h*0.5) movePaddleTo(p,w,h); });
  this.input.on('pointermove',p=>{ if(p.isDown && p.y>=h*0.5) movePaddleTo(p,w,h); });

  scoreText = this.add.text(cx, 40, '0 - 0', {fontFamily:'Orbitron',fontSize:'48px',color:'#ffe175',stroke:'#2fbf6b',strokeThickness:3}).setOrigin(0.5,0);

  // first serve
  serve(this);
}

function centerBodyOnTexture(img){
  const bw=img.body.width, bh=img.body.height;
  img.body.setOffset(img.width/2-bw/2, img.height/2-bh/2);
}

function movePaddleTo(p,w,h){
  if(goalLock) return;
  player.x = Phaser.Math.Clamp(p.x,100,w-100);
  player.y = Phaser.Math.Clamp(p.y,h*0.5+40,h-80);
}

function resolvePaddle(paddle, prev, scene){
  if(goalLock || !puck.body || !puck.body.enable) return;
  const dx=puck.x-paddle.x, dy=puck.y-paddle.y, dist=Math.hypot(dx,dy)||0.0001;
  const rSum=puck.displayWidth/2+paddle.displayWidth/2;
  if(dist<rSum){
    const nx=dx/dist, ny=dy/dist, pen=rSum-dist;
    puck.x+=nx*pen; puck.y+=ny*pen;
    const pvx=(paddle.x-prev.x)*60, pvy=(paddle.y-prev.y)*60;
    const tx=-ny, ty=nx, vN=pvx*nx+pvy*ny, vT=pvx*tx+pvy*ty;
    const base=520, gainN=9, gainT=5, maxV=2000;
    const vx=nx*(base+gainN*Math.abs(vN)) + tx*(vT*gainT);
    const vy=ny*(base+gainN*Math.abs(vN)) + ty*(vT*gainT);
    puck.setVelocity(Phaser.Math.Clamp(vx,-maxV,maxV), Phaser.Math.Clamp(vy,-maxV,maxV));
    puck.setAngularVelocity(Phaser.Math.Clamp(vT*1.5,-450,450));
    try{ scene.sfx?.hit1?.play(); }catch{}
  }
}

function update(time,delta){
  const w=this.scale.width, h=this.scale.height;

  // EARLY goal check — exit the frame immediately when a goal starts
  const GOAL_HALF=130, cx=w/2;
  if(!goalLock && puck && puck.body && puck.body.enable){
    if(puck.y < 85 && Math.abs(puck.x-cx) < GOAL_HALF){
      try{ this.sfx?.goal?.play(); }catch{}
      scorePlayer++;
      startGoalSink.call(this, 'top');   // begins sink & schedules reset
      return; // <- do nothing else this frame
    }
    if(puck.y > h-85 && Math.abs(puck.x-cx) < GOAL_HALF){
      try{ this.sfx?.goal?.play(); }catch{}
      scoreCPU++;
      startGoalSink.call(this, 'bottom');
      return;
    }
  }

  if(goalLock) return; // while sinking/resetting

  // AI
  cpu.x += (puck.x - cpu.x) * 0.10;
  cpu.y += (puck.y - cpu.y) * 0.06;
  cpu.x  = Phaser.Math.Clamp(cpu.x,100,w-100);
  cpu.y  = Phaser.Math.Clamp(cpu.y,80,h*0.45);

  // collisions
  const curPlayer={x:player.x,y:player.y};
  const curCPU={x:cpu.x,y:cpu.y};
  resolvePaddle(player, prevPlayer, this);
  resolvePaddle(cpu,    prevCPU,  this);
  prevPlayer = curPlayer; prevCPU = curCPU;

  // velocity clamp
  if(puck.body && puck.body.enable){
    const v=puck.body.velocity, vmax=2000, keep=0.999;
    v.x = Phaser.Math.Clamp(v.x*keep,-vmax,vmax);
    v.y = Phaser.Math.Clamp(v.y*keep,-vmax,vmax);
  }

  scoreText.setText(`${scorePlayer} - ${scoreCPU}`);
}

// SINK: disable physics, let puck visually slide into slot, then re-enable & serve
function startGoalSink(side){
  if(goalLock || !puck) return;
  const scene=this, w=scene.scale.width, h=scene.scale.height, cx=w/2;
  goalLock = true;

  // stop interacting with physics/world bounds during sink
  puck.setVelocity(0,0);
  puck.setAngularVelocity(0);
  if(puck.body){ puck.body.checkCollision.none = true; puck.body.enable = false; }
  puck.setCollideWorldBounds(false);

  // target y inside “machine”
  const targetY = (side==='top') ? -40 : (h+40);

  // tween visual sink (scale/fade + slide to center of slot)
  scene.tweens.add({
    targets: puck,
    x: cx,
    y: targetY,
    scaleX: puck.scaleX*0.55,
    scaleY: puck.scaleY*0.55,
    alpha: 0,
    duration: 230,
    ease: 'Quad.easeIn',
    onComplete: ()=>{
      // reset to center and re-enable physics cleanly
      serve(scene, side==='top' ? 'player' : 'cpu');
      goalLock = false;
    }
  });
}

function serve(scene, scoredBy){
  const w=scene.scale.width, h=scene.scale.height;
  // restore puck visuals
  puck.setPosition(w/2, h/2).setAlpha(1).setScale(0.07);
  // re-enable physics body
  if(!puck.body){ scene.physics.add.existing(puck); } // safety if body was stripped
  puck.body.enable = true;
  puck.body.checkCollision.none = false;
  puck.setCollideWorldBounds(true);

  const angle=Phaser.Math.Between(20,160)*(Phaser.Math.Between(0,1)?1:-1);
  const speed=Phaser.Math.Between(650,800);
  const vx=Math.cos(angle*Math.PI/180)*speed;
  const vy=(scoredBy==='player'?-1:1)*Math.abs(Math.sin(angle*Math.PI/180)*speed);
  puck.setVelocity(vx,vy);
  puck.setAngularVelocity(Phaser.Math.Between(-120,120));

  // UI
  scoreText.setText(`${scorePlayer} - ${scoreCPU}`);
}

</script>
</body>
</html>
