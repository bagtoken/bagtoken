<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>$BAG Air Hockey ‚Äî Arcade P2E</title>

<link rel="preconnect" href="https://api.coingecko.com" crossorigin>
<script src="https://cdn.jsdelivr.net/npm/phaser@3.70.0/dist/phaser.min.js"></script>
<script src="https://xaman.app/assets/cdn/xumm.min.js"></script>

<!-- Preload SFX -->
<link rel="preload" href="/arcade/assets/sounds/air-hockey-hit.mp3" as="audio">
<link rel="preload" href="/arcade/assets/sounds/air-hockey-goal.mp3" as="audio">

<!-- Shared UI -->
<script src="/js/bag-overlay.js"></script>
<script src="/js/bag-session.js"></script>
<script src="/js/bag-quick-amounts.js"></script>

<style>
:root{
  --gold:#ffe175;--bg:#020703;--panel:#0b1b13;--panel2:#0d2217;--muted:#aeb7af;--fg:#f5f7f4;
  --green:#2fbf6b;--green-600:#249a55;--line:#173524;--shadow:rgba(0,0,0,.35);
  --vh:100vh;
}
html,body{
  margin:0;padding:0;background:var(--bg);color:var(--fg);
  font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
  line-height:1.5;overflow-x:hidden;overscroll-behavior:none;
  -webkit-tap-highlight-color:transparent;touch-action:pan-y;user-select:none;-webkit-user-select:none
}
.panel{background:linear-gradient(180deg,var(--panel),var(--panel2));border:1px solid var(--line);
  border-radius:16px;box-shadow:0 8px 24px var(--shadow);padding:16px;margin:0 auto;max-width:1080px}
.btn{cursor:pointer;border:0;border-radius:12px;padding:12px 16px;font-weight:900;
  background:linear-gradient(180deg,#ffe175,#f5c94c);color:#08130d;box-shadow:0 4px 0 #b08a19;text-decoration:none}
.btn:active{transform:translateY(1px);box-shadow:0 3px 0 #9a7315}
.divider{height:1px;background:#123221;margin:14px 0}
.marquee{text-align:center;font-weight:900;letter-spacing:.08em;color:#ffe9a6;background:linear-gradient(180deg,#17311f,#0e2419);border:1px solid #254a33;border-radius:12px;padding:8px;margin:10px 0}
a.back{position:fixed;top:18px;left:18px;z-index:1100;text-decoration:none}
a.back:hover,a.back:focus,a.back:active{text-decoration:none}
img{display:block;max-width:100%;height:auto}
canvas{display:block;margin:auto;touch-action:none}

/* Keep match HUD visible; game area fits remaining viewport height */
.game-stick{
  position:relative; max-width:1080px; margin:0 auto; border-radius:16px; overflow:hidden;
  height:clamp(420px, min(calc(var(--vh) - 240px), 78vh), 920px);
  background:#021107;
}
@media (max-width:480px){
  .game-stick{ height:clamp(420px, min(calc(var(--vh) - 260px), 74vh), 800px); }
}

#gameContainer{width:100%;height:100%;border-radius:12px;overflow:hidden}

/* Hero */
.hero-wrap{padding:68px 12px 6px}
.hero-img{margin:0 auto 8px;width:100%;max-width:960px;filter:drop-shadow(0 10px 24px rgba(46,191,107,.18))}
@media (min-width:900px){ .hero-img{max-width:720px}}

/* Stake/HUD */
.stack{display:grid;gap:10px}
.choice{display:flex;gap:10px;flex-wrap:wrap}
.chip{display:inline-flex;align-items:center;gap:8px;padding:8px 12px;border-radius:999px;border:1px solid #2b6a48;background:#0e2a1c;color:#e9efe9;font-weight:800}
.chip input{accent-color:#2fbf6b}
.mono{font-variant-numeric:tabular-nums}
.micro{font-size:.85rem;color:#aeb7af}
.preset-chips{display:flex;gap:12px;flex-wrap:wrap;margin-top:8px}
.preset-chip{
  appearance:none;border:1px solid var(--green-600);background:var(--green);color:#fff;border-radius:999px;
  padding:14px 18px;font-size:1.02rem;font-weight:900;cursor:pointer
}
.preset-chip.active{box-shadow:0 0 0 2px rgba(255,255,255,.25) inset,0 8px 22px rgba(47,191,107,.25)}
.hudbar{display:grid;grid-template-columns:repeat(auto-fit,minmax(140px,1fr));gap:6px;align-items:center;margin:6px 2px 0}
.pill{background:#0a1e15;border:1px solid #244330;border-radius:999px;padding:6px 10px;font-size:12px;color:#cfe6d8}
.pill b{font-weight:800}
.pill.balance{grid-column:1/-1;font-size:14px;padding:8px 12px;font-weight:800}
.ok{color:#2fbf6b}.warn{color:#e8a85c}.err{color:#e25b5b}

/* Top match HUD (fat, obvious selectors) */
.top-hud{position:sticky;top:0;z-index:1050;display:flex;justify-content:space-between;align-items:center;gap:8px;
  padding:10px 10px;margin:8px 0;border:1px solid #224631;background:linear-gradient(180deg,#10331f,#0b2418);border-radius:12px;flex-wrap:wrap}
.top-hud .side{display:flex;align-items:center;gap:8px;font-weight:800}
.badge{display:inline-flex;align-items:center;gap:8px;border:1px solid #2b6a48;background:#0e2a1c;color:#e9efe9;border-radius:12px;padding:8px 12px;font-weight:800}
.small{font-size:.95rem}
.arrow{font-size:14px}
.select-big{
  appearance:none;background:#0b2217;border:2px solid #37c777;color:#f5fff7;border-radius:12px;
  padding:10px 12px;font-weight:900;letter-spacing:.02em
}
.rule-pill{position:fixed;right:12px;bottom:12px;z-index:1200}
.start-overlay{
  position:absolute;inset:0;background:linear-gradient(180deg,rgba(2,17,7,.92),rgba(2,17,7,.92));display:flex;flex-direction:column;align-items:center;justify-content:center;gap:16px;z-index:1000
}
.start-overlay h3{margin:0;font-size:1.2rem}
.highlight{box-shadow:0 0 0 3px rgba(55,199,119,.35)}
</style>
</head>
<body>

<a href="/arcade/index.html" class="btn back" aria-label="Back to Arcade">Back</a>

<!-- HERO -->
<section class="hero-wrap" aria-label="$BAG Air Hockey">
  <picture>
    <source type="image/webp"
            srcset="/arcade/assets/img/bag-airhockey-960.webp 960w, /arcade/assets/img/bag-airhockey-1024.webp 1024w"
            sizes="100vw">
    <img class="hero-img"
         src="/arcade/assets/img/bag-airhockey-1024.png"
         srcset="/arcade/assets/img/bag-airhockey-960.png 960w, /arcade/assets/img/bag-airhockey-1024.png 1024w"
         sizes="100vw" width="1024" height="576" alt="$BAG Air Hockey ‚Äî hero">
  </picture>
</section>

<!-- HEADER -->
<section style="text-align:center;padding:0 12px 10px">
  <h2 style="margin:0;font-size:1.6rem;">üéØ $BAG Air Hockey ‚Äî Head-to-Head</h2>
  <p style="font-size:.95rem;opacity:.9;margin:.4rem 0 0">Pick your format. Place your stake. Start the fight.</p>
</section>

<!-- CONTROL + PRICES + SESSION -->
<section style="padding:0 16px 20px;">
  <div class="panel">
    <div style="display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap">
      <div id="sessionStatus" style="font-size:.9rem">Session: <span id="sessionModeLbl" style="color:#2fb6a9">Demo</span></div>
      <div style="display:flex;gap:8px;flex-wrap:wrap">
        <button id="toggleDemoBtn" class="btn" title="Toggle Demo/Live">Demo Mode</button>
        <button id="startSessionBtn" class="btn">Start Session</button>
        <button id="endSessionBtn" class="btn" style="display:none">End</button>
      </div>
    </div>

    <div class="divider"></div>

    <!-- Stake -->
    <div class="stack">
      <div>
        <div class="micro">Amount</div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
          <div>
            <input id="usdBet" class="mono" type="number" inputmode="decimal" min="0" max="2000" step="0.01" placeholder="0.00"
                   style="width:160px;background:#0b2217;border:1px solid #1b4a2f;border-radius:10px;color:#f3f5f0;padding:12px">
            <span class="micro unit">USD</span>
          </div>
        </div>
        <div class="preset-chips" id="usdPresets" data-quick-amounts data-target-usd="#usdBet" data-target-qty="#betQty"
             data-currency-toggle="#curToggle" data-min-usd="1" data-max-usd="2000" data-active-class="active" data-sync-on-price="1">
          <button type="button" class="preset-chip" data-usd="1">$1</button>
          <button type="button" class="preset-chip" data-usd="2">$2</button>
          <button type="button" class="preset-chip" data-usd="5">$5</button>
          <button type="button" class="preset-chip" data-usd="10">$10</button>
          <button type="button" class="preset-chip" data-usd="20">$20</button>
          <button type="button" class="preset-chip" data-usd="50">$50</button>
          <button type="button" class="preset-chip" data-usd="100">$100</button>
          <button type="button" class="preset-chip" data-usd="max">Max</button>
        </div>
      </div>

      <div>
        <div class="micro">Bet currency</div>
        <div class="choice" id="curToggle">
          <label class="chip"><input type="radio" name="betCur" value="XRP" checked> XRP</label>
          <label class="chip"><input type="radio" name="betCur" value="BAG"> BAG</label>
        </div>
      </div>

      <div>
        <div class="micro">Bet amount</div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center">
          <div>
            <!-- default 1 XRP -->
            <input id="betQty" class="mono" type="number" inputmode="decimal" min="0" step="any" value="1"
                   style="width:160px;background:#0b2217;border:1px solid #1b4a2f;border-radius:10px;color:#f3f5f0;padding:12px">
            <span class="unit">XRP</span>
          </div>
          <button id="challengeBtn" class="btn">Issue Challenge</button>
        </div>
        <div class="micro" id="betLimits" style="margin-top:6px"></div>
      </div>
    </div>

    <div class="divider"></div>

    <!-- Live Prices -->
    <div class="marquee">Live Prices</div>
    <div style="text-align:center;font-family:monospace;">
      <span id="liveDot" class="warn">‚óè</span>
      BAG $<span id="liveBAG">‚Äî</span> ¬∑ XRP $<span id="liveXRP">‚Äî</span><span id="liveNote"></span>
      <div id="liveConv" style="font-size:.85rem;opacity:.85;margin-top:4px;">1 BAG ‚âà ‚Äî XRP ¬∑ 1 XRP ‚âà ‚Äî BAG</div>
    </div>
  </div>
</section>

<!-- GAME PANEL -->
<section style="padding:0 16px 80px;">
  <div class="panel">
    <div class="marquee">$BAG AIR HOCKEY</div>

    <!-- Top Match HUD -->
    <div class="top-hud" id="topHud">
      <div class="side">Player <span id="servePlayer" class="arrow" title="Serve">‚¨Ö</span></div>

      <div class="badge highlight">
        Series
        <select id="seriesBest" class="select-big" title="Best-of">
          <option value="3">Best of 3</option>
          <option value="5" selected>Best of 5</option>
          <option value="7">Best of 7</option>
        </select>
        <span id="seriesScore" class="mono small" style="margin-left:6px">0‚Äì0</span>
      </div>

      <div class="badge highlight">
        Target
        <select id="targetGoals" class="select-big" title="First to">
          <option value="5">First to 5</option>
          <option value="7" selected>First to 7</option>
          <option value="9">First to 9</option>
        </select>
      </div>

      <div class="badge" title="Game Clock">‚è± <span id="clock" class="mono" style="margin-left:6px">3:00</span></div>
      <div class="badge small" title="OT">OT: <b style="margin-left:6px">Sudden Death</b></div>

      <div class="side">CPU <span id="serveCPU" class="arrow" title="Serve" style="opacity:.25">‚¨Ö</span></div>
    </div>

    <!-- Sticky, viewport-fitted game area -->
    <div class="game-stick">
      <div id="gameContainer"></div>
      <!-- Start gate overlay -->
      <div id="startGate" class="start-overlay">
        <h3>Select Series + Target, then Start</h3>
        <button id="gateStartBtn" class="btn">Start Game</button>
      </div>
    </div>

    <div class="divider"></div>

    <!-- HUD pills -->
    <div class="hudbar" id="ahHud" aria-live="polite">
      <span class="pill balance">Balance: <b id="balLbl">‚Äî</b> <span id="ccyLbl">BAG</span></span>
      <span class="pill">Mode: <b id="modeLbl">Demo</b></span>
      <span class="pill">Bet: <b id="betLbl">1</b></span>
      <span class="pill">Last: <b id="lastLbl">‚Äî</b></span>
      <button id="rulesBtn" class="btn rule-pill">‚ÑπÔ∏è Rules</button>
    </div>
  </div>
</section>

<footer style="text-align:center;padding:14px 0;font-size:.9rem;color:#b9c1b5;">
  ¬© 2025 $BAG Protocol | getthebag.io | Powered by $XRP
</footer>

<!-- ===== RULES ===== -->
<script>
window.__AH_RULES__ = {
  series: { options:[3,5,7], default:5 },
  targetGoals: { options:[5,7,9], default:7 },
  gameClockSec: 180,
  suddenDeathOT: true,
  overtimeCapSec: 60,
  mercyLead: 5,
  serve: { first:'player', alternateByGame:true, dropCountdownMs:900 },
  antiStall: { trapMs:2000 }
};
</script>

<!-- ===== MOBILE VH FIX ===== -->
<script>
(function(){
  function setVH(){ const vh = window.innerHeight * 0.01; document.documentElement.style.setProperty('--vh', `${vh*100}px`); }
  setVH(); addEventListener('resize', setVH); addEventListener('orientationchange', setVH);
})();
</script>

<!-- ===== LIVE PRICING (AMM + cache) ===== -->
<script>
(function(){
  const PRICE_REFRESH_MS=15000, FETCH_TIMEOUT_MS=8000, LIVE_CACHE_TTL_MS=86400000, VIEW_CACHE_TTL_MS=21600000;
  const BAG_ISSUER='rNeYbfb9EDV8c7mNfUuooEEYYzMcEuDFbr', BAG_CODE='BAG';
  const VIEW_CACHE_KEY='bag_prices_v8', LAST_LIVE_KEY='bag_last_live_v1', XRP_KEY='xrp_usd';
  const PRICES=(window.__PRICES__={bagUsd:0,xrpUsd:0,source:'‚Äî',ts:0});
  const fmt=n=>Number.isFinite(n)? n.toFixed(6):'‚Äî';
  const cacheSet=(k,v)=>{ try{ localStorage.setItem(k, JSON.stringify({t:Date.now(), v})); }catch{} };
  const cacheGet=(k,ttl)=>{ try{ const o=JSON.parse(localStorage.getItem(k)||'null'); if(!o) return null; return (Date.now()-(o.t||0))<=ttl?o.v:null; }catch{ return null; } };
  function timedFetch(url,opts={},timeout=FETCH_TIMEOUT_MS){
    const ctrl=new AbortController(); const id=setTimeout(()=>ctrl.abort(new Error('timeout')),timeout);
    try{ return fetch(url,{...opts,headers:{Accept:'application/json',...(opts.headers||{})},mode:'cors',cache:'no-store',credentials:'omit',referrerPolicy:'no-referrer',signal:ctrl.signal}); }
    finally{ setTimeout(()=>clearTimeout(id),0); }
  }
  function paint(){
    const d=document; d.getElementById('liveBAG').textContent=fmt(PRICES.bagUsd);
    d.getElementById('liveXRP').textContent=Number.isFinite(PRICES.xrpUsd)? PRICES.xrpUsd.toFixed(2):'‚Äî';
    const dot=d.getElementById('liveDot'), note=d.getElementById('liveNote');
    if(dot) dot.className=(PRICES.source==='live-amm'?'ok':PRICES.source==='last-live'?'warn':'err');
    if(note) note.textContent=(PRICES.source==='live-amm'?' (AMM live)':' (last live)');
    if(PRICES.bagUsd>0 && PRICES.xrpUsd>0){
      const xrpPerBag=PRICES.bagUsd/PRICES.xrpUsd, bagPerXrp=PRICES.xrpUsd/PRICES.bagUsd;
      d.getElementById('liveConv').textContent=`1 BAG ‚âà ${xrpPerBag.toFixed(6)} XRP ¬∑ 1 XRP ‚âà ${bagPerXrp.toFixed(6)} BAG`;
    }
    document.dispatchEvent(new Event('bag:pricesUpdated'));
  }
  async function fetchXrpUsd(){
    try{
      const r=await timedFetch('https://api.coingecko.com/api/v3/simple/price?ids=ripple&vs_currencies=usd');
      const v=(await r.json())?.ripple?.usd; if(Number(v)>0){ PRICES.xrpUsd=+v; cacheSet(XRP_KEY,PRICES.xrpUsd); return true; }
    }catch{} return false;
  }
  const parseXRP=a=> (typeof a==='string')? Number(a)/1_000_000 : (a&&a.currency==='XRP'? Number(a.value):null);
  const parseIOU=a=> (a&&typeof a==='object')? Number(a.value):null;
  async function fetchBAGViaAMM(){
    const req={id:1,command:'amm_info',asset:{currency:BAG_CODE,issuer:BAG_ISSUER},asset2:{currency:'XRP'}};
    const price=await new Promise(resolve=>{
      let ws; const t=setTimeout(()=>{ try{ws&&ws.close();}catch{} resolve(null); },8000);
      try{
        ws=new WebSocket('wss://s1.ripple.com');
        ws.onopen=()=>ws.send(JSON.stringify(req));
        ws.onerror=()=>{ clearTimeout(t); try{ws.close();}catch{} resolve(null); };
        ws.onmessage=e=>{
          try{
            const m=JSON.parse(e.data); if(m.id!==1||!m.result||!m.result.amm) return;
            clearTimeout(t); try{ws.close();}catch{};
            const amm=m.result.amm; const bag=parseIOU(amm.amount), xrp=parseXRP(amm.amount2);
            if(!(bag>0)&&!(xrp>0)) return resolve(null);
            const px=xrp/bag; resolve(isFinite(px)&&px>0?px:null);
          }catch{ resolve(null); }
        };
      }catch{ clearTimeout(t); resolve(null); }
    });
    if(!(price>0)) return false;
    if(!(PRICES.xrpUsd>0)) return false;
    PRICES.bagUsd=PRICES.xrpUsd*price; PRICES.source='live-amm';
    cacheSet(LAST_LIVE_KEY,{bagUsd:PRICES.bagUsd,xrpUsd:PRICES.xrpUsd});
    cacheSet(VIEW_CACHE_KEY,{bagUsd:PRICES.bagUsd,xrpUsd:PRICES.xrpUsd});
    return true;
  }
  function loadLast(){ const v=cacheGet(LAST_LIVE_KEY,LIVE_CACHE_TTL_MS); if(v && Number(v.bagUsd)>0){ PRICES.bagUsd=+v.bagUsd; if(Number(v.xrpUsd)>0) PRICES.xrpUsd=+v.xrpUsd; PRICES.source='last-live'; return true; } return false; }
  function loadView(){ const v=cacheGet(VIEW_CACHE_KEY,VIIEW_CACHE_TTL_MS=21600000); return v } // placeholder prevention
})();
</script>

<!-- ===== Stake Wire ===== -->
<script>
(function(global){
  const PR=()=>global.__PRICES__||{bagUsd:0,xrpUsd:0};
  const getCur=root=>{ const el=root?.querySelector('input[name="betCur"]:checked'); return el? String(el.value).toUpperCase():'XRP'; };
  const priceFor=cur=>{ const {bagUsd,xrpUsd}=PR(); return cur==='BAG'? bagUsd:xrpUsd; };
  const fmtUsd=n=>'$'+(Number(n)||0).toLocaleString(undefined,{minimumFractionDigits:2,maximumFractionDigits:2});
  function computeSessionMaxUsd(cur,minUsd,maxUsd){
    const sess=(global.__bagSession&&global.__bagSession.get&&global.__bagSession.get())||{};
    const bagBal=Number(sess.bag)||0; let unitsAvail;
    if(cur==='BAG'){ unitsAvail=bagBal; } else { const {bagUsd,xrpUsd}=PR(); unitsAvail=(bagUsd>0&&xrpUsd>0)? (bagBal*(bagUsd/xrpUsd)):0; }
    const px=priceFor(cur); const usdAvail=(px>0&&unitsAvail>0)? unitsAvail*px : maxUsd;
    return Math.max(minUsd, Math.min(maxUsd, usdAvail));
  }
  function init(opts){
    const cfg=Object.assign({usdInput:'#usdBet', qtyInput:'#betQty', currencyToggle:'#curToggle', unitLabels:'.unit', limitsLabel:'#betLimits',
      presetsRoot:'#usdPresets', minUsd:1, maxUsd:2000, activeClass:'active', syncOnPrice:true}, opts||{});
    const usdEl=document.querySelector(cfg.usdInput), qtyEl=document.querySelector(cfg.qtyInput), curToggle=document.querySelector(cfg.currencyToggle),
          unitEls=document.querySelectorAll(cfg.unitLabels), limitsEl=document.querySelector(cfg.limitsLabel), presets=document.querySelector(cfg.presetsRoot);
    const STATE={lastEdited:'qty', lastCur:null, syncing:false};
    const rUsd=()=>{ const v=parseFloat(usdEl?.value||''); return Number.isFinite(v)&&v>0?v:0; };
    const rQty=()=>{ const v=parseFloat(qtyEl?.value||''); return Number.isFinite(v)&&v>0?v:0; };
    const wUsd=u=>{ if(!usdEl)return; usdEl.value = u? (Math.round(u*100)/100).toFixed(2):''; };
    const wQty=q=>{ if(!qtyEl)return; const d=6; qtyEl.value = q? Number(q).toFixed(Math.min(6,d)).replace(/\.?0+$/,''):''; };
    const paintUnits=()=>{ const cur=getCur(curToggle); unitEls.forEach(s=>s.textContent=cur); };
    const renderLimits=()=>{ if(!limitsEl) return; const cur=getCur(curToggle), px=priceFor(cur), u=rUsd()||(rQty()*(px>0?px:0))||0;
      const warn=(u>0&&u<cfg.minUsd)?` ¬∑ <span style="color:#e8a85c">Min ${fmtUsd(cfg.minUsd)}</span>`:(u>cfg.maxUsd)?` ¬∑ <span style="color:#e8a85c">Max ${fmtUsd(cfg.maxUsd)}</span>`:''; 
      limitsEl.innerHTML=`Limits: ${fmtUsd(cfg.minUsd)}‚Äì${fmtUsd(cfg.maxUsd)} ¬∑ Your stake ‚âà ${fmtUsd(u||0)}${warn}`; };
    function syncFromUSD(){ if(STATE.syncing) return; STATE.syncing=true; const cur=getCur(curToggle), px=priceFor(cur), usd=rUsd();
      if(usd && px>0) wQty(usd/px); else if(!usd) wQty(''); renderLimits(); STATE.syncing=false; }
    function syncFromQty(){ if(STATE.syncing) return; STATE.syncing=true; const cur=getCur(curToggle), px=priceFor(cur), qty=rQty();
      if(qty && px>0) wUsd(qty*px); else if(!qty) wUsd(''); renderLimits(); STATE.syncing=false; }
    function convert(prev,next){ const pxPrev=priceFor(prev), pxNext=priceFor(next); let usd=rUsd(); const qPrev=rQty();
      if(!(usd>0)) usd=(qPrev>0&&pxPrev>0)? qPrev*pxPrev:0; if(usd>0&&pxNext>0){ wUsd(usd); wQty(usd/pxNext); } renderLimits(); }
    usdEl?.addEventListener('input', ()=>{ STATE.lastEdited='usd'; syncFromUSD(); window.dispatchEvent(new Event('bag:hudRefresh')); });
    qtyEl?.addEventListener('input', ()=>{ STATE.lastEdited='qty'; syncFromQty(); window.dispatchEvent(new Event('bag:hudRefresh')); });
    STATE.lastCur=getCur(curToggle);
    curToggle?.addEventListener('change', ()=>{ const prev=STATE.lastCur, next=getCur(curToggle); STATE.lastCur=next; paintUnits(); convert(prev,next); window.dispatchEvent(new Event('bag:hudRefresh')); });
    if(cfg.syncOnPrice){ addEventListener('bag:pricesUpdated', ()=>{ if(STATE.lastEdited==='usd') syncFromUSD(); else syncFromQty(); }); }
    if(presets){
      const setActive=btn=>{ presets.querySelectorAll('.preset-chip').forEach(b=>b.classList.remove(cfg.activeClass)); btn&&btn.classList.add(cfg.activeClass); };
      const applyUsd=usd=>{ wUsd(usd); STATE.lastEdited='usd'; syncFromUSD(); window.dispatchEvent(new Event('bag:hudRefresh')); };
      const clamp=u=>Math.max(cfg.minUsd, Math.min(cfg.maxUsd, u||0));
      presets.querySelectorAll('button[data-usd]').forEach(btn=>{
        btn.addEventListener('click', ()=>{ const v=btn.getAttribute('data-usd'); let usd=0;
          usd = (v==='max') ? computeSessionMaxUsd(getCur(curToggle), cfg.minUsd, cfg.maxUsd) : (parseFloat(v)||0);
          usd=clamp(usd); setActive(btn); applyUsd(usd);
        });
      });
      const resync=()=>{ const btn=presets.querySelector('.'+cfg.activeClass); if(!btn) return; const v=btn.getAttribute('data-usd');
        if(v==='max'){ applyUsd(computeSessionMaxUsd(getCur(curToggle), cfg.minUsd, cfg.maxUsd)); } else { applyUsd(parseFloat(v)||0); } };
      addEventListener('bag:pricesUpdated', resync); curToggle?.addEventListener('change', resync);
    }
    paintUnits();
    /* FORCE DEFAULTS: 1 XRP */
    try{
      document.querySelector('input[name="betCur"][value="XRP"]').checked = true;
      document.getElementById('betQty').value = '1';
      window.dispatchEvent(new Event('bag:hudRefresh'));
    }catch{}
    if(rUsd()>0){ STATE.lastEdited='usd'; syncFromUSD(); } else { STATE.lastEdited='qty'; syncFromQty(); } renderLimits();
  }
  global.BAGStakeWire={ init };
})(window);

// HUD wire-up + session/demo + challenge
document.addEventListener('DOMContentLoaded', ()=>{
  try{ window.BAGStakeWire.init(); }catch{}
  const betQty=document.getElementById('betQty');
  const modeLbl=document.getElementById('modeLbl');
  const betLbl=document.getElementById('betLbl');
  const ccyLbl=document.getElementById('ccyLbl');
  const lastLbl=document.getElementById('lastLbl');
  const sessionModeLbl=document.getElementById('sessionModeLbl');
  const toggleDemoBtn=document.getElementById('toggleDemoBtn');
  let DEMO=true;

  const paintHUD=()=>{
    betLbl.textContent = betQty.value || '1';
    const cur=document.querySelector('input[name="betCur"]:checked')?.value||'XRP';
    document.querySelectorAll('.unit').forEach(n=>n.textContent=cur);
    ccyLbl.textContent = cur;
    modeLbl.textContent = DEMO?'Demo':'Live';
    sessionModeLbl.textContent = DEMO?'Demo':'Live';
    sessionModeLbl.style.color = DEMO ? '#2fb6a9' : '#ffe175';
    lastLbl.textContent = window.__AH_LAST__ || '‚Äî';
  };
  paintHUD();
  document.addEventListener('bag:hudRefresh', paintHUD);

  toggleDemoBtn.addEventListener('click', ()=>{
    DEMO=!DEMO;
    toggleDemoBtn.textContent = DEMO ? 'Demo Mode' : 'Live Mode';
    window.__BAG_FORCE_DEMO = DEMO;
    paintHUD();
  });

  document.getElementById('challengeBtn').addEventListener('click', ()=>{
    const cur=document.querySelector('input[name="betCur"]:checked')?.value||'XRP';
    const qty=parseFloat(document.getElementById('betQty').value||'0')||1;
    const best=parseInt(document.getElementById('seriesBest').value,10);
    const goals=parseInt(document.getElementById('targetGoals').value,10);
    const slip={ game:'Air Hockey', best, goals, cur, qty, demo:DEMO };
    window.dispatchEvent(new CustomEvent('bag:challenge', { detail: slip })); // hook for The Cage / matchmaker
    document.getElementById('challengeBtn').textContent='Challenge Sent';
    setTimeout(()=>document.getElementById('challengeBtn').textContent='Issue Challenge',1200);
  });

  document.getElementById('rulesBtn').addEventListener('click', ()=>{
    const copy = `Air Hockey Rules ‚Äî Best-of-3/5/7. Each game is first to ${document.getElementById('targetGoals').value} or 3:00 on the clock. If time expires, sudden-death. Mercy at +${window.__AH_RULES__.mercyLead}. Serve alternates each game; after goals, conceding side serves after a 3-2-1 drop. Own goals count. No trapping > 2s ‚Äî whistle + center drop. Puck out ‚Üí center drop.`;
    window.dispatchEvent(new CustomEvent('bag:rules', { detail: { title:'Air Hockey Rules', body:copy } }));
    alert(copy); // quick fallback
  });
});
</script>

<!-- ===== Air Hockey Game + Series Controller ===== -->
<script>
/* ------- Phaser config ------- */
const config = {
  type: Phaser.AUTO,
  scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH, width: 1024, height: 1536, parent: 'gameContainer' },
  backgroundColor: '#021107',
  physics: { default: 'arcade', arcade: { debug: false, fps: 120, step: 1/240 } },
  input: { activePointers: 5 }
};

/* ------- Tuning ------- */
const PADDLE_SCALE = 0.20;
const PUCK_SCALE   = 0.09;
const GOAL_HALF    = 140;
const POINTER_OFFSET_Y = -56;
const WALL_MARGIN  = 100;

const CORNER_BAND     = 150;
const STUCK_SPEED     = 60;
const STUCK_TIME_MS   = 600;
const STUCK_COOLDOWN  = 800;
const CPU_RETREAT_Y   = 280;

/* ------- State ------- */
let puck, player, cpu, scoreText, ring, lowerZone;
let goalTop, goalBottom;
let scorePlayer = 0, scoreCPU = 0;
let prevPlayer = {x:0,y:0}, prevCPU = {x:0,y:0};
let goalLock = false;

let series = { best:5, need:3, p:0, c:0, gameIndex:1, nextServe:'player' };
let clock = { total:180000, remain:180000, running:false, sudden:false, otCap:60000, otStart:0 };
let dropText = null;

let gameArmed = false; // start gate

// TOUCH GLIDE STATE
let touchActive=false, touchId=null;
let playerTarget={x:0,y:0};

// stuck tracking
let stuckStart = 0;
let lastKickAt = 0;

// sfx throttle
let lastHitAt = 0;

/* ------- WebAudio helper (countdown + buzzer) ------- */
const AudioFX = {
  ctx:null,
  init(scene){ try{ this.ctx = scene.sound.context; }catch{} },
  beep(freq=800, ms=140, vol=0.07){
    if(!this.ctx) return;
    const o=this.ctx.createOscillator(), g=this.ctx.createGain();
    o.type='square'; o.frequency.value=freq;
    g.gain.value=0; o.connect(g); g.connect(this.ctx.destination);
    const t=this.ctx.currentTime;
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(vol,t+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, t + ms/1000);
    o.start(t); o.stop(t + ms/1000 + 0.02);
  },
  buzzer(ms=900, vol=0.08){
    if(!this.ctx) return;
    const o=this.ctx.createOscillator(), n=this.ctx.createOscillator(), g=this.ctx.createGain();
    o.type='sawtooth'; n.type='square';
    o.frequency.value=120; n.frequency.value=60;
    g.gain.value=0; o.connect(g); n.connect(g); g.connect(this.ctx.destination);
    const t=this.ctx.currentTime;
    g.gain.setValueAtTime(0,t);
    g.gain.linearRampToValueAtTime(vol,t+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t + ms/1000);
    o.start(t); n.start(t); o.stop(t + ms/1000 + 0.05); n.stop(t + ms/1000 + 0.05);
  }
};

new Phaser.Game(Object.assign({}, config, { scene: { preload, create, update } }));

/* ------- Helpers ------- */
function mmss(ms){ ms=Math.max(0,ms|0); const s=(ms/1000)|0; const m=(s/60)|0; const r=(s%60)|0; return `${m}:${r<10?'0':''}${r}`; }
function lerp(a,b,t){ return a+(b-a)*t; }

/* ------- Scene ------- */
function preload(){
  this.load.image('table','/arcade/assets/img/airhockey-table-skin-1024.webp');
  this.load.image('puck','/arcade/assets/img/puck-1024.webp');
  this.load.image('paddle_gold','/arcade/assets/img/paddle_gold-1024.webp');
  this.load.image('paddle_green','/arcade/assets/img/paddle_green-1024.webp');

  this.load.audio('hit','/arcade/assets/sounds/air-hockey-hit.mp3');
  this.load.audio('goal','/arcade/assets/sounds/air-hockey-goal.mp3');
}

function create(){
  this.sound.pauseOnBlur = false;
  const unlockAudio = ()=>{
    try{ if (this.sound.locked) this.sound.unlock(); }catch{}
    try{ this.sound.context && this.sound.context.resume && this.sound.context.resume(); }catch{}
    this.input.off('pointerdown', unlockAudio);
  };
  this.input.on('pointerdown', unlockAudio);

  AudioFX.init(this);

  const w=this.scale.width, h=this.scale.height, cx=w/2;

  // selections bind (bugfix: no nonexistent element writes)
  const bestSel=document.getElementById('seriesBest');
  const goalsSel=document.getElementById('targetGoals');
  series.best = parseInt(bestSel.value,10) || window.__AH_RULES__.series.default;
  series.need = (series.best>>1)+1;
  clock.total = (window.__AH_RULES__.gameClockSec||180)*1000;

  bestSel.addEventListener('change', ()=>{
    series.best = parseInt(bestSel.value,10);
    series.need = (series.best>>1)+1;
    paintTopHud();
  });
  goalsSel.addEventListener('change', ()=>{ /* paint happens automatically */ });

  // table
  this.add.image(cx, h/2, 'table').setDisplaySize(w, h);
  this.physics.world.setBounds(WALL_MARGIN, WALL_MARGIN, w - WALL_MARGIN*2, h - WALL_MARGIN*2);

  // puck
  puck = this.physics.add.image(cx, h/2, 'puck').setScale(PUCK_SCALE);
  puck.setCollideWorldBounds(true).setBounce(0.995).setDamping(true).setDrag(0.995,0.995).setMaxVelocity(2000);
  puck.body.setCircle(puck.displayWidth/2); centerBodyOnTexture(puck);

  // paddles
  player = this.physics.add.image(cx, h*0.85, 'paddle_gold').setScale(PADDLE_SCALE);
  cpu    = this.physics.add.image(cx, h*0.15, 'paddle_green').setScale(PADDLE_SCALE);
  [player,cpu].forEach(p=>{
    p.setImmovable(true);
    p.setCollideWorldBounds(true);
    p.body.setCircle(p.displayWidth/2);
    centerBodyOnTexture(p);
  });

  // init glide target
  playerTarget.x = player.x; playerTarget.y = player.y;

  // goal sensors
  goalTop = this.add.rectangle(cx, WALL_MARGIN - 8, GOAL_HALF*2, 28, 0xffffff, 0);
  goalBottom = this.add.rectangle(cx, h - (WALL_MARGIN - 8), GOAL_HALF*2, 28, 0xffffff, 0);
  this.physics.add.existing(goalTop, true);
  this.physics.add.existing(goalBottom, true);
  this.physics.add.overlap(puck, goalTop, ()=>onGoal.call(this,'top'), null, this);
  this.physics.add.overlap(puck, goalBottom, ()=>onGoal.call(this,'bottom'), null, this);

  // sfx
  this.sfx = {hit:null,goal:null};
  try{
    this.sfx.hit  = this.sound.add('hit',{volume:.38});
    this.sfx.goal = this.sound.add('goal',{volume:.55});
  }catch(e){}

  // touch helper ring
  ring = this.add.graphics({ x: 0, y: 0 });
  ring.lineStyle(2, 0xFFE175, 0.8).strokeCircle(0, 0, Math.max(22, player.displayWidth*0.35));
  ring.setAlpha(0);

  // BIGGER control zone for finger slide (lower portion)
  const controlTop = Math.max(h*0.52, h*0.5);
  lowerZone = this.add.zone(w/2, controlTop + (h - controlTop)/2, w, h - controlTop)
                 .setInteractive({useHandCursor:false});

  const clamp = Phaser.Math.Clamp;
  const clampToPlayerField=(gx,gy)=>{
    const ww=this.scale.width, hh=this.scale.height;
    const half = player.displayWidth*0.5;
    const x = clamp(gx, WALL_MARGIN + half, ww - (WALL_MARGIN + half));
    const y = clamp(gy + POINTER_OFFSET_Y, Math.max(controlTop, hh*0.5) + half, hh - WALL_MARGIN);
    return {x,y};
  };

  // Smooth target setter (don‚Äôt snap)
  const setTarget=(gx,gy)=>{
    if(!gameArmed) return;
    const t = clampToPlayerField(gx,gy);
    playerTarget.x = t.x; playerTarget.y = t.y;
    ring.x = gx; ring.y = gy;
  };

  // TOUCH GLIDE ‚Äî single pointer id to prevent ‚Äúhops‚Äù
  lowerZone.on('pointerdown',(p)=>{ if(!gameArmed) return; touchActive=true; touchId=p.id; ring.setAlpha(0.6); setTarget(p.worldX,p.worldY); });
  lowerZone.on('pointermove',(p)=>{ if(!gameArmed) return; if(touchActive && p.id===touchId){ setTarget(p.worldX,p.worldY); } });
  lowerZone.on('pointerup',  (p)=>{ if(p.id===touchId){ touchActive=false; ring.setAlpha(0); } });
  lowerZone.on('pointerout', (p)=>{ if(p.id===touchId){ touchActive=false; ring.setAlpha(0); } });

  // drag paddle updates target (not position)
  const r = player.displayWidth*0.5;
  player.setInteractive(new Phaser.Geom.Circle(0,0,r), Phaser.Geom.Circle.Contains);
  this.input.setDraggable(player);
  this.input.dragDistanceThreshold=0;
  player.on('drag',(pointer,dragX,dragY)=>{ if(!gameArmed) return; ring.setAlpha(0.6); setTarget(dragX,dragY); });
  this.input.on('pointerup', ()=> ring.setAlpha(0));

  // score text
  scoreText = this.add.text(cx, 40, '0 - 0', {fontFamily:'Orbitron',fontSize:'48px',color:'#ffe175',stroke:'#2fbf6b',strokeThickness:3}).setOrigin(0.5,0);

  // drop countdown
  dropText = this.add.text(cx, h/2, '', {fontFamily:'Orbitron',fontSize:'120px',color:'#ffe175',stroke:'#2fbf6b',strokeThickness:8}).setOrigin(0.5,0.5);
  dropText.setAlpha(0);

  // GATE
  const gate = document.getElementById('startGate');
  const gateStartBtn  = document.getElementById('gateStartBtn');
  gate.style.display='flex'; // force choose before play
  gameArmed=false;

  gateStartBtn.addEventListener('click', ()=>{
    gate.style.display='none';
    gameArmed = true;
    startNewMatch(this);
  });

  paintTopHud();
}

/* ------- Match / Game Flow ------- */
function startNewMatch(scene){
  series.p=0; series.c=0; series.gameIndex=1; series.nextServe='player';
  series.need = (series.best>>1)+1;
  paintTopHud();
  window.dispatchEvent(new CustomEvent('bag:matchStart',{detail:{game:'Air Hockey', best:series.best}}));
  startNewGame(scene,false);
}
function startNewGame(scene, alternate=true){
  if(!gameArmed) return;
  if(alternate && window.__AH_RULES__.serve.alternateByGame){
    series.nextServe = (series.nextServe==='player')?'cpu':'player';
  }
  scorePlayer=0; scoreCPU=0; goalLock=false;
  clock.remain = clock.total; clock.running=false; clock.sudden=false;
  dropText.setText('').setAlpha(0);
  scoreText.setText('0 - 0');
  paintTopHud();
  serveCountdown(scene, series.nextServe, ()=>{ if(gameArmed) clock.running=true; });
}

/* ------- Countdown beeps ------- */
function serveCountdown(scene, who, onDone){
  if(!gameArmed) return;
  const seq=['3','2','1'];
  const freqs=[880,700,560];
  let i=0;
  dropText.setAlpha(1);
  const tick=()=>{
    if(!gameArmed){ dropText.setAlpha(0).setText(''); return; }
    if(i<seq.length){
      dropText.setText(seq[i]);
      try{ AudioFX.beep(freqs[i], 140, 0.07); }catch{}
      i++; scene.time.delayedCall(320,tick);
    } else {
      dropText.setAlpha(0).setText('');
      serve(scene, who==='player'?'cpu':'player');
      if(typeof onDone==='function') onDone();
      flashServeArrows(who);
    }
  };
  tick();
}
function flashServeArrows(serving){
  const p=document.getElementById('servePlayer'), c=document.getElementById('serveCPU');
  if(serving==='player'){ p.style.opacity='1'; c.style.opacity='.25'; }
  else { p.style.opacity='.25'; c.style.opacity='1'; }
}

/* ------- Goals / Win logic ------- */
function onGoal(side){
  if(!gameArmed || goalLock || !puck?.body?.enable) return;
  try{ this.sfx?.goal?.play(); }catch{}
  if(side==='top') scorePlayer++; else scoreCPU++;
  startGoalSink.call(this, side);

  const target = parseInt(document.getElementById('targetGoals').value,10) || window.__AH_RULES__.targetGoals.default;
  if(Math.abs(scorePlayer - scoreCPU) >= (window.__AH_RULES__.mercyLead||5)){
    finishGame(this, scorePlayer>scoreCPU?'player':'cpu', 'Mercy'); return;
  }
  if(scorePlayer>=target || scoreCPU>=target){
    finishGame(this, scorePlayer>scoreCPU?'player':'cpu', 'Target'); return;
  }
  if(clock.sudden){ finishGame(this, scorePlayer>scoreCPU?'player':'cpu', 'Sudden Death'); }
}

/* ------- Finish / Next ------- */
function finishGame(scene, winner, reason){
  clock.running=false;
  try{ AudioFX.buzzer(900, 0.08); }catch{}
  window.__AH_LAST__ = `${winner==='player'?'You':'CPU'} won (${reason})`;
  window.dispatchEvent(new CustomEvent('bag:hudRefresh'));

  if(winner==='player') series.p++; else series.c++;
  paintTopHud();

  if(series.p>=series.need || series.c>=series.need){
    const matchWinner = (series.p>series.c)?'player':'cpu';
    window.dispatchEvent(new CustomEvent('bag:matchEnd',{detail:{game:'Air Hockey', winner:matchWinner, series:{p:series.p,c:series.c,best:series.best}}}));
    alert(`Match over ‚Äî ${matchWinner==='player'?'You':'CPU'} win ${series.p}‚Äì${series.c} (Bo${series.best})`);
    // Re-arm gate for new match
    series.gameIndex=1; series.p=0; series.c=0;
    series.nextServe = (series.nextServe==='player')?'cpu':'player';
    document.getElementById('startGate').style.display='flex';
    gameArmed=false;
    return;
  }
  series.gameIndex++;
  startNewGame(scene,true);
}

/* ------- Utils ------- */
function centerBodyOnTexture(img){
  const bw=img.body.width, bh=img.body.height;
  img.body.setOffset(img.width/2-bw/2, img.height/2-bh/2);
}
function resolvePaddle(paddle, prev, scene){
  if(!gameArmed) return;
  if(goalLock || !puck.body || !puck.body.enable) return;
  const dx=puck.x-paddle.x, dy=puck.y-paddle.y, dist=Math.hypot(dx,dy)||0.0001;
  const rSum=puck.displayWidth/2+paddle.displayWidth/2;
  if(dist<rSum){
    const nx=dx/dist, ny=dy/dist, pen=rSum-dist;
    puck.x+=nx*pen; puck.y+=ny*pen;

    const pvx=(paddle.x-prev.x)*60, pvy=(paddle.y-prev.y)*60;
    const tx=-ny, ty=nx, vN=pvx*nx+pvy*ny, vT=pvx*tx+pvy*ty;

    const base=500, gainN=8.5, gainT=4.7, maxV=2000;
    const vx=nx*(base+gainN*Math.abs(vN)) + tx*(vT*gainT);
    const vy=ny*(base+gainN*Math.abs(vN)) + ty*(vT*gainT);
    puck.setVelocity(Phaser.Math.Clamp(vx,-maxV,maxV), Phaser.Math.Clamp(vy,-maxV,maxV));

    const spin=Phaser.Math.Clamp(vT*1.5,-450,450);
    puck.setAngularVelocity(spin);

    // HIT SFX only on paddle contact
    try{
      const now=performance.now();
      if(now - lastHitAt > 70){
        scene.sfx?.hit?.setDetune?.(Phaser.Math.Between(-60,50));
        scene.sfx?.hit?.play({ volume:.38 });
        lastHitAt = now;
      }
    }catch{}
  }
}

/* ------- Update (AI + Clock + TOUCH GLIDE) ------- */
function update(time, delta){
  // clock display even when gated
  document.getElementById('clock').textContent = gameArmed ? mmss(clock.remain) : mmss(clock.total);

  // Smoothly move paddle toward target to kill ‚Äúhop‚Äù
  player.x = lerp(player.x, playerTarget.x, 0.35);
  player.y = lerp(player.y, playerTarget.y, 0.35);

  if(!gameArmed) return;

  const w=this.scale.width, h=this.scale.height;
  if(!goalLock){
    // CPU AI
    const cx = w/2;
    const rCpu = cpu.displayWidth * 0.5;
    const rPuck = puck.displayWidth * 0.5;

    const nearTop = puck.y < h*0.45;
    const nearSide = (puck.x < WALL_MARGIN + CORNER_BAND) || (puck.x > w - (WALL_MARGIN + CORNER_BAND));
    const pullToCenter = (nearTop && nearSide) ? 0.35 : 0.0;

    const targetX = lerp(cpu.x, Phaser.Math.Clamp(lerp(puck.x, cx, pullToCenter), WALL_MARGIN + rCpu, w - (WALL_MARGIN + rCpu)), 0.10);
    const cpuChaseDepth = Math.min(puck.y, h*0.38);
    const targetY = lerp(cpu.y, Phaser.Math.Clamp(cpuChaseDepth, WALL_MARGIN + rCpu, h*0.45), 0.06);

    cpu.x = targetX; cpu.y = targetY;

    const nearWall = (puck.x < WALL_MARGIN + rPuck + 8) ||
                     (puck.x > w - (WALL_MARGIN + rPuck + 8)) ||
                     (puck.y < WALL_MARGIN + rPuck + 8);
    const dxPC = puck.x - cpu.x, dyPC = puck.y - cpu.y, dPC = Math.hypot(dxPC, dyPC) || 1;
    const minGap = (rCpu + rPuck) * 0.95;
    if(nearWall && dPC < minGap){
      const push = (minGap - dPC) * 0.6;
      cpu.x -= (dxPC / dPC) * push;
      cpu.y -= (dyPC / dPC) * push;
      cpu.x = Phaser.Math.Clamp(cpu.x, WALL_MARGIN + rCpu, w - (WALL_MARGIN + rCpu));
      cpu.y = Phaser.Math.Clamp(cpu.y, WALL_MARGIN + rCpu, h*0.45);
    }

    // Corner escape
    const v = puck.body ? puck.body.velocity : {x:0,y:0};
    const speed = Math.hypot(v.x, v.y);
    const inCpuHalf = puck.y < h * 0.5;
    const inCornerish = inCpuHalf &&
      (puck.y < WALL_MARGIN + CORNER_BAND) &&
      ((puck.x < WALL_MARGIN + CORNER_BAND) || (puck.x > w - (WALL_MARGIN + CORNER_BAND)));
    if(inCornerish && speed < STUCK_SPEED){
      const now=performance.now();
      if(!stuckStart) stuckStart = now;
      const longEnough = (now - stuckStart) > STUCK_TIME_MS;
      const cooled = (now - lastKickAt) > STUCK_COOLDOWN;
      if(longEnough && cooled){
        const toCenter = new Phaser.Math.Vector2(w/2 - puck.x, (h*0.35) - puck.y).normalize();
        puck.setVelocity(toCenter.x * 900, toCenter.y * 900);
        cpu.y = Math.min(cpu.y + 40, CPU_RETREAT_Y);
        lastKickAt = now; stuckStart = 0;
      }
    } else { stuckStart = 0; }

    const curPlayer={x:player.x,y:player.y};
    const curCPU={x:cpu.x,y:cpu.y};
    resolvePaddle(player, prevPlayer, this);
    resolvePaddle(cpu,    prevCPU,  this);
    prevPlayer=curPlayer; prevCPU=curCPU;

    if(puck.body && puck.body.enable){
      const v2=puck.body.velocity, vmax=2000, keep=0.999;
      v2.x = Phaser.Math.Clamp(v2.x*keep,-vmax,vmax);
      v2.y = Phaser.Math.Clamp(v2.y*keep,-vmax,vmax);
    }
  }

  // game clock
  if(clock.running && !goalLock){
    clock.remain -= delta;
    if(!clock.sudden && clock.remain<=0){
      clock.sudden = true;
      clock.remain = 0;
      document.getElementById('clock').parentElement.style.boxShadow='0 0 0 2px rgba(255,225,117,.25) inset';
      clock.otStart = performance.now();
    } else if(clock.sudden){
      if(performance.now() - clock.otStart > (window.__AH_RULES__.overtimeCapSec||60)*1000){
        whistleCenterDrop(this);
        clock.otStart = performance.now();
      }
    }
  }

  scoreText.setText(`${scorePlayer} - ${scoreCPU}`);
}

/* ------- Whistle / Serve / Sink ------- */
function whistleCenterDrop(scene){
  goalLock = true;
  puck.setVelocity(0,0); puck.setAngularVelocity(0);
  puck.setPosition(scene.scale.width/2, scene.scale.height/2);
  scene.time.delayedCall(250, ()=>{
    goalLock=false;
    serveCountdown(scene, series.nextServe, ()=>{ if(gameArmed) clock.running=true; });
  });
}
function startGoalSink(side){
  if(goalLock || !puck) return;
  const scene=this, w=scene.scale.width, h=scene.scale.height, cx=w/2;
  goalLock = true;

  puck.setVelocity(0,0);
  puck.setAngularVelocity(0);
  if(puck.body){ puck.body.checkCollision.none = true; puck.body.enable = false; }
  puck.setCollideWorldBounds(false);

  const targetY = (side==='top') ? -40 : (h+40);
  scene.tweens.add({
    targets: puck, x: cx, y: targetY, scaleX: puck.scaleX*0.55, scaleY: puck.scaleY*0.55, alpha: 0,
    duration: 230, ease: 'Quad.easeIn',
    onComplete: ()=>{
      series.nextServe = (side==='top') ? 'cpu' : 'player';
      serve(scene, series.nextServe==='player'?'cpu':'player');
      scene.time.delayedCall(window.__AH_RULES__.serve.dropCountdownMs||900, ()=>{
        if(puck){ puck.setAlpha(1).setScale(PUCK_SCALE); if(puck.body){ puck.body.enable=true; puck.body.checkCollision.none=false; } }
        goalLock=false;
        if(gameArmed) clock.running=true;
        flashServeArrows(series.nextServe);
      });
    }
  });
}
function serve(scene, scoredBy){
  const w=scene.scale.width, h=scene.scale.height;
  puck.setPosition(w/2, h/2).setAlpha(1).setScale(PUCK_SCALE);
  if(!puck.body){ scene.physics.add.existing(puck); }
  puck.body.enable = true; puck.body.checkCollision.none = false;
  puck.setCollideWorldBounds(true);
  puck.body.setCircle(puck.displayWidth/2);
  centerBodyOnTexture(puck);

  const angle=Phaser.Math.Between(20,160)*(Phaser.Math.Between(0,1)?1:-1);
  const speed=Phaser.Math.Between(650,800);
  const vx=Math.cos(angle*Math.PI/180)*speed;
  const vy=(scoredBy==='player'?-1:1)*Math.abs(Math.sin(angle*Math.PI/180)*speed);
  puck.setVelocity(vx,vy);
  puck.setAngularVelocity(Phaser.Math.Between(-120,120));

  window.__AH_LAST__ = 'Serve';
  window.dispatchEvent(new CustomEvent('bag:hudRefresh'));
}

/* ------- HUD paint ------- */
function paintTopHud(){
  document.getElementById('seriesScore').textContent = `${series.p}‚Äì${series.c}`;
  document.getElementById('clock').textContent = mmss(clock.remain);
  flashServeArrows(series.nextServe);
}
</script>
</body>
</html>
